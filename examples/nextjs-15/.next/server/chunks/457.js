exports.ids = ['457'];
exports.modules = {
  7014: function (module, exports) {
    'use strict';
    // This gets assigned as a side-effect during app initialization. Because it
    // represents the build used to create the JS bundle, it should never change
    // after being set, so we store it in a global variable.
    //
    // When performing RSC requests, if the incoming data has a different build ID,
    // we perform an MPA navigation/refresh to load the updated build and ensure
    // that the client and server in sync.
    // Starts as an empty string. In practice, because setAppBuildId is called
    // during initialization before hydration starts, this will always get
    // reassigned to the actual build ID before it's ever needed by a navigation.
    // If for some reasons it didn't, due to a bug or race condition, then on
    // navigation the build comparision would fail and trigger an MPA navigation.

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getAppBuildId: function () {
        return getAppBuildId;
      },
      setAppBuildId: function () {
        return setAppBuildId;
      },
    });
    let globalBuildId = '';
    function setAppBuildId(buildId) {
      globalBuildId = buildId;
    }
    function getAppBuildId() {
      return globalBuildId;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=app-build-id.js.map
  },
  9292: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'callServer', {
      enumerable: true,
      get: function () {
        return callServer;
      },
    });
    const _react = __webpack_require__(863);
    const _routerreducertypes = __webpack_require__(77);
    const _useactionqueue = __webpack_require__(4297);
    async function callServer(actionId, actionArgs) {
      return new Promise((resolve, reject) => {
        (0, _react.startTransition)(() => {
          (0, _useactionqueue.dispatchAppRouterAction)({
            type: _routerreducertypes.ACTION_SERVER_ACTION,
            actionId,
            actionArgs,
            resolve,
            reject,
          });
        });
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=app-call-server.js.map
  },
  160: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'findSourceMapURL', {
      enumerable: true,
      get: function () {
        return findSourceMapURL;
      },
    });
    const basePath = false || '';
    const pathname = '' + basePath + '/__nextjs_source-map';
    const findSourceMapURL = true
      ? function findSourceMapURL(filename) {
          if (filename === '') {
            return null;
          }
          if (
            filename.startsWith(document.location.origin) &&
            filename.includes('/_next/static')
          ) {
            // This is a request for a client chunk. This can only happen when
            // using Turbopack. In this case, since we control how those source
            // maps are generated, we can safely assume that the sourceMappingURL
            // is relative to the filename, with an added `.map` extension. The
            // browser can just request this file, and it gets served through the
            // normal dev server, without the need to route this through
            // the `/__nextjs_source-map` dev middleware.
            return '' + filename + '.map';
          }
          const url = new URL(pathname, document.location.origin);
          url.searchParams.set('filename', filename);
          return url.href;
        }
      : 0;
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=app-find-source-map-url.js.map
  },
  7079: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ACTION_HEADER: function () {
        return ACTION_HEADER;
      },
      FLIGHT_HEADERS: function () {
        return FLIGHT_HEADERS;
      },
      NEXT_DID_POSTPONE_HEADER: function () {
        return NEXT_DID_POSTPONE_HEADER;
      },
      NEXT_HMR_REFRESH_HASH_COOKIE: function () {
        return NEXT_HMR_REFRESH_HASH_COOKIE;
      },
      NEXT_HMR_REFRESH_HEADER: function () {
        return NEXT_HMR_REFRESH_HEADER;
      },
      NEXT_IS_PRERENDER_HEADER: function () {
        return NEXT_IS_PRERENDER_HEADER;
      },
      NEXT_REWRITTEN_PATH_HEADER: function () {
        return NEXT_REWRITTEN_PATH_HEADER;
      },
      NEXT_REWRITTEN_QUERY_HEADER: function () {
        return NEXT_REWRITTEN_QUERY_HEADER;
      },
      NEXT_ROUTER_PREFETCH_HEADER: function () {
        return NEXT_ROUTER_PREFETCH_HEADER;
      },
      NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: function () {
        return NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;
      },
      NEXT_ROUTER_STALE_TIME_HEADER: function () {
        return NEXT_ROUTER_STALE_TIME_HEADER;
      },
      NEXT_ROUTER_STATE_TREE_HEADER: function () {
        return NEXT_ROUTER_STATE_TREE_HEADER;
      },
      NEXT_RSC_UNION_QUERY: function () {
        return NEXT_RSC_UNION_QUERY;
      },
      NEXT_URL: function () {
        return NEXT_URL;
      },
      RSC_CONTENT_TYPE_HEADER: function () {
        return RSC_CONTENT_TYPE_HEADER;
      },
      RSC_HEADER: function () {
        return RSC_HEADER;
      },
    });
    const RSC_HEADER = 'RSC';
    const ACTION_HEADER = 'Next-Action';
    const NEXT_ROUTER_STATE_TREE_HEADER = 'Next-Router-State-Tree';
    const NEXT_ROUTER_PREFETCH_HEADER = 'Next-Router-Prefetch';
    const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'Next-Router-Segment-Prefetch';
    const NEXT_HMR_REFRESH_HEADER = 'Next-HMR-Refresh';
    const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';
    const NEXT_URL = 'Next-Url';
    const RSC_CONTENT_TYPE_HEADER = 'text/x-component';
    const FLIGHT_HEADERS = [
      RSC_HEADER,
      NEXT_ROUTER_STATE_TREE_HEADER,
      NEXT_ROUTER_PREFETCH_HEADER,
      NEXT_HMR_REFRESH_HEADER,
      NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,
    ];
    const NEXT_RSC_UNION_QUERY = '_rsc';
    const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';
    const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';
    const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';
    const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';
    const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=app-router-headers.js.map
  },
  7826: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'bailoutToClientRendering', {
      enumerable: true,
      get: function () {
        return bailoutToClientRendering;
      },
    });
    const _bailouttocsr = __webpack_require__(2926);
    const _workasyncstorageexternal = __webpack_require__(9348);
    function bailoutToClientRendering(reason) {
      const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
      if (workStore == null ? void 0 : workStore.forceStatic) return;
      if (workStore == null ? void 0 : workStore.isStaticGeneration)
        throw Object.defineProperty(
          new _bailouttocsr.BailoutToCSRError(reason),
          '__NEXT_ERROR_CODE',
          {
            value: 'E394',
            enumerable: false,
            configurable: true,
          }
        );
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=bailout-to-client-rendering.js.map
  },
  8306: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ClientPageRoot', {
      enumerable: true,
      get: function () {
        return ClientPageRoot;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _invarianterror = __webpack_require__(2748);
    function ClientPageRoot(param) {
      let { Component, searchParams, params, promises } = param;
      if (true) {
        const { workAsyncStorage } = __webpack_require__(9348);
        let clientSearchParams;
        let clientParams;
        // We are going to instrument the searchParams prop with tracking for the
        // appropriate context. We wrap differently in prerendering vs rendering
        const store = workAsyncStorage.getStore();
        if (!store) {
          throw Object.defineProperty(
            new _invarianterror.InvariantError(
              'Expected workStore to exist when handling searchParams in a client Page.'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E564',
              enumerable: false,
              configurable: true,
            }
          );
        }
        const { createSearchParamsFromClient } = __webpack_require__(980);
        clientSearchParams = createSearchParamsFromClient(searchParams, store);
        const { createParamsFromClient } = __webpack_require__(4265);
        clientParams = createParamsFromClient(params, store);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {
          params: clientParams,
          searchParams: clientSearchParams,
        });
      } else {
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=client-page.js.map
  },
  7210: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ClientSegmentRoot', {
      enumerable: true,
      get: function () {
        return ClientSegmentRoot;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _invarianterror = __webpack_require__(2748);
    function ClientSegmentRoot(param) {
      let { Component, slots, params, promise } = param;
      if (true) {
        const { workAsyncStorage } = __webpack_require__(9348);
        let clientParams;
        // We are going to instrument the searchParams prop with tracking for the
        // appropriate context. We wrap differently in prerendering vs rendering
        const store = workAsyncStorage.getStore();
        if (!store) {
          throw Object.defineProperty(
            new _invarianterror.InvariantError(
              'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E600',
              enumerable: false,
              configurable: true,
            }
          );
        }
        const { createParamsFromClient } = __webpack_require__(4265);
        clientParams = createParamsFromClient(params, store);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {
          ...slots,
          params: clientParams,
        });
      } else {
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=client-segment.js.map
  },
  5534: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorBoundary: function () {
        return ErrorBoundary;
      },
      ErrorBoundaryHandler: function () {
        return ErrorBoundaryHandler;
      },
      GlobalError: function () {
        return GlobalError;
      },
      // Exported so that the import signature in the loaders can be identical to user
      // supplied custom global error signatures.
      default: function () {
        return _default;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(863));
    const _navigationuntracked = __webpack_require__(7337);
    const _isnextroutererror = __webpack_require__(9603);
    const _navfailurehandler = __webpack_require__(3761);
    const workAsyncStorage = true
      ? __webpack_require__(9348) /* .workAsyncStorage */.workAsyncStorage
      : 0;
    const styles = {
      error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily:
          'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: '100vh',
        textAlign: 'center',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
      },
      text: {
        fontSize: '14px',
        fontWeight: 400,
        lineHeight: '28px',
        margin: '0 8px',
      },
    };
    // if we are revalidating we want to re-throw the error so the
    // function crashes so we can maintain our previous cache
    // instead of caching the error page
    function HandleISRError(param) {
      let { error } = param;
      if (workAsyncStorage) {
        const store = workAsyncStorage.getStore();
        if (
          (store == null ? void 0 : store.isRevalidate) ||
          (store == null ? void 0 : store.isStaticGeneration)
        ) {
          console.error(error);
          throw error;
        }
      }
      return null;
    }
    class ErrorBoundaryHandler extends _react.default.Component {
      static getDerivedStateFromError(error) {
        if ((0, _isnextroutererror.isNextRouterError)(error)) {
          // Re-throw if an expected internal Next.js router error occurs
          // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)
          throw error;
        }
        return {
          error,
        };
      }
      static getDerivedStateFromProps(props, state) {
        const { error } = state;
        // if we encounter an error while
        // a navigation is pending we shouldn't render
        // the error boundary and instead should fallback
        // to a hard navigation to attempt recovering
        if (false) {
        }
        /**
         * Handles reset of the error boundary when a navigation happens. Ensures the
         * error boundary does not stay enabled when navigating to a new page. Approach of
         * setState in render is safe as it checks the previous pathname and then
         * overrides it as outlined in
         * https://react.dev/reference/react/useState#storing-information-from-previous-renders
         */ if (props.pathname !== state.previousPathname && state.error) {
          return {
            error: null,
            previousPathname: props.pathname,
          };
        }
        return {
          error: state.error,
          previousPathname: props.pathname,
        };
      }
      // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.
      render() {
        if (this.state.error) {
          return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsx)(HandleISRError, {
                error: this.state.error,
              }),
              this.props.errorStyles,
              this.props.errorScripts,
              /*#__PURE__*/ (0, _jsxruntime.jsx)(this.props.errorComponent, {
                error: this.state.error,
                reset: this.reset,
              }),
            ],
          });
        }
        return this.props.children;
      }
      constructor(props) {
        super(props),
          (this.reset = () => {
            this.setState({
              error: null,
            });
          });
        this.state = {
          error: null,
          previousPathname: this.props.pathname,
        };
      }
    }
    function GlobalError(param) {
      let { error } = param;
      const digest = error == null ? void 0 : error.digest;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('html', {
        id: '__next_error__',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('head', {}),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('body', {
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsx)(HandleISRError, {
                error: error,
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                style: styles.error,
                children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                  children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsxs)('h2', {
                      style: styles.text,
                      children: [
                        'Application error: a ',
                        digest ? 'server' : 'client',
                        '-side exception has occurred while loading ',
                        window.location.hostname,
                        ' (see the',
                        ' ',
                        digest ? 'server logs' : 'browser console',
                        ' for more information).',
                      ],
                    }),
                    digest
                      ? /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
                          style: styles.text,
                          children: 'Digest: ' + digest,
                        })
                      : null,
                  ],
                }),
              }),
            ],
          }),
        ],
      });
    }
    const _default = GlobalError;
    function ErrorBoundary(param) {
      let { errorComponent, errorStyles, errorScripts, children } = param;
      // When we're rendering the missing params shell, this will return null. This
      // is because we won't be rendering any not found boundaries or error
      // boundaries for the missing params shell. When this runs on the client
      // (where these errors can occur), we will get the correct pathname.
      const pathname = (0, _navigationuntracked.useUntrackedPathname)();
      if (errorComponent) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorBoundaryHandler, {
          pathname: pathname,
          errorComponent: errorComponent,
          errorStyles: errorStyles,
          errorScripts: errorScripts,
          children: children,
        });
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children,
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-boundary.js.map
  },
  8314: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'attachHydrationErrorState', {
      enumerable: true,
      get: function () {
        return attachHydrationErrorState;
      },
    });
    const _ishydrationerror = __webpack_require__(4291);
    const _hydrationerrorinfo = __webpack_require__(4614);
    function attachHydrationErrorState(error) {
      let parsedHydrationErrorState = {};
      const isHydrationWarning = (0, _ishydrationerror.testReactHydrationWarning)(
        error.message
      );
      const isHydrationRuntimeError = (0, _ishydrationerror.isHydrationError)(error);
      // If it's not hydration warnings or errors, skip
      if (!(isHydrationRuntimeError || isHydrationWarning)) {
        return;
      }
      const reactHydrationDiffSegments = (0,
      _hydrationerrorinfo.getReactHydrationDiffSegments)(error.message);
      // If the reactHydrationDiffSegments exists
      // and the diff (reactHydrationDiffSegments[1]) exists
      // e.g. the hydration diff log error.
      if (reactHydrationDiffSegments) {
        const diff = reactHydrationDiffSegments[1];
        parsedHydrationErrorState = {
          ...error.details,
          ..._hydrationerrorinfo.hydrationErrorState,
          // If diff is present in error, we don't need to pick up the console logged warning.
          // - if hydration error has diff, and is not hydration diff log, then it's a normal hydration error.
          // - if hydration error no diff, then leverage the one from the hydration diff log.
          warning: (diff && !isHydrationWarning
            ? null
            : _hydrationerrorinfo.hydrationErrorState.warning) || [
            (0, _ishydrationerror.getDefaultHydrationErrorMessage)(),
            '',
            '',
          ],
          // When it's hydration diff log, do not show notes section.
          // This condition is only for the 1st squashed error.
          notes: isHydrationWarning ? '' : reactHydrationDiffSegments[0],
          reactOutputComponentDiff: diff,
        };
        // Cache the `reactOutputComponentDiff` into hydrationErrorState.
        // This is only required for now when we still squashed the hydration diff log into hydration error.
        // Once the all error is logged to dev overlay in order, this will go away.
        if (!_hydrationerrorinfo.hydrationErrorState.reactOutputComponentDiff && diff) {
          _hydrationerrorinfo.hydrationErrorState.reactOutputComponentDiff = diff;
        }
        // If it's hydration runtime error that doesn't contain the diff, combine the diff from the cached hydration diff.
        if (
          !diff &&
          isHydrationRuntimeError &&
          _hydrationerrorinfo.hydrationErrorState.reactOutputComponentDiff
        ) {
          parsedHydrationErrorState.reactOutputComponentDiff =
            _hydrationerrorinfo.hydrationErrorState.reactOutputComponentDiff;
        }
      } else {
        // Normal runtime error, where it doesn't contain the hydration diff.
        // If there's any extra information in the error message to display,
        // append it to the error message details property
        if (_hydrationerrorinfo.hydrationErrorState.warning) {
          // The patched console.error found hydration errors logged by React
          // Append the logged warning to the error message
          parsedHydrationErrorState = {
            ...error.details,
            // It contains the warning, component stack, server and client tag names
            ..._hydrationerrorinfo.hydrationErrorState,
          };
        }
        // Consume the cached hydration diff.
        // This is only required for now when we still squashed the hydration diff log into hydration error.
        // Once the all error is logged to dev overlay in order, this will go away.
        if (_hydrationerrorinfo.hydrationErrorState.reactOutputComponentDiff) {
          parsedHydrationErrorState.reactOutputComponentDiff =
            _hydrationerrorinfo.hydrationErrorState.reactOutputComponentDiff;
        }
      }
      // If it's a hydration error, store the hydration error state into the error object
      error.details = parsedHydrationErrorState;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=attach-hydration-error-state.js.map
  },
  4980: function (module, exports) {
    'use strict';
    // To distinguish from React error.digest, we use a different symbol here to determine if the error is from console.error or unhandled promise rejection.

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      createConsoleError: function () {
        return createConsoleError;
      },
      getConsoleErrorType: function () {
        return getConsoleErrorType;
      },
      isConsoleError: function () {
        return isConsoleError;
      },
    });
    const digestSym = Symbol.for('next.console.error.digest');
    const consoleTypeSym = Symbol.for('next.console.error.type');
    function createConsoleError(message, environmentName) {
      const error =
        typeof message === 'string'
          ? Object.defineProperty(new Error(message), '__NEXT_ERROR_CODE', {
              value: 'E394',
              enumerable: false,
              configurable: true,
            })
          : message;
      error[digestSym] = 'NEXT_CONSOLE_ERROR';
      error[consoleTypeSym] = typeof message === 'string' ? 'string' : 'error';
      if (environmentName && !error.environmentName) {
        error.environmentName = environmentName;
      }
      return error;
    }
    const isConsoleError = (error) => {
      return error && error[digestSym] === 'NEXT_CONSOLE_ERROR';
    };
    const getConsoleErrorType = (error) => {
      return error[consoleTypeSym];
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=console-error.js.map
  },
  9294: function (module, exports) {
    'use strict';
    // Dedupe the two consecutive errors: If the previous one is same as current one, ignore the current one.

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'enqueueConsecutiveDedupedError', {
      enumerable: true,
      get: function () {
        return enqueueConsecutiveDedupedError;
      },
    });
    function enqueueConsecutiveDedupedError(queue, error) {
      const previousError = queue[queue.length - 1];
      // Compare the error stack to dedupe the consecutive errors
      if (previousError && previousError.stack === error.stack) {
        return;
      }
      queue.push(error);
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=enqueue-client-error.js.map
  },
  4614: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getHydrationWarningType: function () {
        return getHydrationWarningType;
      },
      getReactHydrationDiffSegments: function () {
        return getReactHydrationDiffSegments;
      },
      hydrationErrorState: function () {
        return hydrationErrorState;
      },
      storeHydrationErrorStateFromConsoleArgs: function () {
        return storeHydrationErrorStateFromConsoleArgs;
      },
    });
    const _ishydrationerror = __webpack_require__(4291);
    const hydrationErrorState = {};
    // https://github.com/facebook/react/blob/main/packages/react-dom/src/__tests__/ReactDOMHydrationDiff-test.js used as a reference
    const htmlTagsWarnings = new Set([
      'Warning: In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s',
      'Warning: In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s',
      'Warning: In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.',
      "Warning: In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.",
      'Warning: Expected server HTML to contain a matching <%s> in <%s>.%s',
      'Warning: Did not expect server HTML to contain a <%s> in <%s>.%s',
    ]);
    const textAndTagsMismatchWarnings = new Set([
      'Warning: Expected server HTML to contain a matching text node for "%s" in <%s>.%s',
      'Warning: Did not expect server HTML to contain the text node "%s" in <%s>.%s',
    ]);
    const getHydrationWarningType = (message) => {
      if (typeof message !== 'string') {
        // TODO: Doesn't make sense to treat no message as a hydration error message.
        // We should bail out somewhere earlier.
        return 'text';
      }
      const normalizedMessage = message.startsWith('Warning: ')
        ? message
        : 'Warning: ' + message;
      if (isHtmlTagsWarning(normalizedMessage)) return 'tag';
      if (isTextInTagsMismatchWarning(normalizedMessage)) return 'text-in-tag';
      return 'text';
    };
    const isHtmlTagsWarning = (message) => htmlTagsWarnings.has(message);
    const isTextInTagsMismatchWarning = (msg) => textAndTagsMismatchWarnings.has(msg);
    const getReactHydrationDiffSegments = (msg) => {
      if (msg) {
        const { message, diff } = (0, _ishydrationerror.getHydrationErrorStackInfo)(msg);
        if (message) return [message, diff];
      }
      return undefined;
    };
    function storeHydrationErrorStateFromConsoleArgs() {
      for (
        var _len = arguments.length, args = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        args[_key] = arguments[_key];
      }
      let [msg, firstContent, secondContent, ...rest] = args;
      if ((0, _ishydrationerror.testReactHydrationWarning)(msg)) {
        // Some hydration warnings has 4 arguments, some has 3, fallback to the last argument
        // when the 3rd argument is not the component stack but an empty string
        const isReact18 = msg.startsWith('Warning: ');
        // For some warnings, there's only 1 argument for template.
        // The second argument is the diff or component stack.
        if (args.length === 3) {
          secondContent = '';
        }
        const warning = [
          // remove the last %s from the message
          msg,
          firstContent,
          secondContent,
        ];
        const lastArg = (rest[rest.length - 1] || '').trim();
        if (!isReact18) {
          hydrationErrorState.reactOutputComponentDiff = lastArg;
        } else {
          hydrationErrorState.reactOutputComponentDiff = generateHydrationDiffReact18(
            msg,
            firstContent,
            secondContent,
            lastArg
          );
        }
        hydrationErrorState.warning = warning;
        hydrationErrorState.serverContent = firstContent;
        hydrationErrorState.clientContent = secondContent;
      }
    }
    /*
     * Some hydration errors in React 18 does not have the diff in the error message.
     * Instead it has the error stack trace which is component stack that we can leverage.
     * Will parse the diff from the error stack trace
     *  e.g.
     *  Warning: Expected server HTML to contain a matching <div> in <p>.
     *    at div
     *    at p
     *    at div
     *    at div
     *    at Page
     *  output:
     *    <Page>
     *      <div>
     *        <p>
     *  >       <div>
     *
     */ function generateHydrationDiffReact18(
      message,
      firstContent,
      secondContent,
      lastArg
    ) {
      const componentStack = lastArg;
      let firstIndex = -1;
      let secondIndex = -1;
      const hydrationWarningType = getHydrationWarningType(message);
      // at div\n at Foo\n at Bar (....)\n -> [div, Foo]
      const components = componentStack
        .split('\n') // .reverse()
        .map((line, index) => {
          // `<space>at <component> (<location>)` -> `at <component> (<location>)`
          line = line.trim();
          // extract `<space>at <component>` to `<<component>>`
          // e.g. `  at Foo` -> `<Foo>`
          const [, component, location] = /at (\w+)( \((.*)\))?/.exec(line) || [];
          // If there's no location then it's user-land stack frame
          if (!location) {
            if (component === firstContent && firstIndex === -1) {
              firstIndex = index;
            } else if (component === secondContent && secondIndex === -1) {
              secondIndex = index;
            }
          }
          return location ? '' : component;
        })
        .filter(Boolean)
        .reverse();
      let diff = '';
      for (let i = 0; i < components.length; i++) {
        const component = components[i];
        const matchFirstContent =
          hydrationWarningType === 'tag' && i === components.length - firstIndex - 1;
        const matchSecondContent =
          hydrationWarningType === 'tag' && i === components.length - secondIndex - 1;
        if (matchFirstContent || matchSecondContent) {
          const spaces = ' '.repeat(Math.max(i * 2 - 2, 0) + 2);
          diff += '> ' + spaces + '<' + component + '>\n';
        } else {
          const spaces = ' '.repeat(i * 2 + 2);
          diff += spaces + '<' + component + '>\n';
        }
      }
      if (hydrationWarningType === 'text') {
        const spaces = ' '.repeat(components.length * 2);
        diff += '+ ' + spaces + '"' + firstContent + '"\n';
        diff += '- ' + spaces + '"' + secondContent + '"\n';
      } else if (hydrationWarningType === 'text-in-tag') {
        const spaces = ' '.repeat(components.length * 2);
        diff += '> ' + spaces + '<' + secondContent + '>\n';
        diff += '>   ' + spaces + '"' + firstContent + '"\n';
      }
      return diff;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=hydration-error-info.js.map
  },
  5589: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'RuntimeErrorHandler', {
      enumerable: true,
      get: function () {
        return RuntimeErrorHandler;
      },
    });
    const RuntimeErrorHandler = {
      hadRuntimeError: false,
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=runtime-error-handler.js.map
  },
  9917: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'getReactStitchedError', {
      enumerable: true,
      get: function () {
        return getReactStitchedError;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(863));
    const _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(5336));
    const _errortelemetryutils = __webpack_require__(8053);
    const REACT_ERROR_STACK_BOTTOM_FRAME = 'react-stack-bottom-frame';
    const REACT_ERROR_STACK_BOTTOM_FRAME_REGEX = new RegExp(
      '(at ' +
        REACT_ERROR_STACK_BOTTOM_FRAME +
        ' )|(' +
        REACT_ERROR_STACK_BOTTOM_FRAME +
        '\\@)'
    );
    function getReactStitchedError(err) {
      const isErrorInstance = (0, _iserror.default)(err);
      const originStack = isErrorInstance ? err.stack || '' : '';
      const originMessage = isErrorInstance ? err.message : '';
      const stackLines = originStack.split('\n');
      const indexOfSplit = stackLines.findIndex((line) =>
        REACT_ERROR_STACK_BOTTOM_FRAME_REGEX.test(line)
      );
      const isOriginalReactError = indexOfSplit >= 0; // has the react-stack-bottom-frame
      let newStack = isOriginalReactError
        ? stackLines.slice(0, indexOfSplit).join('\n')
        : originStack;
      const newError = Object.defineProperty(
        new Error(originMessage),
        '__NEXT_ERROR_CODE',
        {
          value: 'E394',
          enumerable: false,
          configurable: true,
        }
      );
      // Copy all enumerable properties, e.g. digest
      Object.assign(newError, err);
      (0, _errortelemetryutils.copyNextErrorCode)(err, newError);
      newError.stack = newStack;
      // Avoid duplicate overriding stack frames
      appendOwnerStack(newError);
      return newError;
    }
    function appendOwnerStack(error) {
      if (!_react.default.captureOwnerStack) {
        return;
      }
      let stack = error.stack || '';
      // This module is only bundled in development mode so this is safe.
      const ownerStack = _react.default.captureOwnerStack();
      // Avoid duplicate overriding stack frames
      if (ownerStack && stack.endsWith(ownerStack) === false) {
        stack += ownerStack;
        // Override stack
        error.stack = stack;
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=stitched-error.js.map
  },
  6000: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      handleClientError: function () {
        return handleClientError;
      },
      handleConsoleError: function () {
        return handleConsoleError;
      },
      handleGlobalErrors: function () {
        return handleGlobalErrors;
      },
      useErrorHandler: function () {
        return useErrorHandler;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _react = __webpack_require__(863);
    const _attachhydrationerrorstate = __webpack_require__(8314);
    const _isnextroutererror = __webpack_require__(9603);
    const _hydrationerrorinfo = __webpack_require__(4614);
    const _console = __webpack_require__(4866);
    const _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(5336));
    const _consoleerror = __webpack_require__(4980);
    const _enqueueclienterror = __webpack_require__(9294);
    const _stitchederror = __webpack_require__(9917);
    const queueMicroTask =
      globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));
    const errorQueue = [];
    const errorHandlers = [];
    const rejectionQueue = [];
    const rejectionHandlers = [];
    function handleConsoleError(originError, consoleErrorArgs) {
      let error;
      const { environmentName } = (0, _console.parseConsoleArgs)(consoleErrorArgs);
      if ((0, _iserror.default)(originError)) {
        error = (0, _consoleerror.createConsoleError)(originError, environmentName);
      } else {
        error = (0, _consoleerror.createConsoleError)(
          (0, _console.formatConsoleArgs)(consoleErrorArgs),
          environmentName
        );
      }
      error = (0, _stitchederror.getReactStitchedError)(error);
      (0, _hydrationerrorinfo.storeHydrationErrorStateFromConsoleArgs)(
        ...consoleErrorArgs
      );
      (0, _attachhydrationerrorstate.attachHydrationErrorState)(error);
      (0, _enqueueclienterror.enqueueConsecutiveDedupedError)(errorQueue, error);
      for (const handler of errorHandlers) {
        // Delayed the error being passed to React Dev Overlay,
        // avoid the state being synchronously updated in the component.
        queueMicroTask(() => {
          handler(error);
        });
      }
    }
    function handleClientError(originError) {
      let error;
      if ((0, _iserror.default)(originError)) {
        error = originError;
      } else {
        // If it's not an error, format the args into an error
        const formattedErrorMessage = originError + '';
        error = Object.defineProperty(
          new Error(formattedErrorMessage),
          '__NEXT_ERROR_CODE',
          {
            value: 'E394',
            enumerable: false,
            configurable: true,
          }
        );
      }
      error = (0, _stitchederror.getReactStitchedError)(error);
      (0, _attachhydrationerrorstate.attachHydrationErrorState)(error);
      (0, _enqueueclienterror.enqueueConsecutiveDedupedError)(errorQueue, error);
      for (const handler of errorHandlers) {
        // Delayed the error being passed to React Dev Overlay,
        // avoid the state being synchronously updated in the component.
        queueMicroTask(() => {
          handler(error);
        });
      }
    }
    function useErrorHandler(handleOnUnhandledError, handleOnUnhandledRejection) {
      (0, _react.useEffect)(() => {
        // Handle queued errors.
        errorQueue.forEach(handleOnUnhandledError);
        rejectionQueue.forEach(handleOnUnhandledRejection);
        // Listen to new errors.
        errorHandlers.push(handleOnUnhandledError);
        rejectionHandlers.push(handleOnUnhandledRejection);
        return () => {
          // Remove listeners.
          errorHandlers.splice(errorHandlers.indexOf(handleOnUnhandledError), 1);
          rejectionHandlers.splice(
            rejectionHandlers.indexOf(handleOnUnhandledRejection),
            1
          );
          // Reset error queues.
          errorQueue.splice(0, errorQueue.length);
          rejectionQueue.splice(0, rejectionQueue.length);
        };
      }, [handleOnUnhandledError, handleOnUnhandledRejection]);
    }
    function onUnhandledError(event) {
      if ((0, _isnextroutererror.isNextRouterError)(event.error)) {
        event.preventDefault();
        return false;
      }
      // When there's an error property present, we log the error to error overlay.
      // Otherwise we don't do anything as it's not logging in the console either.
      if (event.error) {
        handleClientError(event.error);
      }
    }
    function onUnhandledRejection(ev) {
      const reason = ev == null ? void 0 : ev.reason;
      if ((0, _isnextroutererror.isNextRouterError)(reason)) {
        ev.preventDefault();
        return;
      }
      let error = reason;
      if (error && !(0, _iserror.default)(error)) {
        error = Object.defineProperty(new Error(error + ''), '__NEXT_ERROR_CODE', {
          value: 'E394',
          enumerable: false,
          configurable: true,
        });
      }
      rejectionQueue.push(error);
      for (const handler of rejectionHandlers) {
        handler(error);
      }
    }
    function handleGlobalErrors() {
      if (false) {
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=use-error-handler.js.map
  },
  1364: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'forbidden', {
      enumerable: true,
      get: function () {
        return forbidden;
      },
    });
    const _httpaccessfallback = __webpack_require__(4114);
    // TODO: Add `forbidden` docs
    /**
     * @experimental
     * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)
     * within a route segment as well as inject a tag.
     *
     * `forbidden()` can be used in
     * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
     * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
     * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
     *
     * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)
     */ const DIGEST = '' + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ';403';
    function forbidden() {
      if (true) {
        throw Object.defineProperty(
          new Error(
            '`forbidden()` is experimental and only allowed to be enabled when `experimental.authInterrupts` is enabled.'
          ),
          '__NEXT_ERROR_CODE',
          {
            value: 'E488',
            enumerable: false,
            configurable: true,
          }
        );
      }
      // eslint-disable-next-line no-throw-literal
      const error = Object.defineProperty(new Error(DIGEST), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: false,
        configurable: true,
      });
      error.digest = DIGEST;
      throw error;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=forbidden.js.map
  },
  2129: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DynamicServerError: function () {
        return DynamicServerError;
      },
      isDynamicServerError: function () {
        return isDynamicServerError;
      },
    });
    const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';
    class DynamicServerError extends Error {
      constructor(description) {
        super('Dynamic server usage: ' + description),
          (this.description = description),
          (this.digest = DYNAMIC_ERROR_CODE);
      }
    }
    function isDynamicServerError(err) {
      if (
        typeof err !== 'object' ||
        err === null ||
        !('digest' in err) ||
        typeof err.digest !== 'string'
      ) {
        return false;
      }
      return err.digest === DYNAMIC_ERROR_CODE;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=hooks-server-context.js.map
  },
  8419: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'HTTPAccessFallbackBoundary', {
      enumerable: true,
      get: function () {
        return HTTPAccessFallbackBoundary;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _navigationuntracked = __webpack_require__(7337);
    const _httpaccessfallback = __webpack_require__(4114);
    const _warnonce = __webpack_require__(1859);
    const _approutercontextsharedruntime = __webpack_require__(1727);
    class HTTPAccessFallbackErrorBoundary extends _react.default.Component {
      componentDidCatch() {
        if (
          true &&
          this.props.missingSlots &&
          this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn
          !this.props.missingSlots.has('children')
        ) {
          let warningMessage =
            'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\n' +
            'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\n\n';
          const formattedSlots = Array.from(this.props.missingSlots)
            .sort((a, b) => a.localeCompare(b))
            .map((slot) => '@' + slot)
            .join(', ');
          warningMessage += 'Missing slots: ' + formattedSlots;
          (0, _warnonce.warnOnce)(warningMessage);
        }
      }
      static getDerivedStateFromError(error) {
        if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {
          const httpStatus = (0, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);
          return {
            triggeredStatus: httpStatus,
          };
        }
        // Re-throw if error is not for 404
        throw error;
      }
      static getDerivedStateFromProps(props, state) {
        /**
         * Handles reset of the error boundary when a navigation happens. Ensures the
         * error boundary does not stay enabled when navigating to a new page. Approach of
         * setState in render is safe as it checks the previous pathname and then
         * overrides it as outlined in
         * https://react.dev/reference/react/useState#storing-information-from-previous-renders
         */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {
          return {
            triggeredStatus: undefined,
            previousPathname: props.pathname,
          };
        }
        return {
          triggeredStatus: state.triggeredStatus,
          previousPathname: props.pathname,
        };
      }
      render() {
        const { notFound, forbidden, unauthorized, children } = this.props;
        const { triggeredStatus } = this.state;
        const errorComponents = {
          [_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,
          [_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,
          [_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,
        };
        if (triggeredStatus) {
          const isNotFound =
            triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND &&
            notFound;
          const isForbidden =
            triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN &&
            forbidden;
          const isUnauthorized =
            triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED &&
            unauthorized;
          // If there's no matched boundary in this layer, keep throwing the error by rendering the children
          if (!(isNotFound || isForbidden || isUnauthorized)) {
            return children;
          }
          return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsx)('meta', {
                name: 'robots',
                content: 'noindex',
              }),
              true &&
                /*#__PURE__*/ (0, _jsxruntime.jsx)('meta', {
                  name: 'boundary-next-error',
                  content: (0, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(
                    triggeredStatus
                  ),
                }),
              errorComponents[triggeredStatus],
            ],
          });
        }
        return children;
      }
      constructor(props) {
        super(props);
        this.state = {
          triggeredStatus: undefined,
          previousPathname: props.pathname,
        };
      }
    }
    function HTTPAccessFallbackBoundary(param) {
      let { notFound, forbidden, unauthorized, children } = param;
      // When we're rendering the missing params shell, this will return null. This
      // is because we won't be rendering any not found boundaries or error
      // boundaries for the missing params shell. When this runs on the client
      // (where these error can occur), we will get the correct pathname.
      const pathname = (0, _navigationuntracked.useUntrackedPathname)();
      const missingSlots = (0, _react.useContext)(
        _approutercontextsharedruntime.MissingSlotContext
      );
      const hasErrorFallback = !!(notFound || forbidden || unauthorized);
      if (hasErrorFallback) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {
          pathname: pathname,
          notFound: notFound,
          forbidden: forbidden,
          unauthorized: unauthorized,
          missingSlots: missingSlots,
          children: children,
        });
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children,
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-boundary.js.map
  },
  4114: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      HTTPAccessErrorStatus: function () {
        return HTTPAccessErrorStatus;
      },
      HTTP_ERROR_FALLBACK_ERROR_CODE: function () {
        return HTTP_ERROR_FALLBACK_ERROR_CODE;
      },
      getAccessFallbackErrorTypeByStatus: function () {
        return getAccessFallbackErrorTypeByStatus;
      },
      getAccessFallbackHTTPStatus: function () {
        return getAccessFallbackHTTPStatus;
      },
      isHTTPAccessFallbackError: function () {
        return isHTTPAccessFallbackError;
      },
    });
    const HTTPAccessErrorStatus = {
      NOT_FOUND: 404,
      FORBIDDEN: 403,
      UNAUTHORIZED: 401,
    };
    const ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));
    const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';
    function isHTTPAccessFallbackError(error) {
      if (
        typeof error !== 'object' ||
        error === null ||
        !('digest' in error) ||
        typeof error.digest !== 'string'
      ) {
        return false;
      }
      const [prefix, httpStatus] = error.digest.split(';');
      return (
        prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus))
      );
    }
    function getAccessFallbackHTTPStatus(error) {
      const httpStatus = error.digest.split(';')[1];
      return Number(httpStatus);
    }
    function getAccessFallbackErrorTypeByStatus(status) {
      switch (status) {
        case 401:
          return 'unauthorized';
        case 403:
          return 'forbidden';
        case 404:
          return 'not-found';
        default:
          return;
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=http-access-fallback.js.map
  },
  4291: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      NEXTJS_HYDRATION_ERROR_LINK: function () {
        return NEXTJS_HYDRATION_ERROR_LINK;
      },
      REACT_HYDRATION_ERROR_LINK: function () {
        return REACT_HYDRATION_ERROR_LINK;
      },
      getDefaultHydrationErrorMessage: function () {
        return getDefaultHydrationErrorMessage;
      },
      getHydrationErrorStackInfo: function () {
        return getHydrationErrorStackInfo;
      },
      isHydrationError: function () {
        return isHydrationError;
      },
      isReactHydrationErrorMessage: function () {
        return isReactHydrationErrorMessage;
      },
      testReactHydrationWarning: function () {
        return testReactHydrationWarning;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(5336));
    const hydrationErrorRegex =
      /hydration failed|while hydrating|content does not match|did not match|HTML didn't match|text didn't match/i;
    const reactUnifiedMismatchWarning =
      "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:";
    const reactHydrationStartMessages = [
      reactUnifiedMismatchWarning,
      "Hydration failed because the server rendered text didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:",
      "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:",
    ];
    const REACT_HYDRATION_ERROR_LINK = 'https://react.dev/link/hydration-mismatch';
    const NEXTJS_HYDRATION_ERROR_LINK =
      'https://nextjs.org/docs/messages/react-hydration-error';
    const getDefaultHydrationErrorMessage = () => {
      return reactUnifiedMismatchWarning;
    };
    function isHydrationError(error) {
      return (0, _iserror.default)(error) && hydrationErrorRegex.test(error.message);
    }
    function isReactHydrationErrorMessage(msg) {
      return reactHydrationStartMessages.some((prefix) => msg.startsWith(prefix));
    }
    const hydrationWarningRegexes = [
      /^In HTML, (.+?) cannot be a child of <(.+?)>\.(.*)\nThis will cause a hydration error\.(.*)/,
      /^In HTML, (.+?) cannot be a descendant of <(.+?)>\.\nThis will cause a hydration error\.(.*)/,
      /^In HTML, text nodes cannot be a child of <(.+?)>\.\nThis will cause a hydration error\./,
      /^In HTML, whitespace text nodes cannot be a child of <(.+?)>\. Make sure you don't have any extra whitespace between tags on each line of your source code\.\nThis will cause a hydration error\./,
      /^Expected server HTML to contain a matching <(.+?)> in <(.+?)>\.(.*)/,
      /^Did not expect server HTML to contain a <(.+?)> in <(.+?)>\.(.*)/,
      /^Expected server HTML to contain a matching text node for "(.+?)" in <(.+?)>\.(.*)/,
      /^Did not expect server HTML to contain the text node "(.+?)" in <(.+?)>\.(.*)/,
      /^Text content did not match\. Server: "(.+?)" Client: "(.+?)"(.*)/,
    ];
    function testReactHydrationWarning(msg) {
      if (typeof msg !== 'string' || !msg) return false;
      // React 18 has the `Warning: ` prefix.
      // React 19 does not.
      if (msg.startsWith('Warning: ')) {
        msg = msg.slice('Warning: '.length);
      }
      return hydrationWarningRegexes.some((regex) => regex.test(msg));
    }
    function getHydrationErrorStackInfo(rawMessage) {
      rawMessage = rawMessage.replace(/^Error: /, '');
      rawMessage = rawMessage.replace('Warning: ', '');
      const isReactHydrationWarning = testReactHydrationWarning(rawMessage);
      if (!isReactHydrationErrorMessage(rawMessage) && !isReactHydrationWarning) {
        return {
          message: null,
          stack: rawMessage,
          diff: '',
        };
      }
      if (isReactHydrationWarning) {
        const [message, diffLog] = rawMessage.split('\n\n');
        return {
          message: message.trim(),
          stack: '',
          diff: (diffLog || '').trim(),
        };
      }
      const firstLineBreak = rawMessage.indexOf('\n');
      rawMessage = rawMessage.slice(firstLineBreak + 1).trim();
      const [message, trailing] = rawMessage.split('' + REACT_HYDRATION_ERROR_LINK);
      const trimmedMessage = message.trim();
      // React built-in hydration diff starts with a newline, checking if length is > 1
      if (trailing && trailing.length > 1) {
        const stacks = [];
        const diffs = [];
        trailing.split('\n').forEach((line) => {
          if (line.trim() === '') return;
          if (line.trim().startsWith('at ')) {
            stacks.push(line);
          } else {
            diffs.push(line);
          }
        });
        return {
          message: trimmedMessage,
          diff: diffs.join('\n'),
          stack: stacks.join('\n'),
        };
      } else {
        return {
          message: trimmedMessage,
          stack: trailing,
        };
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=is-hydration-error.js.map
  },
  9603: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'isNextRouterError', {
      enumerable: true,
      get: function () {
        return isNextRouterError;
      },
    });
    const _httpaccessfallback = __webpack_require__(4114);
    const _redirecterror = __webpack_require__(6521);
    function isNextRouterError(error) {
      return (
        (0, _redirecterror.isRedirectError)(error) ||
        (0, _httpaccessfallback.isHTTPAccessFallbackError)(error)
      );
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=is-next-router-error.js.map
  },
  1413: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return OuterLayoutRouter;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _routerreducertypes = __webpack_require__(77);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(2951));
    const _approutercontextsharedruntime = __webpack_require__(1727);
    const _fetchserverresponse = __webpack_require__(8556);
    const _unresolvedthenable = __webpack_require__(1470);
    const _errorboundary = __webpack_require__(5534);
    const _matchsegments = __webpack_require__(5462);
    const _handlesmoothscroll = __webpack_require__(7346);
    const _redirectboundary = __webpack_require__(7575);
    const _errorboundary1 = __webpack_require__(8419);
    const _createroutercachekey = __webpack_require__(3953);
    const _hasinterceptionrouteincurrenttree = __webpack_require__(9418);
    const _useactionqueue = __webpack_require__(4297);
    /**
     * Add refetch marker to router state at the point of the current layout segment. This
     * ensures the response returned is not further down than the current layout segment.
     */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {
      if (segmentPathToWalk) {
        const [segment, parallelRouteKey] = segmentPathToWalk;
        const isLast = segmentPathToWalk.length === 2;
        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {
          if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {
            if (isLast) {
              const subTree = walkAddRefetch(
                undefined,
                treeToRecreate[1][parallelRouteKey]
              );
              return [
                treeToRecreate[0],
                {
                  ...treeToRecreate[1],
                  [parallelRouteKey]: [subTree[0], subTree[1], subTree[2], 'refetch'],
                },
              ];
            }
            return [
              treeToRecreate[0],
              {
                ...treeToRecreate[1],
                [parallelRouteKey]: walkAddRefetch(
                  segmentPathToWalk.slice(2),
                  treeToRecreate[1][parallelRouteKey]
                ),
              },
            ];
          }
        }
      }
      return treeToRecreate;
    }
    const __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      _reactdom.default.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    // TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available
    /** Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning */ function findDOMNode(
      instance
    ) {
      // Tree-shake for server bundle
      if (true) return null;
      // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.
      // We need to lazily reference it.
      const internal_reactDOMfindDOMNode =
        __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;
      return internal_reactDOMfindDOMNode(instance);
    }
    const rectProperties = [
      'bottom',
      'height',
      'left',
      'right',
      'top',
      'width',
      'x',
      'y',
    ];
    /** Check if a HTMLElement is hidden or fixed/sticky position */ function shouldSkipElement(
      element
    ) {
      // we ignore fixed or sticky positioned elements since they'll likely pass the "in-viewport" check
      // and will result in a situation we bail on scroll because of something like a fixed nav,
      // even though the actual page content is offscreen
      if (['sticky', 'fixed'].includes(getComputedStyle(element).position)) {
        if (true) {
          console.warn(
            'Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:',
            element
          );
        }
        return true;
      }
      // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`
      // because `offsetParent` doesn't consider document/body
      const rect = element.getBoundingClientRect();
      return rectProperties.every((item) => rect[item] === 0);
    }
    /** Check if the top corner of the HTMLElement is in the viewport. */ function topOfElementInViewport(
      element,
      viewportHeight
    ) {
      const rect = element.getBoundingClientRect();
      return rect.top >= 0 && rect.top <= viewportHeight;
    }
    /**
     * Find the DOM node for a hash fragment. If `top` the page has to scroll to the top of
     * the page. This mirrors the browser's behavior. If the hash fragment is an id, the page
     * has to scroll to the element with that id. If the hash fragment is a name, the page has
     * to scroll to the first element with that name.
     */ function getHashFragmentDomNode(hashFragment) {
      // If the hash fragment is `top` the page has to scroll to the top of the page.
      if (hashFragment === 'top') {
        return document.body;
      }
      var _document_getElementById;
      // If the hash fragment is an id, the page has to scroll to the element with that id.
      return (_document_getElementById = document.getElementById(hashFragment)) != null
        ? _document_getElementById
        : document.getElementsByName(hashFragment)[0];
    }
    class InnerScrollAndFocusHandler extends _react.default.Component {
      componentDidMount() {
        this.handlePotentialScroll();
      }
      componentDidUpdate() {
        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.
        if (this.props.focusAndScrollRef.apply) {
          this.handlePotentialScroll();
        }
      }
      render() {
        return this.props.children;
      }
      constructor(...args) {
        super(...args),
          (this.handlePotentialScroll = () => {
            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.
            const { focusAndScrollRef, segmentPath } = this.props;
            if (focusAndScrollRef.apply) {
              // segmentPaths is an array of segment paths that should be scrolled to
              // if the current segment path is not in the array, the scroll is not applied
              // unless the array is empty, in which case the scroll is always applied
              if (
                focusAndScrollRef.segmentPaths.length !== 0 &&
                !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath) =>
                  segmentPath.every((segment, index) =>
                    (0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])
                  )
                )
              ) {
                return;
              }
              let domNode = null;
              const hashFragment = focusAndScrollRef.hashFragment;
              if (hashFragment) {
                domNode = getHashFragmentDomNode(hashFragment);
              }
              // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.
              // This already caused a bug where the first child was a <link/> in head.
              if (!domNode) {
                domNode = findDOMNode(this);
              }
              // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.
              if (!(domNode instanceof Element)) {
                return;
              }
              // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.
              // If the element is skipped, try to select the next sibling and try again.
              while (!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)) {
                if (true) {
                  var _domNode_parentElement;
                  if (
                    ((_domNode_parentElement = domNode.parentElement) == null
                      ? void 0
                      : _domNode_parentElement.localName) === 'head'
                  ) {
                    // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.
                    // This is always a bug in Next.js and caused by React hoisting metadata.
                    // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.
                  }
                }
                // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.
                if (domNode.nextElementSibling === null) {
                  return;
                }
                domNode = domNode.nextElementSibling;
              }
              // State is mutated to ensure that the focus and scroll is applied only once.
              focusAndScrollRef.apply = false;
              focusAndScrollRef.hashFragment = null;
              focusAndScrollRef.segmentPaths = [];
              (0, _handlesmoothscroll.handleSmoothScroll)(
                () => {
                  // In case of hash scroll, we only need to scroll the element into view
                  if (hashFragment) {
                    domNode.scrollIntoView();
                    return;
                  }
                  // Store the current viewport height because reading `clientHeight` causes a reflow,
                  // and it won't change during this function.
                  const htmlElement = document.documentElement;
                  const viewportHeight = htmlElement.clientHeight;
                  // If the element's top edge is already in the viewport, exit early.
                  if (topOfElementInViewport(domNode, viewportHeight)) {
                    return;
                  }
                  // Otherwise, try scrolling go the top of the document to be backward compatible with pages
                  // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)
                  // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left
                  // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically
                  htmlElement.scrollTop = 0;
                  // Scroll to domNode if domNode is not in viewport when scrolled to top of document
                  if (!topOfElementInViewport(domNode, viewportHeight)) {
                    // Scroll into view doesn't scroll horizontally by default when not needed
                    domNode.scrollIntoView();
                  }
                },
                {
                  // We will force layout by querying domNode position
                  dontForceLayout: true,
                  onlyHashChange: focusAndScrollRef.onlyHashChange,
                }
              );
              // Mutate after scrolling so that it can be read by `handleSmoothScroll`
              focusAndScrollRef.onlyHashChange = false;
              // Set focus on the element
              domNode.focus();
            }
          });
      }
    }
    function ScrollAndFocusHandler(param) {
      let { segmentPath, children } = param;
      const context = (0, _react.useContext)(
        _approutercontextsharedruntime.GlobalLayoutRouterContext
      );
      if (!context) {
        throw Object.defineProperty(
          new Error('invariant global layout router not mounted'),
          '__NEXT_ERROR_CODE',
          {
            value: 'E473',
            enumerable: false,
            configurable: true,
          }
        );
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {
        segmentPath: segmentPath,
        focusAndScrollRef: context.focusAndScrollRef,
        children: children,
      });
    }
    /** InnerLayoutRouter handles rendering the provided segment based on the cache. */ function InnerLayoutRouter(
      param
    ) {
      let { tree, segmentPath, cacheNode, url } = param;
      const context = (0, _react.useContext)(
        _approutercontextsharedruntime.GlobalLayoutRouterContext
      );
      if (!context) {
        throw Object.defineProperty(
          new Error('invariant global layout router not mounted'),
          '__NEXT_ERROR_CODE',
          {
            value: 'E473',
            enumerable: false,
            configurable: true,
          }
        );
      }
      const { tree: fullTree } = context;
      // `rsc` represents the renderable node for this segment.
      // If this segment has a `prefetchRsc`, it's the statically prefetched data.
      // We should use that on initial render instead of `rsc`. Then we'll switch
      // to `rsc` when the dynamic response streams in.
      //
      // If no prefetch data is available, then we go straight to rendering `rsc`.
      const resolvedPrefetchRsc =
        cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc;
      // We use `useDeferredValue` to handle switching between the prefetched and
      // final values. The second argument is returned on initial render, then it
      // re-renders with the first argument.
      const rsc = (0, _react.useDeferredValue)(cacheNode.rsc, resolvedPrefetchRsc);
      // `rsc` is either a React node or a promise for a React node, except we
      // special case `null` to represent that this segment's data is missing. If
      // it's a promise, we need to unwrap it so we can determine whether or not the
      // data is missing.
      const resolvedRsc =
        typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function'
          ? (0, _react.use)(rsc)
          : rsc;
      if (!resolvedRsc) {
        // The data for this segment is not available, and there's no pending
        // navigation that will be able to fulfill it. We need to fetch more from
        // the server and patch the cache.
        // Check if there's already a pending request.
        let lazyData = cacheNode.lazyData;
        if (lazyData === null) {
          /** Router state with refetch marker added */ // TODO-APP: remove ''
          const refetchTree = walkAddRefetch(['', ...segmentPath], fullTree);
          const includeNextUrl = (0,
          _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(fullTree);
          const navigatedAt = Date.now();
          cacheNode.lazyData = lazyData = (0, _fetchserverresponse.fetchServerResponse)(
            new URL(url, location.origin),
            {
              flightRouterState: refetchTree,
              nextUrl: includeNextUrl ? context.nextUrl : null,
            }
          ).then((serverResponse) => {
            (0, _react.startTransition)(() => {
              (0, _useactionqueue.dispatchAppRouterAction)({
                type: _routerreducertypes.ACTION_SERVER_PATCH,
                previousTree: fullTree,
                serverResponse,
                navigatedAt,
              });
            });
            return serverResponse;
          });
          // Suspend while waiting for lazyData to resolve
          (0, _react.use)(lazyData);
        }
        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.
        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.
        (0, _react.use)(_unresolvedthenable.unresolvedThenable);
      }
      // If we get to this point, then we know we have something we can render.
      const subtree = /*#__PURE__*/ (0, _jsxruntime.jsx)(
        _approutercontextsharedruntime.LayoutRouterContext.Provider,
        {
          value: {
            parentTree: tree,
            parentCacheNode: cacheNode,
            parentSegmentPath: segmentPath,
            // TODO-APP: overriding of url for parallel routes
            url: url,
          },
          children: resolvedRsc,
        }
      );
      // Ensure root layout is not wrapped in a div as the root layout renders `<html>`
      return subtree;
    }
    /**
     * Renders suspense boundary with the provided "loading" property as the fallback. If no
     * loading property is provided it renders the children without a suspense boundary.
     */ function LoadingBoundary(param) {
      let { loading, children } = param;
      // If loading is a promise, unwrap it. This happens in cases where we haven't
      // yet received the loading data from the server — which includes whether or
      // not this layout has a loading component at all.
      //
      // It's OK to suspend here instead of inside the fallback because this
      // promise will resolve simultaneously with the data for the segment itself.
      // So it will never suspend for longer than it would have if we didn't use
      // a Suspense fallback at all.
      let loadingModuleData;
      if (
        typeof loading === 'object' &&
        loading !== null &&
        typeof loading.then === 'function'
      ) {
        const promiseForLoading = loading;
        loadingModuleData = (0, _react.use)(promiseForLoading);
      } else {
        loadingModuleData = loading;
      }
      if (loadingModuleData) {
        const loadingRsc = loadingModuleData[0];
        const loadingStyles = loadingModuleData[1];
        const loadingScripts = loadingModuleData[2];
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {
          fallback: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [loadingStyles, loadingScripts, loadingRsc],
          }),
          children: children,
        });
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children,
      });
    }
    function OuterLayoutRouter(param) {
      let {
        parallelRouterKey,
        error,
        errorStyles,
        errorScripts,
        templateStyles,
        templateScripts,
        template,
        notFound,
        forbidden,
        unauthorized,
      } = param;
      const context = (0, _react.useContext)(
        _approutercontextsharedruntime.LayoutRouterContext
      );
      if (!context) {
        throw Object.defineProperty(
          new Error('invariant expected layout router to be mounted'),
          '__NEXT_ERROR_CODE',
          {
            value: 'E56',
            enumerable: false,
            configurable: true,
          }
        );
      }
      const { parentTree, parentCacheNode, parentSegmentPath, url } = context;
      // Get the CacheNode for this segment by reading it from the parent segment's
      // child map.
      const parentParallelRoutes = parentCacheNode.parallelRoutes;
      let segmentMap = parentParallelRoutes.get(parallelRouterKey);
      // If the parallel router cache node does not exist yet, create it.
      // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.
      if (!segmentMap) {
        segmentMap = new Map();
        parentParallelRoutes.set(parallelRouterKey, segmentMap);
      }
      // Get the active segment in the tree
      // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.
      const parentTreeSegment = parentTree[0];
      const tree = parentTree[1][parallelRouterKey];
      const treeSegment = tree[0];
      const segmentPath =
        parentSegmentPath === null // the code. We should clean this up.
          ? [parallelRouterKey]
          : parentSegmentPath.concat([parentTreeSegment, parallelRouterKey]);
      // The "state" key of a segment is the one passed to React — it represents the
      // identity of the UI tree. Whenever the state key changes, the tree is
      // recreated and the state is reset. In the App Router model, search params do
      // not cause state to be lost, so two segments with the same segment path but
      // different search params should have the same state key.
      //
      // The "cache" key of a segment, however, *does* include the search params, if
      // it's possible that the segment accessed the search params on the server.
      // (This only applies to page segments; layout segments cannot access search
      // params on the server.)
      const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(treeSegment);
      const stateKey = (0, _createroutercachekey.createRouterCacheKey)(treeSegment, true); // no search params
      // Read segment path from the parallel router cache node.
      let cacheNode = segmentMap.get(cacheKey);
      if (cacheNode === undefined) {
        // When data is not available during rendering client-side we need to fetch
        // it from the server.
        const newLazyCacheNode = {
          lazyData: null,
          rsc: null,
          prefetchRsc: null,
          head: null,
          prefetchHead: null,
          parallelRoutes: new Map(),
          loading: null,
          navigatedAt: -1,
        };
        // Flight data fetch kicked off during render and put into the cache.
        cacheNode = newLazyCacheNode;
        segmentMap.set(cacheKey, newLazyCacheNode);
      }
      /*
    - Error boundary
      - Only renders error boundary if error component is provided.
      - Rendered for each segment to ensure they have their own error state.
    - Loading boundary
      - Only renders suspense boundary if loading components is provided.
      - Rendered for each segment to ensure they have their own loading state.
      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.
  */ // TODO: The loading module data for a segment is stored on the parent, then
      // applied to each of that parent segment's parallel route slots. In the
      // simple case where there's only one parallel route (the `children` slot),
      // this is no different from if the loading module data where stored on the
      // child directly. But I'm not sure this actually makes sense when there are
      // multiple parallel routes. It's not a huge issue because you always have
      // the option to define a narrower loading boundary for a particular slot. But
      // this sort of smells like an implementation accident to me.
      const loadingModuleData = parentCacheNode.loading;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)(
        _approutercontextsharedruntime.TemplateContext.Provider,
        {
          value: /*#__PURE__*/ (0, _jsxruntime.jsx)(ScrollAndFocusHandler, {
            segmentPath: segmentPath,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {
              errorComponent: error,
              errorStyles: errorStyles,
              errorScripts: errorScripts,
              children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingBoundary, {
                loading: loadingModuleData,
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(
                  _errorboundary1.HTTPAccessFallbackBoundary,
                  {
                    notFound: notFound,
                    forbidden: forbidden,
                    unauthorized: unauthorized,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(
                      _redirectboundary.RedirectBoundary,
                      {
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerLayoutRouter, {
                          url: url,
                          tree: tree,
                          cacheNode: cacheNode,
                          segmentPath: segmentPath,
                        }),
                      }
                    ),
                  }
                ),
              }),
            }),
          }),
          children: [templateStyles, templateScripts, template],
        },
        stateKey
      );
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=layout-router.js.map
  },
  5462: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'matchSegment', {
      enumerable: true,
      get: function () {
        return matchSegment;
      },
    });
    const matchSegment = (existingSegment, segment) => {
      // segment is either Array or string
      if (typeof existingSegment === 'string') {
        if (typeof segment === 'string') {
          // Common case: segment is just a string
          return existingSegment === segment;
        }
        return false;
      }
      if (typeof segment === 'string') {
        return false;
      }
      return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=match-segments.js.map
  },
  6604: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      AsyncMetadata: function () {
        return AsyncMetadata;
      },
      AsyncMetadataOutlet: function () {
        return AsyncMetadataOutlet;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const AsyncMetadata = true
      ? __webpack_require__(1911) /* .ServerInsertMetadata */.ServerInsertMetadata
      : 0;
    function MetadataOutlet(param) {
      let { promise } = param;
      const { error, digest } = (0, _react.use)(promise);
      if (error) {
        if (digest) {
          // The error will lose its original digest after passing from server layer to client layer；
          // We recover the digest property here to override the React created one if original digest exists.
          error.digest = digest;
        }
        throw error;
      }
      return null;
    }
    function AsyncMetadataOutlet(param) {
      let { promise } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {
        fallback: null,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MetadataOutlet, {
          promise: promise,
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=async-metadata.js.map
  },
  6432: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      MetadataBoundary: function () {
        return MetadataBoundary;
      },
      OutletBoundary: function () {
        return OutletBoundary;
      },
      ViewportBoundary: function () {
        return ViewportBoundary;
      },
    });
    const _metadataconstants = __webpack_require__(6859);
    // We use a namespace object to allow us to recover the name of the function
    // at runtime even when production bundling/minification is used.
    const NameSpace = {
      [_metadataconstants.METADATA_BOUNDARY_NAME]: function (param) {
        let { children } = param;
        return children;
      },
      [_metadataconstants.VIEWPORT_BOUNDARY_NAME]: function (param) {
        let { children } = param;
        return children;
      },
      [_metadataconstants.OUTLET_BOUNDARY_NAME]: function (param) {
        let { children } = param;
        return children;
      },
    };
    const MetadataBoundary = // so it retains the name inferred from the namespace object
      NameSpace[_metadataconstants.METADATA_BOUNDARY_NAME.slice(0)];
    const ViewportBoundary = // so it retains the name inferred from the namespace object
      NameSpace[_metadataconstants.VIEWPORT_BOUNDARY_NAME.slice(0)];
    const OutletBoundary = NameSpace[_metadataconstants.OUTLET_BOUNDARY_NAME.slice(0)]; // so it retains the name inferred from the namespace object
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=metadata-boundary.js.map
  },
  1911: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ServerInsertMetadata', {
      enumerable: true,
      get: function () {
        return ServerInsertMetadata;
      },
    });
    const _react = __webpack_require__(863);
    const _serverinsertedmetadatasharedruntime = __webpack_require__(3917);
    // Receives a metadata resolver setter from the context, and will pass the metadata resolving promise to
    // the context where we gonna use it to resolve the metadata, and render as string to append in <body>.
    const useServerInsertedMetadata = (metadataResolver) => {
      const setMetadataResolver = (0, _react.useContext)(
        _serverinsertedmetadatasharedruntime.ServerInsertedMetadataContext
      );
      if (setMetadataResolver) {
        setMetadataResolver(metadataResolver);
      }
    };
    function ServerInsertMetadata(param) {
      let { promise } = param;
      // Apply use() to the metadata promise to suspend the rendering in SSR.
      const { metadata } = (0, _react.use)(promise);
      // Insert metadata into the HTML stream through the `useServerInsertedMetadata`
      useServerInsertedMetadata(
        {
          'ServerInsertMetadata.useServerInsertedMetadata': () => metadata,
        }['ServerInsertMetadata.useServerInsertedMetadata']
      );
      return null;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=server-inserted-metadata.js.map
  },
  3761: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      handleHardNavError: function () {
        return handleHardNavError;
      },
      useNavFailureHandler: function () {
        return useNavFailureHandler;
      },
    });
    const _react = __webpack_require__(863);
    const _createhreffromurl = __webpack_require__(4363);
    function handleHardNavError(error) {
      if (error && 'undefined' !== 'undefined' && 0 && 0) {
      }
      return false;
    }
    function useNavFailureHandler() {
      if (false) {
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=nav-failure-handler.js.map
  },
  7337: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'useUntrackedPathname', {
      enumerable: true,
      get: function () {
        return useUntrackedPathname;
      },
    });
    const _react = __webpack_require__(863);
    const _hooksclientcontextsharedruntime = __webpack_require__(1493);
    /**
     * This checks to see if the current render has any unknown route parameters. It's used to
     * trigger a different render path in the error boundary.
     *
     * @returns True if there are any unknown route parameters, false otherwise
     */ function hasFallbackRouteParams() {
      if (true) {
        // AsyncLocalStorage should not be included in the client bundle.
        const { workAsyncStorage } = __webpack_require__(9348);
        const workStore = workAsyncStorage.getStore();
        if (!workStore) return false;
        const { fallbackRouteParams } = workStore;
        if (!fallbackRouteParams || fallbackRouteParams.size === 0) return false;
        return true;
      }
      return false;
    }
    function useUntrackedPathname() {
      // If there are any unknown route parameters we would typically throw
      // an error, but this internal method allows us to return a null value instead
      // for components that do not propagate the pathname to the static shell (like
      // the error boundary).
      if (hasFallbackRouteParams()) {
        return null;
      }
      // This shouldn't cause any issues related to conditional rendering because
      // the environment will be consistent for the render.
      // eslint-disable-next-line react-hooks/rules-of-hooks
      return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=navigation-untracked.js.map
  },
  2947: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ReadonlyURLSearchParams: function () {
        return _navigationreactserver.ReadonlyURLSearchParams;
      },
      RedirectType: function () {
        return _navigationreactserver.RedirectType;
      },
      ServerInsertedHTMLContext: function () {
        return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;
      },
      forbidden: function () {
        return _navigationreactserver.forbidden;
      },
      notFound: function () {
        return _navigationreactserver.notFound;
      },
      permanentRedirect: function () {
        return _navigationreactserver.permanentRedirect;
      },
      redirect: function () {
        return _navigationreactserver.redirect;
      },
      unauthorized: function () {
        return _navigationreactserver.unauthorized;
      },
      unstable_rethrow: function () {
        return _navigationreactserver.unstable_rethrow;
      },
      useParams: function () {
        return useParams;
      },
      usePathname: function () {
        return usePathname;
      },
      useRouter: function () {
        return useRouter;
      },
      useSearchParams: function () {
        return useSearchParams;
      },
      useSelectedLayoutSegment: function () {
        return useSelectedLayoutSegment;
      },
      useSelectedLayoutSegments: function () {
        return useSelectedLayoutSegments;
      },
      useServerInsertedHTML: function () {
        return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;
      },
    });
    const _react = __webpack_require__(863);
    const _approutercontextsharedruntime = __webpack_require__(1727);
    const _hooksclientcontextsharedruntime = __webpack_require__(1493);
    const _getsegmentvalue = __webpack_require__(1258);
    const _segment = __webpack_require__(5418);
    const _navigationreactserver = __webpack_require__(1389);
    const _serverinsertedhtmlsharedruntime = __webpack_require__(3779);
    const useDynamicRouteParams = true
      ? __webpack_require__(9948) /* .useDynamicRouteParams */.useDynamicRouteParams
      : 0;
    function useSearchParams() {
      const searchParams = (0, _react.useContext)(
        _hooksclientcontextsharedruntime.SearchParamsContext
      );
      // In the case where this is `null`, the compat types added in
      // `next-env.d.ts` will add a new overload that changes the return type to
      // include `null`.
      const readonlySearchParams = (0, _react.useMemo)(() => {
        if (!searchParams) {
          // When the router is not ready in pages, we won't have the search params
          // available.
          return null;
        }
        return new _navigationreactserver.ReadonlyURLSearchParams(searchParams);
      }, [searchParams]);
      if (true) {
        // AsyncLocalStorage should not be included in the client bundle.
        const { bailoutToClientRendering } = __webpack_require__(7826);
        // TODO-APP: handle dynamic = 'force-static' here and on the client
        bailoutToClientRendering('useSearchParams()');
      }
      return readonlySearchParams;
    }
    function usePathname() {
      useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('usePathname()');
      // In the case where this is `null`, the compat types added in `next-env.d.ts`
      // will add a new overload that changes the return type to include `null`.
      return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);
    }
    function useRouter() {
      const router = (0, _react.useContext)(
        _approutercontextsharedruntime.AppRouterContext
      );
      if (router === null) {
        throw Object.defineProperty(
          new Error('invariant expected app router to be mounted'),
          '__NEXT_ERROR_CODE',
          {
            value: 'E238',
            enumerable: false,
            configurable: true,
          }
        );
      }
      return router;
    }
    function useParams() {
      useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useParams()');
      return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);
    }
    /** Get the canonical parameters from the current level to the leaf node. */ // Client components API
    function getSelectedLayoutSegmentPath(tree, parallelRouteKey, first, segmentPath) {
      if (first === void 0) first = true;
      if (segmentPath === void 0) segmentPath = [];
      let node;
      if (first) {
        // Use the provided parallel route key on the first parallel route
        node = tree[1][parallelRouteKey];
      } else {
        // After first parallel route prefer children, if there's no children pick the first parallel route.
        const parallelRoutes = tree[1];
        var _parallelRoutes_children;
        node =
          (_parallelRoutes_children = parallelRoutes.children) != null
            ? _parallelRoutes_children
            : Object.values(parallelRoutes)[0];
      }
      if (!node) return segmentPath;
      const segment = node[0];
      let segmentValue = (0, _getsegmentvalue.getSegmentValue)(segment);
      if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) {
        return segmentPath;
      }
      segmentPath.push(segmentValue);
      return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);
    }
    function useSelectedLayoutSegments(parallelRouteKey) {
      if (parallelRouteKey === void 0) parallelRouteKey = 'children';
      useDynamicRouteParams == null
        ? void 0
        : useDynamicRouteParams('useSelectedLayoutSegments()');
      const context = (0, _react.useContext)(
        _approutercontextsharedruntime.LayoutRouterContext
      );
      // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts
      if (!context) return null;
      return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey);
    }
    function useSelectedLayoutSegment(parallelRouteKey) {
      if (parallelRouteKey === void 0) parallelRouteKey = 'children';
      useDynamicRouteParams == null
        ? void 0
        : useDynamicRouteParams('useSelectedLayoutSegment()');
      const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);
      if (!selectedLayoutSegments || selectedLayoutSegments.length === 0) {
        return null;
      }
      const selectedLayoutSegment =
        parallelRouteKey === 'children'
          ? selectedLayoutSegments[0]
          : selectedLayoutSegments[selectedLayoutSegments.length - 1];
      // if the default slot is showing, we return null since it's not technically "selected" (it's a fallback)
      // and returning an internal value like `__DEFAULT__` would be confusing.
      return selectedLayoutSegment === _segment.DEFAULT_SEGMENT_KEY
        ? null
        : selectedLayoutSegment;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=navigation.js.map
  },
  1389: function (module, exports, __webpack_require__) {
    'use strict';
    /** @internal */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ReadonlyURLSearchParams: function () {
        return ReadonlyURLSearchParams;
      },
      RedirectType: function () {
        return _redirecterror.RedirectType;
      },
      forbidden: function () {
        return _forbidden.forbidden;
      },
      notFound: function () {
        return _notfound.notFound;
      },
      permanentRedirect: function () {
        return _redirect.permanentRedirect;
      },
      redirect: function () {
        return _redirect.redirect;
      },
      unauthorized: function () {
        return _unauthorized.unauthorized;
      },
      unstable_rethrow: function () {
        return _unstablerethrow.unstable_rethrow;
      },
    });
    const _redirect = __webpack_require__(3142);
    const _redirecterror = __webpack_require__(6521);
    const _notfound = __webpack_require__(262);
    const _forbidden = __webpack_require__(1364);
    const _unauthorized = __webpack_require__(208);
    const _unstablerethrow = __webpack_require__(8319);
    class ReadonlyURLSearchParamsError extends Error {
      constructor() {
        super(
          'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'
        );
      }
    }
    class ReadonlyURLSearchParams extends URLSearchParams {
      /**
       * @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more:
       *   https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams
       */ append() {
        throw new ReadonlyURLSearchParamsError();
      }
      /**
       * @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more:
       *   https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams
       */ delete() {
        throw new ReadonlyURLSearchParamsError();
      }
      /**
       * @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more:
       *   https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams
       */ set() {
        throw new ReadonlyURLSearchParamsError();
      }
      /**
       * @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more:
       *   https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams
       */ sort() {
        throw new ReadonlyURLSearchParamsError();
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=navigation.react-server.js.map
  },
  262: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'notFound', {
      enumerable: true,
      get: function () {
        return notFound;
      },
    });
    const _httpaccessfallback = __webpack_require__(4114);
    /**
     * This function allows you to render the [not-found.js
     * file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found) within a
     * route segment as well as inject a tag.
     *
     * `notFound()` can be used in [Server
     * Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
     * [Route
     * Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers),
     * and [Server
     * Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
     *
     * - In a Server Component, this will insert a `<meta name="robots" content="noindex" />`
     *   meta tag and set the status code to 404.
     * - In a Route Handler or Server Action, it will serve a 404 to the caller.
     *
     * Read more: [Next.js Docs:
     * `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)
     */ const DIGEST = '' + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ';404';
    function notFound() {
      // eslint-disable-next-line no-throw-literal
      const error = Object.defineProperty(new Error(DIGEST), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: false,
        configurable: true,
      });
      error.digest = DIGEST;
      throw error;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=not-found.js.map
  },
  9005: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'AppDevOverlayErrorBoundary', {
      enumerable: true,
      get: function () {
        return AppDevOverlayErrorBoundary;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _runtimeerrorhandler = __webpack_require__(5589);
    const _errorboundary = __webpack_require__(5534);
    function ErroredHtml(param) {
      let {
        globalError: [GlobalError, globalErrorStyles],
        error,
      } = param;
      if (!error) {
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)('html', {
          children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)('head', {}),
            /*#__PURE__*/ (0, _jsxruntime.jsx)('body', {}),
          ],
        });
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_errorboundary.ErrorBoundary, {
        errorComponent: _errorboundary.GlobalError,
        children: [
          globalErrorStyles,
          /*#__PURE__*/ (0, _jsxruntime.jsx)(GlobalError, {
            error: error,
          }),
        ],
      });
    }
    class AppDevOverlayErrorBoundary extends _react.PureComponent {
      static getDerivedStateFromError(error) {
        if (!error.stack) {
          return {
            isReactError: false,
            reactError: null,
          };
        }
        _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError = true;
        return {
          isReactError: true,
          reactError: error,
        };
      }
      componentDidCatch() {
        this.props.onError(this.state.isReactError);
      }
      render() {
        const { children, globalError } = this.props;
        const { isReactError, reactError } = this.state;
        const fallback = /*#__PURE__*/ (0, _jsxruntime.jsx)(ErroredHtml, {
          globalError: globalError,
          error: reactError,
        });
        return isReactError ? fallback : children;
      }
      constructor(...args) {
        super(...args),
          (this.state = {
            isReactError: false,
            reactError: null,
          });
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=app-dev-overlay-error-boundary.js.map
  },
  4831: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'AppDevOverlay', {
      enumerable: true,
      get: function () {
        return AppDevOverlay;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _appdevoverlayerrorboundary = __webpack_require__(9005);
    const _fontstyles = __webpack_require__(5739);
    const _devoverlay = __webpack_require__(124);
    const _useerrorhandler = __webpack_require__(6000);
    const _isnextroutererror = __webpack_require__(9603);
    const _constants = __webpack_require__(3694);
    function readSsrError() {
      if (typeof document === 'undefined') {
        return null;
      }
      const ssrErrorTemplateTag = document.querySelector(
        'template[data-next-error-message]'
      );
      if (ssrErrorTemplateTag) {
        const message = ssrErrorTemplateTag.getAttribute('data-next-error-message');
        const stack = ssrErrorTemplateTag.getAttribute('data-next-error-stack');
        const digest = ssrErrorTemplateTag.getAttribute('data-next-error-digest');
        const error = Object.defineProperty(new Error(message), '__NEXT_ERROR_CODE', {
          value: 'E394',
          enumerable: false,
          configurable: true,
        });
        if (digest) {
          error.digest = digest;
        }
        // Skip Next.js SSR'd internal errors that which will be handled by the error boundaries.
        if ((0, _isnextroutererror.isNextRouterError)(error)) {
          return null;
        }
        error.stack = stack || '';
        return error;
      }
      return null;
    }
    // Needs to be in the same error boundary as the shell.
    // If it commits, we know we recovered from an SSR error.
    // If it doesn't commit, we errored again and React will take care of error reporting.
    function ReplaySsrOnlyErrors(param) {
      let { onBlockingError } = param;
      if (true) {
        // Need to read during render. The attributes will be gone after commit.
        const ssrError = readSsrError();
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, _react.useEffect)(() => {
          if (ssrError !== null) {
            // TODO(veil): Produces wrong Owner Stack
            // TODO(veil): Mark as recoverable error
            // TODO(veil): console.error
            (0, _useerrorhandler.handleClientError)(ssrError);
            // If it's missing root tags, we can't recover, make it blocking.
            if (ssrError.digest === _constants.MISSING_ROOT_TAGS_ERROR) {
              onBlockingError();
            }
          }
        }, [ssrError, onBlockingError]);
      }
      return null;
    }
    function AppDevOverlay(param) {
      let { state, globalError, children } = param;
      const [isErrorOverlayOpen, setIsErrorOverlayOpen] = (0, _react.useState)(false);
      const openOverlay = (0, _react.useCallback)(() => {
        setIsErrorOverlayOpen(true);
      }, []);
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsxs)(
            _appdevoverlayerrorboundary.AppDevOverlayErrorBoundary,
            {
              globalError: globalError,
              onError: setIsErrorOverlayOpen,
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)(ReplaySsrOnlyErrors, {
                  onBlockingError: openOverlay,
                }),
                children,
              ],
            }
          ),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsx)(_fontstyles.FontStyles, {}),
              /*#__PURE__*/ (0, _jsxruntime.jsx)(_devoverlay.DevOverlay, {
                state: state,
                isErrorOverlayOpen: isErrorOverlayOpen,
                setIsErrorOverlayOpen: setIsErrorOverlayOpen,
              }),
            ],
          }),
        ],
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=app-dev-overlay.js.map
  },
  7839: function (module, exports, __webpack_require__) {
    'use strict';
    /* module decorator */ module = __webpack_require__.nmd(module);
    /// <reference types="webpack/module.d.ts" />

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      default: function () {
        return HotReload;
      },
      waitForWebpackRuntimeHotUpdate: function () {
        return waitForWebpackRuntimeHotUpdate;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _stripansi = /*#__PURE__*/ _interop_require_default._(
      __webpack_require__(7976)
    );
    const _formatwebpackmessages = /*#__PURE__*/ _interop_require_default._(
      __webpack_require__(34)
    );
    const _navigation = __webpack_require__(2947);
    const _shared = __webpack_require__(6172);
    const _parsestack = __webpack_require__(765);
    const _appdevoverlay = __webpack_require__(4831);
    const _useerrorhandler = __webpack_require__(6000);
    const _runtimeerrorhandler = __webpack_require__(5589);
    const _usewebsocket = __webpack_require__(3881);
    const _parsecomponentstack = __webpack_require__(4698);
    const _hotreloadertypes = __webpack_require__(6758);
    const _navigationuntracked = __webpack_require__(7337);
    const _stitchederror = __webpack_require__(9917);
    const _handledevbuildindicatorhmrevents = __webpack_require__(8297);
    const _reporthmrlatency = /*#__PURE__*/ _interop_require_default._(
      __webpack_require__(1397)
    );
    const _turbopackhotreloadercommon = __webpack_require__(4233);
    const _approuterheaders = __webpack_require__(7079);
    let mostRecentCompilationHash = null;
    let __nextDevClientId = Math.round(Math.random() * 100 + Date.now());
    let reloading = false;
    let webpackStartMsSinceEpoch = null;
    const turbopackHmr = false ? 0 : null;
    let pendingHotUpdateWebpack = Promise.resolve();
    let resolvePendingHotUpdateWebpack = () => {};
    function setPendingHotUpdateWebpack() {
      pendingHotUpdateWebpack = new Promise((resolve) => {
        resolvePendingHotUpdateWebpack = () => {
          resolve();
        };
      });
    }
    function waitForWebpackRuntimeHotUpdate() {
      return pendingHotUpdateWebpack;
    }
    // There is a newer version of the code available.
    function handleAvailableHash(hash) {
      // Update last known compilation hash.
      mostRecentCompilationHash = hash;
    }
    /**
     * Is there a newer version of this code available? For webpack: Check if the hash changed
     * compared to **webpack_hash** For Turbopack: Always true because it doesn't have
     * **webpack_hash**
     */ function isUpdateAvailable() {
      if (false) {
      }
      /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.
      // It's a global variable injected by Webpack.
      return mostRecentCompilationHash !== __webpack_require__.h();
    }
    // Webpack disallows updates in other states.
    function canApplyUpdates() {
      return module.hot.status() === 'idle';
    }
    function afterApplyUpdates(fn) {
      if (canApplyUpdates()) {
        fn();
      } else {
        function handler(status) {
          if (status === 'idle') {
            module.hot.removeStatusHandler(handler);
            fn();
          }
        }
        module.hot.addStatusHandler(handler);
      }
    }
    function performFullReload(err, sendMessage) {
      const stackTrace =
        err &&
        ((err.stack && err.stack.split('\n').slice(0, 5).join('\n')) ||
          err.message ||
          err + '');
      sendMessage(
        JSON.stringify({
          event: 'client-full-reload',
          stackTrace,
          hadRuntimeError: !!_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError,
          dependencyChain: err ? err.dependencyChain : undefined,
        })
      );
      if (reloading) return;
      reloading = true;
      window.location.reload();
    }
    // Attempt to update code on the fly, fall back to a hard reload.
    function tryApplyUpdatesWebpack(sendMessage, dispatcher) {
      if (!isUpdateAvailable() || !canApplyUpdates()) {
        resolvePendingHotUpdateWebpack();
        dispatcher.onBuildOk();
        (0, _reporthmrlatency.default)(
          sendMessage,
          [],
          webpackStartMsSinceEpoch,
          Date.now()
        );
        return;
      }
      function handleApplyUpdates(err, updatedModules) {
        if (
          err ||
          _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError ||
          updatedModules == null
        ) {
          if (err) {
            console.warn(_shared.REACT_REFRESH_FULL_RELOAD);
          } else if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
            console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);
          }
          performFullReload(err, sendMessage);
          return;
        }
        dispatcher.onBuildOk();
        if (isUpdateAvailable()) {
          // While we were updating, there was a new update! Do it again.
          tryApplyUpdatesWebpack(sendMessage, dispatcher);
          return;
        }
        dispatcher.onRefresh();
        resolvePendingHotUpdateWebpack();
        (0, _reporthmrlatency.default)(
          sendMessage,
          updatedModules,
          webpackStartMsSinceEpoch,
          Date.now()
        );
        if (false) {
        }
      }
      // https://webpack.js.org/api/hot-module-replacement/#check
      module.hot
        .check(/* autoApply */ false)
        .then((updatedModules) => {
          if (updatedModules == null) {
            return null;
          }
          // We should always handle an update, even if updatedModules is empty (but
          // non-null) for any reason. That's what webpack would normally do:
          // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298
          dispatcher.onBeforeRefresh();
          // https://webpack.js.org/api/hot-module-replacement/#apply
          return module.hot.apply();
        })
        .then(
          (updatedModules) => {
            handleApplyUpdates(null, updatedModules);
          },
          (err) => {
            handleApplyUpdates(err, null);
          }
        );
    }
    /** Handles messages from the server for the App Router. */ function processMessage(
      obj,
      sendMessage,
      processTurbopackMessage,
      router,
      dispatcher,
      appIsrManifestRef,
      pathnameRef
    ) {
      if (!('action' in obj)) {
        return;
      }
      function handleErrors(errors) {
        // "Massage" webpack messages.
        const formatted = (0, _formatwebpackmessages.default)({
          errors: errors,
          warnings: [],
        });
        // Only show the first error.
        dispatcher.onBuildError(formatted.errors[0]);
        // Also log them to the console.
        for (let i = 0; i < formatted.errors.length; i++) {
          console.error((0, _stripansi.default)(formatted.errors[i]));
        }
        // Do not attempt to reload now.
        // We will reload on next success instead.
        if (false) {
        }
      }
      function handleHotUpdate() {
        if (false) {
        } else {
          tryApplyUpdatesWebpack(sendMessage, dispatcher);
        }
      }
      switch (obj.action) {
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST: {
          if (true) {
            if (appIsrManifestRef) {
              appIsrManifestRef.current = obj.data;
              // handle initial status on receiving manifest
              // navigation is handled in useEffect for pathname changes
              // as we'll receive the updated manifest before usePathname
              // triggers for new value
              if (pathnameRef.current in obj.data) {
                dispatcher.onStaticIndicator(true);
              } else {
                dispatcher.onStaticIndicator(false);
              }
            }
          }
          break;
        }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING: {
          if (false) {
          } else {
            webpackStartMsSinceEpoch = Date.now();
            setPendingHotUpdateWebpack();
            console.log('[Fast Refresh] rebuilding');
          }
          break;
        }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT:
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SYNC: {
          if (obj.hash) {
            handleAvailableHash(obj.hash);
          }
          const { errors, warnings } = obj;
          // Is undefined when it's a 'built' event
          if ('versionInfo' in obj) dispatcher.onVersionInfo(obj.versionInfo);
          if ('debug' in obj && obj.debug) dispatcher.onDebugInfo(obj.debug);
          if ('devIndicator' in obj) dispatcher.onDevIndicator(obj.devIndicator);
          const hasErrors = Boolean(errors && errors.length);
          // Compilation with errors (e.g. syntax error or missing modules).
          if (hasErrors) {
            sendMessage(
              JSON.stringify({
                event: 'client-error',
                errorCount: errors.length,
                clientId: __nextDevClientId,
              })
            );
            handleErrors(errors);
            return;
          }
          const hasWarnings = Boolean(warnings && warnings.length);
          if (hasWarnings) {
            sendMessage(
              JSON.stringify({
                event: 'client-warning',
                warningCount: warnings.length,
                clientId: __nextDevClientId,
              })
            );
            // Print warnings to the console.
            const formattedMessages = (0, _formatwebpackmessages.default)({
              warnings: warnings,
              errors: [],
            });
            for (let i = 0; i < formattedMessages.warnings.length; i++) {
              if (i === 5) {
                console.warn(
                  'There were more warnings in other files.\n' +
                    'You can find a complete log in the terminal.'
                );
                break;
              }
              console.warn((0, _stripansi.default)(formattedMessages.warnings[i]));
            }
            // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings
          }
          sendMessage(
            JSON.stringify({
              event: 'client-success',
              clientId: __nextDevClientId,
            })
          );
          if (obj.action === _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT) {
            handleHotUpdate();
          }
          return;
        }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED: {
          processTurbopackMessage({
            type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,
            data: {
              sessionId: obj.data.sessionId,
            },
          });
          break;
        }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE: {
          turbopackHmr.onTurbopackMessage(obj);
          dispatcher.onBeforeRefresh();
          processTurbopackMessage({
            type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,
            data: obj.data,
          });
          if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
            console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);
            performFullReload(null, sendMessage);
          }
          dispatcher.onRefresh();
          break;
        }
        // TODO-APP: make server component change more granular
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES: {
          turbopackHmr == null ? void 0 : turbopackHmr.onServerComponentChanges();
          sendMessage(
            JSON.stringify({
              event: 'server-component-reload-page',
              clientId: __nextDevClientId,
              hash: obj.hash,
            })
          );
          // Store the latest hash in a session cookie so that it's sent back to the
          // server with any subsequent requests.
          document.cookie =
            _approuterheaders.NEXT_HMR_REFRESH_HASH_COOKIE + '=' + obj.hash;
          if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
            if (reloading) return;
            reloading = true;
            return window.location.reload();
          }
          (0, _react.startTransition)(() => {
            router.hmrRefresh();
            dispatcher.onRefresh();
          });
          if (false) {
          }
          return;
        }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE: {
          turbopackHmr == null ? void 0 : turbopackHmr.onReloadPage();
          sendMessage(
            JSON.stringify({
              event: 'client-reload-page',
              clientId: __nextDevClientId,
            })
          );
          if (reloading) return;
          reloading = true;
          return window.location.reload();
        }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE:
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE: {
          turbopackHmr == null ? void 0 : turbopackHmr.onPageAddRemove();
          // TODO-APP: potentially only refresh if the currently viewed page was added/removed.
          return router.hmrRefresh();
        }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR: {
          const { errorJSON } = obj;
          if (errorJSON) {
            const { message, stack } = JSON.parse(errorJSON);
            const error = Object.defineProperty(new Error(message), '__NEXT_ERROR_CODE', {
              value: 'E394',
              enumerable: false,
              configurable: true,
            });
            error.stack = stack;
            handleErrors([error]);
          }
          return;
        }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE: {
          return;
        }
        default: {
        }
      }
    }
    function HotReload(param) {
      let { assetPrefix, children, globalError } = param;
      const [state, dispatch] = (0, _shared.useErrorOverlayReducer)('app');
      const dispatcher = (0, _react.useMemo)(() => {
        return {
          onBuildOk() {
            dispatch({
              type: _shared.ACTION_BUILD_OK,
            });
          },
          onBuildError(message) {
            dispatch({
              type: _shared.ACTION_BUILD_ERROR,
              message,
            });
          },
          onBeforeRefresh() {
            dispatch({
              type: _shared.ACTION_BEFORE_REFRESH,
            });
          },
          onRefresh() {
            dispatch({
              type: _shared.ACTION_REFRESH,
            });
          },
          onVersionInfo(versionInfo) {
            dispatch({
              type: _shared.ACTION_VERSION_INFO,
              versionInfo,
            });
          },
          onStaticIndicator(status) {
            dispatch({
              type: _shared.ACTION_STATIC_INDICATOR,
              staticIndicator: status,
            });
          },
          onDebugInfo(debugInfo) {
            dispatch({
              type: _shared.ACTION_DEBUG_INFO,
              debugInfo,
            });
          },
          onDevIndicator(devIndicator) {
            dispatch({
              type: _shared.ACTION_DEV_INDICATOR,
              devIndicator,
            });
          },
        };
      }, [dispatch]);
      const handleOnUnhandledError = (0, _react.useCallback)(
        (error) => {
          // Component stack is added to the error in use-error-handler in case there was a hydration error
          const componentStackTrace = error._componentStack;
          dispatch({
            type: _shared.ACTION_UNHANDLED_ERROR,
            reason: error,
            frames: (0, _parsestack.parseStack)(error.stack || ''),
            componentStackFrames:
              typeof componentStackTrace === 'string'
                ? (0, _parsecomponentstack.parseComponentStack)(componentStackTrace)
                : undefined,
          });
        },
        [dispatch]
      );
      const handleOnUnhandledRejection = (0, _react.useCallback)(
        (reason) => {
          const stitchedError = (0, _stitchederror.getReactStitchedError)(reason);
          dispatch({
            type: _shared.ACTION_UNHANDLED_REJECTION,
            reason: stitchedError,
            frames: (0, _parsestack.parseStack)(stitchedError.stack || ''),
          });
        },
        [dispatch]
      );
      (0, _useerrorhandler.useErrorHandler)(
        handleOnUnhandledError,
        handleOnUnhandledRejection
      );
      const webSocketRef = (0, _usewebsocket.useWebsocket)(assetPrefix);
      (0, _usewebsocket.useWebsocketPing)(webSocketRef);
      const sendMessage = (0, _usewebsocket.useSendMessage)(webSocketRef);
      const processTurbopackMessage = (0, _usewebsocket.useTurbopack)(
        sendMessage,
        (err) => performFullReload(err, sendMessage)
      );
      const router = (0, _navigation.useRouter)();
      // We don't want access of the pathname for the dev tools to trigger a dynamic
      // access (as the dev overlay will never be present in production).
      const pathname = (0, _navigationuntracked.useUntrackedPathname)();
      const appIsrManifestRef = (0, _react.useRef)({});
      const pathnameRef = (0, _react.useRef)(pathname);
      if (true) {
        // this conditional is only for dead-code elimination which
        // isn't a runtime conditional only build-time so ignore hooks rule
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, _react.useEffect)(() => {
          pathnameRef.current = pathname;
          const appIsrManifest = appIsrManifestRef.current;
          if (appIsrManifest) {
            if (pathname && pathname in appIsrManifest) {
              try {
                dispatcher.onStaticIndicator(true);
              } catch (reason) {
                let message = '';
                if (reason instanceof DOMException) {
                  var _reason_stack;
                  // Most likely a SecurityError, because of an unavailable localStorage
                  message =
                    (_reason_stack = reason.stack) != null
                      ? _reason_stack
                      : reason.message;
                } else if (reason instanceof Error) {
                  var _reason_stack1;
                  message =
                    'Error: ' +
                    reason.message +
                    '\n' +
                    ((_reason_stack1 = reason.stack) != null ? _reason_stack1 : '');
                } else {
                  message = 'Unexpected Exception: ' + reason;
                }
                console.warn('[HMR] ' + message);
              }
            } else {
              dispatcher.onStaticIndicator(false);
            }
          }
        }, [pathname, dispatcher]);
      }
      (0, _react.useEffect)(() => {
        const websocket = webSocketRef.current;
        if (!websocket) return;
        const handler = (event) => {
          try {
            const obj = JSON.parse(event.data);
            (0, _handledevbuildindicatorhmrevents.handleDevBuildIndicatorHmrEvents)(obj);
            processMessage(
              obj,
              sendMessage,
              processTurbopackMessage,
              router,
              dispatcher,
              appIsrManifestRef,
              pathnameRef
            );
          } catch (err) {
            (0, _shared.reportInvalidHmrMessage)(event, err);
          }
        };
        websocket.addEventListener('message', handler);
        return () => websocket.removeEventListener('message', handler);
      }, [
        sendMessage,
        router,
        webSocketRef,
        dispatcher,
        processTurbopackMessage,
        appIsrManifestRef,
      ]);
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_appdevoverlay.AppDevOverlay, {
        state: state,
        globalError: globalError,
        children: children,
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=hot-reloader-client.js.map
  },
  5739: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'FontStyles', {
      enumerable: true,
      get: function () {
        return FontStyles;
      },
    });
    const _tagged_template_literal_loose = __webpack_require__(1637);
    const _css = __webpack_require__(6216);
    const _react = __webpack_require__(863);
    function _templateObject() {
      const data = _tagged_template_literal_loose._([
        "\n      /* latin-ext */\n      @font-face {\n        font-family: '__nextjs-Geist';\n        font-style: normal;\n        font-weight: 400 600;\n        font-display: swap;\n        src: url(/__nextjs_font/geist-latin-ext.woff2) format('woff2');\n        unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7,\n          U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F,\n          U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F,\n          U+A720-A7FF;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: '__nextjs-Geist Mono';\n        font-style: normal;\n        font-weight: 400 600;\n        font-display: swap;\n        src: url(/__nextjs_font/geist-mono-latin-ext.woff2) format('woff2');\n        unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7,\n          U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F,\n          U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F,\n          U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: '__nextjs-Geist';\n        font-style: normal;\n        font-weight: 400 600;\n        font-display: swap;\n        src: url(/__nextjs_font/geist-latin.woff2) format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122,\n          U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* latin */\n      @font-face {\n        font-family: '__nextjs-Geist Mono';\n        font-style: normal;\n        font-weight: 400 600;\n        font-display: swap;\n        src: url(/__nextjs_font/geist-mono-latin.woff2) format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122,\n          U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n    ",
      ]);
      _templateObject = function () {
        return data;
      };
      return data;
    }
    const FontStyles = () => {
      (0, _react.useInsertionEffect)(() => {
        const style = document.createElement('style');
        style.textContent = (0, _css.css)(_templateObject());
        document.head.appendChild(style);
        return () => {
          document.head.removeChild(style);
        };
      }, []);
      return null;
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=font-styles.js.map
  },
  6172: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ACTION_BEFORE_REFRESH: function () {
        return ACTION_BEFORE_REFRESH;
      },
      ACTION_BUILD_ERROR: function () {
        return ACTION_BUILD_ERROR;
      },
      ACTION_BUILD_OK: function () {
        return ACTION_BUILD_OK;
      },
      ACTION_DEBUG_INFO: function () {
        return ACTION_DEBUG_INFO;
      },
      ACTION_DEV_INDICATOR: function () {
        return ACTION_DEV_INDICATOR;
      },
      ACTION_REFRESH: function () {
        return ACTION_REFRESH;
      },
      ACTION_STATIC_INDICATOR: function () {
        return ACTION_STATIC_INDICATOR;
      },
      ACTION_UNHANDLED_ERROR: function () {
        return ACTION_UNHANDLED_ERROR;
      },
      ACTION_UNHANDLED_REJECTION: function () {
        return ACTION_UNHANDLED_REJECTION;
      },
      ACTION_VERSION_INFO: function () {
        return ACTION_VERSION_INFO;
      },
      INITIAL_OVERLAY_STATE: function () {
        return INITIAL_OVERLAY_STATE;
      },
      REACT_REFRESH_FULL_RELOAD: function () {
        return REACT_REFRESH_FULL_RELOAD;
      },
      REACT_REFRESH_FULL_RELOAD_FROM_ERROR: function () {
        return REACT_REFRESH_FULL_RELOAD_FROM_ERROR;
      },
      STORAGE_KEY_POSITION: function () {
        return STORAGE_KEY_POSITION;
      },
      STORAGE_KEY_SCALE: function () {
        return STORAGE_KEY_SCALE;
      },
      STORAGE_KEY_THEME: function () {
        return STORAGE_KEY_THEME;
      },
      reportInvalidHmrMessage: function () {
        return reportInvalidHmrMessage;
      },
      useErrorOverlayReducer: function () {
        return useErrorOverlayReducer;
      },
    });
    const _react = __webpack_require__(863);
    var _process_env___NEXT_DEV_INDICATOR;
    const ACTION_STATIC_INDICATOR = 'static-indicator';
    const ACTION_BUILD_OK = 'build-ok';
    const ACTION_BUILD_ERROR = 'build-error';
    const ACTION_BEFORE_REFRESH = 'before-fast-refresh';
    const ACTION_REFRESH = 'fast-refresh';
    const ACTION_VERSION_INFO = 'version-info';
    const ACTION_UNHANDLED_ERROR = 'unhandled-error';
    const ACTION_UNHANDLED_REJECTION = 'unhandled-rejection';
    const ACTION_DEBUG_INFO = 'debug-info';
    const ACTION_DEV_INDICATOR = 'dev-indicator';
    const STORAGE_KEY_THEME = '__nextjs-dev-tools-theme';
    const STORAGE_KEY_POSITION = '__nextjs-dev-tools-position';
    const STORAGE_KEY_SCALE = '__nextjs-dev-tools-scale';
    function pushErrorFilterDuplicates(errors, err) {
      return [
        ...errors.filter((e) => {
          // Filter out duplicate errors
          return e.event.reason.stack !== err.event.reason.stack;
        }),
        err,
      ];
    }
    const shouldDisableDevIndicator =
      ((_process_env___NEXT_DEV_INDICATOR = true) == null
        ? void 0
        : _process_env___NEXT_DEV_INDICATOR.toString()) === 'false';
    const INITIAL_OVERLAY_STATE = {
      nextId: 1,
      buildError: null,
      errors: [],
      notFound: false,
      staticIndicator: false,
      /* 
    This is set to `true` when we can reliably know
    whether the indicator is in disabled state or not.  
    Otherwise the surface would flicker because the disabled flag loads from the config.
  */ showIndicator: false,
      disableDevIndicator: false,
      refreshState: {
        type: 'idle',
      },
      versionInfo: {
        installed: '0.0.0',
        staleness: 'unknown',
      },
      debugInfo: {
        devtoolsFrontendUrl: undefined,
      },
    };
    function getInitialState(routerType) {
      return {
        ...INITIAL_OVERLAY_STATE,
        routerType,
      };
    }
    function useErrorOverlayReducer(routerType) {
      return (0, _react.useReducer)((state, action) => {
        switch (action.type) {
          case ACTION_DEBUG_INFO: {
            return {
              ...state,
              debugInfo: action.debugInfo,
            };
          }
          case ACTION_STATIC_INDICATOR: {
            return {
              ...state,
              staticIndicator: action.staticIndicator,
            };
          }
          case ACTION_BUILD_OK: {
            return {
              ...state,
              buildError: null,
            };
          }
          case ACTION_BUILD_ERROR: {
            return {
              ...state,
              buildError: action.message,
            };
          }
          case ACTION_BEFORE_REFRESH: {
            return {
              ...state,
              refreshState: {
                type: 'pending',
                errors: [],
              },
            };
          }
          case ACTION_REFRESH: {
            return {
              ...state,
              buildError: null,
              // and UNHANDLED_REJECTION events might be dispatched between the
              errors:
                // BEFORE_REFRESH and the REFRESH event. We want to keep those errors
                // around until the next refresh. Otherwise we run into a race
                // condition where those errors would be cleared on refresh completion
                // before they can be displayed.
                state.refreshState.type === 'pending' ? state.refreshState.errors : [],
              refreshState: {
                type: 'idle',
              },
            };
          }
          case ACTION_UNHANDLED_ERROR:
          case ACTION_UNHANDLED_REJECTION: {
            switch (state.refreshState.type) {
              case 'idle': {
                return {
                  ...state,
                  nextId: state.nextId + 1,
                  errors: pushErrorFilterDuplicates(state.errors, {
                    id: state.nextId,
                    event: action,
                  }),
                };
              }
              case 'pending': {
                return {
                  ...state,
                  nextId: state.nextId + 1,
                  refreshState: {
                    ...state.refreshState,
                    errors: pushErrorFilterDuplicates(state.refreshState.errors, {
                      id: state.nextId,
                      event: action,
                    }),
                  },
                };
              }
              default:
                return state;
            }
          }
          case ACTION_VERSION_INFO: {
            return {
              ...state,
              versionInfo: action.versionInfo,
            };
          }
          case ACTION_DEV_INDICATOR: {
            return {
              ...state,
              showIndicator: true,
              disableDevIndicator:
                shouldDisableDevIndicator || !!action.devIndicator.disabledUntil,
            };
          }
          default: {
            return state;
          }
        }
      }, getInitialState(routerType));
    }
    const REACT_REFRESH_FULL_RELOAD =
      '[Fast Refresh] performing full reload\n\n' +
      "Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\n" +
      'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\n' +
      'Consider migrating the non-React component export to a separate file and importing it into both files.\n\n' +
      'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\n' +
      'Fast Refresh requires at least one parent function component in your React tree.';
    const REACT_REFRESH_FULL_RELOAD_FROM_ERROR =
      '[Fast Refresh] performing full reload because your application had an unrecoverable error';
    function reportInvalidHmrMessage(message, err) {
      console.warn(
        '[HMR] Invalid message: ' +
          JSON.stringify(message) +
          '\n' +
          ((err instanceof Error && (err == null ? void 0 : err.stack)) || '')
      );
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=shared.js.map
  },
  7893: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      CALL_STACK_FRAME_STYLES: function () {
        return CALL_STACK_FRAME_STYLES;
      },
      CallStackFrame: function () {
        return CallStackFrame;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _hotlinkedtext = __webpack_require__(3704);
    const _external = __webpack_require__(8540);
    const _stackframe = __webpack_require__(9667);
    const _useopenineditor = __webpack_require__(9051);
    const CallStackFrame = function CallStackFrame(param) {
      let { frame } = param;
      var _frame_originalStackFrame;
      // TODO: ability to expand resolved frames
      const f =
        (_frame_originalStackFrame = frame.originalStackFrame) != null
          ? _frame_originalStackFrame
          : frame.sourceStackFrame;
      const hasSource = Boolean(frame.originalCodeFrame);
      const open = (0, _useopenineditor.useOpenInEditor)(
        hasSource
          ? {
              file: f.file,
              lineNumber: f.lineNumber,
              column: f.column,
            }
          : undefined
      );
      // Format method to strip out the webpack layer prefix.
      // e.g. (app-pages-browser)/./app/page.tsx -> ./app/page.tsx
      const formattedMethod = f.methodName.replace(/^\([\w-]+\)\//, '');
      // Formatted file source could be empty. e.g. <anonymous> will be formatted to empty string,
      // we'll skip rendering the frame in this case.
      const fileSource = (0, _stackframe.getFrameSource)(f);
      if (!fileSource) {
        return null;
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        'data-nextjs-call-stack-frame': true,
        'data-nextjs-call-stack-frame-no-source': !hasSource,
        'data-nextjs-call-stack-frame-ignored': frame.ignored,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
            className: 'call-stack-frame-method-name',
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsx)(_hotlinkedtext.HotlinkedText, {
                text: formattedMethod,
              }),
              hasSource &&
                /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
                  onClick: open,
                  className: 'open-in-editor-button',
                  children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_external.ExternalIcon, {
                    width: 16,
                    height: 16,
                  }),
                }),
              frame.error
                ? /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
                    className: 'source-mapping-error-button',
                    onClick: () => console.error(frame.reason),
                    title: 'Sourcemapping failed. Click to log cause of error.',
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(
                      _external.SourceMappingErrorIcon,
                      {
                        width: 16,
                        height: 16,
                      }
                    ),
                  })
                : null,
            ],
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
            className: 'call-stack-frame-file-source',
            'data-has-source': hasSource,
            children: fileSource,
          }),
        ],
      });
    };
    const CALL_STACK_FRAME_STYLES =
      '\n  [data-nextjs-call-stack-frame-no-source] {\n    padding: 6px 8px;\n    margin-bottom: 4px;\n\n    border-radius: var(--rounded-lg);\n  }\n\n  [data-nextjs-call-stack-frame-no-source]:last-child {\n    margin-bottom: 0;\n  }\n\n  [data-nextjs-call-stack-frame-ignored="true"] {\n    opacity: 0.6;\n  }\n\n  [data-nextjs-call-stack-frame] {\n    user-select: text;\n    display: block;\n    box-sizing: border-box;\n\n    user-select: text;\n    -webkit-user-select: text;\n    -moz-user-select: text;\n    -ms-user-select: text;\n\n    padding: 6px 8px;\n\n    border-radius: var(--rounded-lg);\n  }\n\n  .call-stack-frame-method-name {\n    display: flex;\n    align-items: center;\n    gap: 4px;\n\n    margin-bottom: 4px;\n    font-family: var(--font-stack-monospace);\n\n    color: var(--color-gray-1000);\n    font-size: var(--size-14);\n    font-weight: 500;\n    line-height: var(--size-20);\n\n    svg {\n      width: var(--size-16px);\n      height: var(--size-16px);\n    }\n  }\n\n  .open-in-editor-button, .source-mapping-error-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border-radius: var(--rounded-full);\n    padding: 4px;\n    color: var(--color-font);\n\n    svg {\n      width: var(--size-16);\n      height: var(--size-16);\n    }\n\n    &:focus-visible {\n      outline: var(--focus-ring);\n      outline-offset: -2px;\n    }\n\n    &:hover {\n      background: var(--color-gray-100);\n    }\n  }\n\n  .call-stack-frame-file-source {\n    color: var(--color-gray-900);\n    font-size: var(--size-14);\n    line-height: var(--size-20);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=call-stack-frame.js.map
  },
  8467: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      CODE_FRAME_STYLES: function () {
        return CODE_FRAME_STYLES;
      },
      CodeFrame: function () {
        return CodeFrame;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _hotlinkedtext = __webpack_require__(3704);
    const _stackframe = __webpack_require__(9667);
    const _useopenineditor = __webpack_require__(9051);
    const _external = __webpack_require__(8540);
    const _file = __webpack_require__(7378);
    const _parsecodeframe = __webpack_require__(7487);
    function CodeFrame(param) {
      let { stackFrame, codeFrame } = param;
      var _stackFrame_file;
      const formattedFrame = (0, _react.useMemo)(
        () => (0, _parsecodeframe.formatCodeFrame)(codeFrame),
        [codeFrame]
      );
      const decodedLines = (0, _react.useMemo)(
        () => (0, _parsecodeframe.groupCodeFrameLines)(formattedFrame),
        [formattedFrame]
      );
      const open = (0, _useopenineditor.useOpenInEditor)({
        file: stackFrame.file,
        lineNumber: stackFrame.lineNumber,
        column: stackFrame.column,
      });
      const fileExtension =
        stackFrame == null
          ? void 0
          : (_stackFrame_file = stackFrame.file) == null
            ? void 0
            : _stackFrame_file.split('.').pop();
      // TODO: make the caret absolute
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        'data-nextjs-codeframe': true,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
            className: 'code-frame-header',
            children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('p', {
              className: 'code-frame-link',
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                  className: 'code-frame-icon',
                  children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_file.FileIcon, {
                    lang: fileExtension,
                  }),
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsxs)('span', {
                  'data-text': true,
                  children: [
                    (0, _stackframe.getFrameSource)(stackFrame),
                    ' @',
                    ' ',
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_hotlinkedtext.HotlinkedText, {
                      text: stackFrame.methodName,
                    }),
                  ],
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
                  'aria-label': 'Open in editor',
                  'data-with-open-in-editor-link-source-file': true,
                  onClick: open,
                  children: /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                    className: 'code-frame-icon',
                    'data-icon': 'right',
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_external.ExternalIcon, {
                      width: 16,
                      height: 16,
                    }),
                  }),
                }),
              ],
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('pre', {
            className: 'code-frame-pre',
            children: decodedLines.map((line, lineIndex) => {
              const { lineNumber, isErroredLine } = (0,
              _parsecodeframe.parseLineNumberFromCodeFrameLine)(line, stackFrame);
              const lineNumberProps = {};
              if (lineNumber) {
                lineNumberProps['data-nextjs-codeframe-line'] = lineNumber;
              }
              if (isErroredLine) {
                lineNumberProps['data-nextjs-codeframe-line--errored'] = true;
              }
              return /*#__PURE__*/ (0, _jsxruntime.jsx)(
                'div',
                {
                  ...lineNumberProps,
                  children: line.map((entry, entryIndex) =>
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(
                      'span',
                      {
                        style: {
                          color: entry.fg ? 'var(--color-' + entry.fg + ')' : undefined,
                          ...(entry.decoration === 'bold' // above 600, hence a temporary fix is to use 500 for bold.
                            ? {
                                fontWeight: 500,
                              }
                            : entry.decoration === 'italic'
                              ? {
                                  fontStyle: 'italic',
                                }
                              : undefined),
                        },
                        children: entry.content,
                      },
                      'frame-' + entryIndex
                    )
                  ),
                },
                'line-' + lineIndex
              );
            }),
          }),
        ],
      });
    }
    const CODE_FRAME_STYLES =
      '\n  [data-nextjs-codeframe] {\n    --code-frame-padding: 12px;\n    --code-frame-line-height: var(--size-16);\n    background-color: var(--color-background-200);\n    overflow: hidden;\n    color: var(--color-gray-1000);\n    text-overflow: ellipsis;\n    border: 1px solid var(--color-gray-400);\n    border-radius: 8px;\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-12);\n    line-height: var(--code-frame-line-height);\n    margin: 8px 0;\n\n    svg {\n      width: var(--size-16);\n      height: var(--size-16);\n    }\n  }\n\n  .code-frame-link,\n  .code-frame-pre {\n    padding: var(--code-frame-padding);\n  }\n\n  .code-frame-link svg {\n    flex-shrink: 0;\n  }\n\n  .code-frame-link [data-text] {\n    display: inline-flex;\n    text-align: left;\n    margin: auto 6px;\n  }\n\n  .code-frame-header {\n    width: 100%;\n    transition: background 100ms ease-out;\n    border-radius: 8px 8px 0 0;\n    border-bottom: 1px solid var(--color-gray-400);\n  }\n\n  [data-with-open-in-editor-link-source-file] {\n    padding: 4px;\n    margin: -4px 0 -4px auto;\n    border-radius: var(--rounded-full);\n    margin-left: auto;\n\n    &:focus-visible {\n      outline: var(--focus-ring);\n      outline-offset: -2px;\n    }\n\n    &:hover {\n      background: var(--color-gray-100);\n    }\n  }\n\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n\n  [data-nextjs-codeframe] *:not(a) {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe-line][data-nextjs-codeframe-line--errored="true"] {\n    position: relative;\n    isolation: isolate;\n\n    > span { \n      position: relative;\n      z-index: 1;\n    }\n\n    &::after {\n      content: "";\n      width: calc(100% + var(--code-frame-padding) * 2);\n      height: var(--code-frame-line-height);\n      left: calc(-1 * var(--code-frame-padding));\n      background: var(--color-red-200);\n      box-shadow: 2px 0 0 0 var(--color-red-900) inset;\n      position: absolute;\n    }\n  }\n\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n  }\n\n  .code-frame-link {\n    display: flex;\n    margin: 0;\n    outline: 0;\n  }\n  .code-frame-link [data-icon=\'right\'] {\n    margin-left: auto;\n  }\n\n  [data-nextjs-codeframe] div > pre {\n    overflow: hidden;\n    display: inline-block;\n  }\n\n  [data-nextjs-codeframe] svg {\n    color: var(--color-gray-900);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=code-frame.js.map
  },
  7487: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      formatCodeFrame: function () {
        return formatCodeFrame;
      },
      groupCodeFrameLines: function () {
        return groupCodeFrameLines;
      },
      parseLineNumberFromCodeFrameLine: function () {
        return parseLineNumberFromCodeFrameLine;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _anser = /*#__PURE__*/ _interop_require_default._(__webpack_require__(1238));
    const _stripansi = /*#__PURE__*/ _interop_require_default._(
      __webpack_require__(7976)
    );
    function formatCodeFrame(codeFrame) {
      const lines = codeFrame.split(/\r?\n/g);
      // Find the minimum length of leading spaces after `|` in the code frame
      const miniLeadingSpacesLength = lines
        .map((line) =>
          /^>? +\d+ +\| [ ]+/.exec((0, _stripansi.default)(line)) === null
            ? null
            : /^>? +\d+ +\| ( *)/.exec((0, _stripansi.default)(line))
        )
        .filter(Boolean)
        .map((v) => v.pop())
        .reduce((c, n) => (isNaN(c) ? n.length : Math.min(c, n.length)), NaN);
      // When the minimum length of leading spaces is greater than 1, remove them
      // from the code frame to help the indentation looks better when there's a lot leading spaces.
      if (miniLeadingSpacesLength > 1) {
        return lines
          .map((line, a) =>
            ~(a = line.indexOf('|'))
              ? line.substring(0, a) +
                line.substring(a).replace('^\\ {' + miniLeadingSpacesLength + '}', '')
              : line
          )
          .join('\n');
      }
      return lines.join('\n');
    }
    function groupCodeFrameLines(formattedFrame) {
      // Map the decoded lines to a format that can be rendered
      const decoded = _anser.default.ansiToJson(formattedFrame, {
        json: true,
        use_classes: true,
        remove_empty: true,
      });
      const lines = [];
      let line = [];
      for (const token of decoded) {
        if (token.content === '\n') {
          lines.push(line);
          line = [];
        } else {
          line.push(token);
        }
      }
      if (line.length > 0) {
        lines.push(line);
      }
      return lines;
    }
    function parseLineNumberFromCodeFrameLine(line, stackFrame) {
      var _line_, _line_1, _stackFrame_lineNumber;
      let lineNumberToken;
      let lineNumber;
      // parse line number from line first 2 tokens
      // e.g. ` > 1 | const foo = 'bar'` => `1`, first token is `1 |`
      // e.g. `  2 | const foo = 'bar'` => `2`. first 2 tokens are ' ' and ' 2 |'
      // console.log('line', line)
      if (
        ((_line_ = line[0]) == null ? void 0 : _line_.content) === '>' ||
        ((_line_1 = line[0]) == null ? void 0 : _line_1.content) === ' '
      ) {
        var _lineNumberToken_content_replace, _lineNumberToken_content;
        lineNumberToken = line[1];
        lineNumber =
          lineNumberToken == null
            ? void 0
            : (_lineNumberToken_content = lineNumberToken.content) == null
              ? void 0
              : (_lineNumberToken_content_replace = _lineNumberToken_content.replace(
                    '|',
                    ''
                  )) == null
                ? void 0
                : _lineNumberToken_content_replace.trim();
      }
      // When the line number is possibly undefined, it can be just the non-source code line
      // e.g. the ^ sign can also take a line, we skip rendering line number for it
      return {
        lineNumber,
        isErroredLine:
          lineNumber ===
          ((_stackFrame_lineNumber = stackFrame.lineNumber) == null
            ? void 0
            : _stackFrame_lineNumber.toString()),
      };
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=parse-code-frame.js.map
  },
  4807: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      COPY_BUTTON_STYLES: function () {
        return COPY_BUTTON_STYLES;
      },
      CopyButton: function () {
        return CopyButton;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _cx = __webpack_require__(6160);
    function useCopyLegacy(content) {
      // This would be simpler with useActionState but we need to support React 18 here.
      // React 18 also doesn't have async transitions.
      const [copyState, dispatch] = _react.useReducer(
        {
          'useCopyLegacy.useReducer': (state, action) => {
            if (action.type === 'reset') {
              return {
                state: 'initial',
              };
            }
            if (action.type === 'copied') {
              return {
                state: 'success',
              };
            }
            if (action.type === 'copying') {
              return {
                state: 'pending',
              };
            }
            if (action.type === 'error') {
              return {
                state: 'error',
                error: action.error,
              };
            }
            return state;
          },
        }['useCopyLegacy.useReducer'],
        {
          state: 'initial',
        }
      );
      function copy() {
        if (isPending) {
          return;
        }
        if (!navigator.clipboard) {
          dispatch({
            type: 'error',
            error: Object.defineProperty(
              new Error('Copy to clipboard is not supported in this browser'),
              '__NEXT_ERROR_CODE',
              {
                value: 'E376',
                enumerable: false,
                configurable: true,
              }
            ),
          });
        } else {
          dispatch({
            type: 'copying',
          });
          navigator.clipboard.writeText(content).then(
            () => {
              dispatch({
                type: 'copied',
              });
            },
            (error) => {
              dispatch({
                type: 'error',
                error,
              });
            }
          );
        }
      }
      const reset = _react.useCallback(
        {
          'useCopyLegacy.useCallback[reset]': () => {
            dispatch({
              type: 'reset',
            });
          },
        }['useCopyLegacy.useCallback[reset]'],
        []
      );
      const isPending = copyState.state === 'pending';
      return [copyState, copy, reset, isPending];
    }
    function useCopyModern(content) {
      const [copyState, dispatch, isPending] = _react.useActionState(
        {
          'useCopyModern.useActionState': (state, action) => {
            if (action === 'reset') {
              return {
                state: 'initial',
              };
            }
            if (action === 'copy') {
              if (!navigator.clipboard) {
                return {
                  state: 'error',
                  error: Object.defineProperty(
                    new Error('Copy to clipboard is not supported in this browser'),
                    '__NEXT_ERROR_CODE',
                    {
                      value: 'E376',
                      enumerable: false,
                      configurable: true,
                    }
                  ),
                };
              }
              return navigator.clipboard.writeText(content).then(
                {
                  'useCopyModern.useActionState': () => {
                    return {
                      state: 'success',
                    };
                  },
                }['useCopyModern.useActionState'],
                {
                  'useCopyModern.useActionState': (error) => {
                    return {
                      state: 'error',
                      error,
                    };
                  },
                }['useCopyModern.useActionState']
              );
            }
            return state;
          },
        }['useCopyModern.useActionState'],
        {
          state: 'initial',
        }
      );
      function copy() {
        _react.startTransition(() => {
          dispatch('copy');
        });
      }
      const reset = _react.useCallback(
        {
          'useCopyModern.useCallback[reset]': () => {
            dispatch('reset');
          },
        }['useCopyModern.useCallback[reset]'],
        [
          // TODO: `dispatch` from `useActionState` is not reactive.
          // Remove from dependencies once https://github.com/facebook/react/pull/29665 is released.
          dispatch,
        ]
      );
      return [copyState, copy, reset, isPending];
    }
    const useCopy =
      typeof _react.useActionState === 'function' ? useCopyModern : useCopyLegacy;
    function CopyButton(param) {
      let { actionLabel, successLabel, content, icon, disabled, ...props } = param;
      const [copyState, copy, reset, isPending] = useCopy(content);
      const error = copyState.state === 'error' ? copyState.error : null;
      _react.useEffect(
        {
          'CopyButton.useEffect': () => {
            if (error !== null) {
              // Additional console.error to get the stack.
              console.error(error);
            }
          },
        }['CopyButton.useEffect'],
        [error]
      );
      _react.useEffect(
        {
          'CopyButton.useEffect': () => {
            if (copyState.state === 'success') {
              const timeoutId = setTimeout(
                {
                  'CopyButton.useEffect.timeoutId': () => {
                    reset();
                  },
                }['CopyButton.useEffect.timeoutId'],
                2000
              );
              return {
                'CopyButton.useEffect': () => {
                  clearTimeout(timeoutId);
                },
              }['CopyButton.useEffect'];
            }
          },
        }['CopyButton.useEffect'],
        [isPending, copyState.state, reset]
      );
      const isDisabled = isPending || disabled;
      const label = copyState.state === 'success' ? successLabel : actionLabel;
      // Assign default icon
      const renderedIcon =
        copyState.state === 'success'
          ? /*#__PURE__*/ (0, _jsxruntime.jsx)(CopySuccessIcon, {})
          : icon ||
            /*#__PURE__*/ (0, _jsxruntime.jsx)(CopyIcon, {
              width: 14,
              height: 14,
              className: 'error-overlay-toolbar-button-icon',
            });
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('button', {
        ...props,
        type: 'button',
        title: label,
        'aria-label': label,
        'aria-disabled': isDisabled,
        disabled: isDisabled,
        'data-nextjs-copy-button': true,
        className: (0, _cx.cx)(
          props.className,
          'nextjs-data-copy-button',
          'nextjs-data-copy-button--' + copyState.state
        ),
        onClick: () => {
          if (!isDisabled) {
            copy();
          }
        },
        children: [
          renderedIcon,
          copyState.state === 'error' ? ' ' + copyState.error : null,
        ],
      });
    }
    function CopyIcon(props) {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '14',
        height: '14',
        viewBox: '0 0 14 14',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        ...props,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M2.406.438c-.845 0-1.531.685-1.531 1.53v6.563c0 .846.686 1.531 1.531 1.531H3.937V8.75H2.406a.219.219 0 0 1-.219-.219V1.97c0-.121.098-.219.22-.219h4.812c.12 0 .218.098.218.219v.656H8.75v-.656c0-.846-.686-1.532-1.531-1.532H2.406zm4.375 3.5c-.845 0-1.531.685-1.531 1.53v6.563c0 .846.686 1.531 1.531 1.531h4.813c.845 0 1.531-.685 1.531-1.53V5.468c0-.846-.686-1.532-1.531-1.532H6.78zm-.218 1.53c0-.12.097-.218.218-.218h4.813c.12 0 .219.098.219.219v6.562c0 .121-.098.219-.22.219H6.782a.219.219 0 0 1-.218-.219V5.47z',
          fill: 'currentColor',
        }),
      });
    }
    function CopySuccessIcon() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        height: '16',
        xlinkTitle: 'copied',
        viewBox: '0 0 16 16',
        width: '16',
        stroke: 'currentColor',
        fill: 'currentColor',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          d: 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z',
        }),
      });
    }
    const COPY_BUTTON_STYLES =
      '\n  .nextjs-data-copy-button {\n    color: inherit;\n\n    svg {\n      width: var(--size-16);\n      height: var(--size-16);\n    }\n  }\n  .nextjs-data-copy-button--initial:hover {\n    cursor: pointer;\n  }\n  .nextjs-data-copy-button--error,\n  .nextjs-data-copy-button--error:hover {\n    color: var(--color-ansi-red);\n  }\n  .nextjs-data-copy-button--success {\n    color: var(--color-ansi-green);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=index.js.map
  },
  6751: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'DialogBody', {
      enumerable: true,
      get: function () {
        return DialogBody;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const DialogBody = function DialogBody(param) {
      let { children, className } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
        'data-nextjs-dialog-body': true,
        className: className,
        children: children,
      });
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dialog-body.js.map
  },
  8450: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'DialogContent', {
      enumerable: true,
      get: function () {
        return DialogContent;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const DialogContent = function DialogContent(param) {
      let { children, className } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
        'data-nextjs-dialog-content': true,
        className: className,
        children: children,
      });
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dialog-content.js.map
  },
  3259: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'DialogHeader', {
      enumerable: true,
      get: function () {
        return DialogHeader;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const DialogHeader = function DialogHeader(param) {
      let { children, className } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
        'data-nextjs-dialog-header': true,
        className: className,
        children: children,
      });
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dialog-header.js.map
  },
  8867: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'Dialog', {
      enumerable: true,
      get: function () {
        return Dialog;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _useonclickoutside = __webpack_require__(694);
    const _usemeasureheight = __webpack_require__(465);
    const CSS_SELECTORS_TO_EXCLUDE_ON_CLICK_OUTSIDE = [
      '[data-next-mark]',
      '[data-issues-open]',
      '#nextjs-dev-tools-menu',
      '[data-nextjs-error-overlay-nav]',
      '[data-info-popover]',
    ];
    const Dialog = function Dialog(param) {
      let {
        children,
        type,
        className,
        onClose,
        'aria-labelledby': ariaLabelledBy,
        'aria-describedby': ariaDescribedBy,
        dialogResizerRef,
        ...props
      } = param;
      const dialogRef = _react.useRef(null);
      const [role, setRole] = _react.useState(
        typeof document !== 'undefined' && document.hasFocus() ? 'dialog' : undefined
      );
      const ref = _react.useRef(null);
      const [height, pristine] = (0, _usemeasureheight.useMeasureHeight)(ref);
      (0, _useonclickoutside.useOnClickOutside)(
        dialogRef.current,
        CSS_SELECTORS_TO_EXCLUDE_ON_CLICK_OUTSIDE,
        (e) => {
          e.preventDefault();
          return onClose == null ? void 0 : onClose();
        }
      );
      _react.useEffect(
        {
          'Dialog.useEffect': () => {
            if (dialogRef.current == null) {
              return;
            }
            function handleFocus() {
              // safari will force itself as the active application when a background page triggers any sort of autofocus
              // this is a workaround to only set the dialog role if the document has focus
              setRole(document.hasFocus() ? 'dialog' : undefined);
            }
            window.addEventListener('focus', handleFocus);
            window.addEventListener('blur', handleFocus);
            return {
              'Dialog.useEffect': () => {
                window.removeEventListener('focus', handleFocus);
                window.removeEventListener('blur', handleFocus);
              },
            }['Dialog.useEffect'];
          },
        }['Dialog.useEffect'],
        []
      );
      _react.useEffect(
        {
          'Dialog.useEffect': () => {
            const dialog = dialogRef.current;
            const root = dialog == null ? void 0 : dialog.getRootNode();
            const initialActiveElement =
              root instanceof ShadowRoot
                ? root == null
                  ? void 0
                  : root.activeElement
                : null;
            // Trap focus within the dialog
            dialog == null ? void 0 : dialog.focus();
            return {
              'Dialog.useEffect': () => {
                // Blur first to avoid getting stuck, in case `activeElement` is missing
                dialog == null ? void 0 : dialog.blur();
                // Restore focus to the previously active element
                initialActiveElement == null ? void 0 : initialActiveElement.focus();
              },
            }['Dialog.useEffect'];
          },
        }['Dialog.useEffect'],
        []
      );
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
        ref: dialogRef,
        tabIndex: -1,
        'data-nextjs-dialog': true,
        role: role,
        'aria-labelledby': ariaLabelledBy,
        'aria-describedby': ariaDescribedBy,
        'aria-modal': 'true',
        className: className,
        onKeyDown: (e) => {
          if (e.key === 'Escape') {
            onClose == null ? void 0 : onClose();
          }
        },
        ...props,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
          ref: dialogResizerRef,
          'data-nextjs-dialog-sizer': true,
          // [x] Don't animate on initial load
          // [x] No duplicate elements
          // [x] Responds to content growth
          style: {
            height,
            transition: pristine ? undefined : 'height 250ms var(--timing-swift)',
          },
          children: /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
            ref: ref,
            children: children,
          }),
        }),
      });
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dialog.js.map
  },
  7074: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      Dialog: function () {
        return _dialog.Dialog;
      },
      DialogBody: function () {
        return _dialogbody.DialogBody;
      },
      DialogContent: function () {
        return _dialogcontent.DialogContent;
      },
      DialogHeader: function () {
        return _dialogheader.DialogHeader;
      },
      styles: function () {
        return _styles.styles;
      },
    });
    const _dialog = __webpack_require__(8867);
    const _dialogbody = __webpack_require__(6751);
    const _dialogcontent = __webpack_require__(8450);
    const _dialogheader = __webpack_require__(3259);
    const _styles = __webpack_require__(6946);
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=index.js.map
  },
  6946: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'styles', {
      enumerable: true,
      get: function () {
        return styles;
      },
    });
    const styles =
      "\n  [data-nextjs-dialog-root] {\n    --next-dialog-radius: var(--rounded-xl);\n    --next-dialog-max-width: 960px;\n    --next-dialog-row-padding: 16px;\n    --next-dialog-padding-x: 12px;\n    --next-dialog-notch-height: 42px;\n    --next-dialog-border-width: 1px;\n\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    max-height: calc(100% - 56px);\n    max-width: var(--next-dialog-max-width);\n    margin-right: auto;\n    margin-left: auto;\n    scale: 0.98;\n    opacity: 0;\n    transition-property: scale, opacity;\n    transition-duration: var(--transition-duration);\n    transition-timing-function: var(--timing-overlay);\n\n    &[data-rendered='true'] {\n      opacity: 1;\n      scale: 1;\n    }\n\n    [data-nextjs-scroll-fader][data-side=\"top\"] {\n      left: 1px;\n      top: calc(var(--next-dialog-notch-height) + var(--next-dialog-border-width));\n      width: calc(100% - var(--next-dialog-padding-x));\n      opacity: 0;\n    }\n  }\n\n  [data-nextjs-dialog] {\n    outline: 0;\n  }\n\n  [data-nextjs-dialog], [data-nextjs-dialog] * {\n    &::-webkit-scrollbar {\n      width: 6px;\n      height: 6px;\n      border-radius: 0 0 1rem 1rem;\n      margin-bottom: 1rem;\n    }\n\n    &::-webkit-scrollbar-button {\n      display: none;\n    }\n\n    &::-webkit-scrollbar-track {\n      border-radius: 0 0 1rem 1rem;\n      background-color: var(--color-background-100);\n    }\n      \n    &::-webkit-scrollbar-thumb {\n      border-radius: 1rem;\n      background-color: var(--color-gray-500);\n    }\n  }\n\n  /* Place overflow: hidden on this so we can break out from [data-nextjs-dialog] */\n  [data-nextjs-dialog-sizer] {\n    overflow: hidden;\n    border-radius: inherit;\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    opacity: 0;\n    transition: opacity var(--transition-duration) var(--timing-overlay);\n  }\n\n  [data-nextjs-dialog-overlay][data-rendered='true']\n    [data-nextjs-dialog-backdrop] {\n    opacity: 1;\n  }\n\n  [data-nextjs-dialog-content] {\n    border: none;\n    margin: 0;\n    display: flex;\n    flex-direction: column;\n    position: relative;\n    padding: 16px var(--next-dialog-padding-x);\n  }\n\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: 8px;\n  }\n\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n\n  @media (max-height: 812px) {\n    [data-nextjs-dialog-overlay] {\n      max-height: calc(100% - 15px);\n    }\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog-root] {\n      --next-dialog-max-width: 540px;\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog-root] {\n      --next-dialog-max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog-root] {\n      --next-dialog-max-width: 960px;\n    }\n  }\n";
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=styles.js.map
  },
  3498: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      CALL_STACK_STYLES: function () {
        return CALL_STACK_STYLES;
      },
      CallStack: function () {
        return CallStack;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _callstackframe = __webpack_require__(7893);
    function CallStack(param) {
      let { frames, dialogResizerRef } = param;
      const initialDialogHeight = (0, _react.useRef)(NaN);
      const [isIgnoreListOpen, setIsIgnoreListOpen] = (0, _react.useState)(false);
      const ignoredFramesTally = (0, _react.useMemo)(() => {
        return frames.reduce((tally, frame) => tally + (frame.ignored ? 1 : 0), 0);
      }, [frames]);
      function onToggleIgnoreList() {
        const dialog = dialogResizerRef == null ? void 0 : dialogResizerRef.current;
        if (!dialog) {
          return;
        }
        const { height: currentHeight } =
          dialog == null ? void 0 : dialog.getBoundingClientRect();
        if (!initialDialogHeight.current) {
          initialDialogHeight.current = currentHeight;
        }
        if (isIgnoreListOpen) {
          function onTransitionEnd() {
            dialog.removeEventListener('transitionend', onTransitionEnd);
            setIsIgnoreListOpen(false);
          }
          dialog.style.height = '' + initialDialogHeight.current + 'px';
          dialog.addEventListener('transitionend', onTransitionEnd);
        } else {
          setIsIgnoreListOpen(true);
        }
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        className: 'error-overlay-call-stack-container',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
            className: 'error-overlay-call-stack-header',
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('p', {
                className: 'error-overlay-call-stack-title',
                children: [
                  'Call Stack',
                  ' ',
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                    className: 'error-overlay-call-stack-count',
                    children: frames.length,
                  }),
                ],
              }),
              ignoredFramesTally > 0 &&
                /*#__PURE__*/ (0, _jsxruntime.jsxs)('button', {
                  'data-expand-ignore-button': isIgnoreListOpen,
                  className: 'error-overlay-call-stack-ignored-list-toggle-button',
                  onClick: onToggleIgnoreList,
                  children: [
                    (isIgnoreListOpen ? 'Hide' : 'Show') +
                      ' ' +
                      ignoredFramesTally +
                      ' ignore-listed frame(s)',
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(ChevronUpDown, {}),
                  ],
                }),
            ],
          }),
          frames.map((frame, frameIndex) => {
            return !frame.ignored || isIgnoreListOpen
              ? /*#__PURE__*/ (0, _jsxruntime.jsx)(
                  _callstackframe.CallStackFrame,
                  {
                    frame: frame,
                  },
                  frameIndex
                )
              : null;
          }),
        ],
      });
    }
    function ChevronUpDown() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '16',
        height: '16',
        viewBox: '0 0 16 16',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M8.70722 2.39641C8.3167 2.00588 7.68353 2.00588 7.29301 2.39641L4.46978 5.21963L3.93945 5.74996L5.00011 6.81062L5.53044 6.28029L8.00011 3.81062L10.4698 6.28029L11.0001 6.81062L12.0608 5.74996L11.5304 5.21963L8.70722 2.39641ZM5.53044 9.71963L5.00011 9.1893L3.93945 10.25L4.46978 10.7803L7.29301 13.6035C7.68353 13.994 8.3167 13.994 8.70722 13.6035L11.5304 10.7803L12.0608 10.25L11.0001 9.1893L10.4698 9.71963L8.00011 12.1893L5.53044 9.71963Z',
          fill: 'currentColor',
        }),
      });
    }
    const CALL_STACK_STYLES =
      '\n  .error-overlay-call-stack-container {\n    position: relative;\n    margin-top: 8px;\n  }\n\n  .error-overlay-call-stack-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    min-height: var(--size-28);\n    padding: 8px 8px 12px 4px;\n    width: 100%;\n  }\n\n  .error-overlay-call-stack-title {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    gap: 8px;\n\n    margin: 0;\n\n    color: var(--color-gray-1000);\n    font-size: var(--size-16);\n    font-weight: 500;\n  }\n\n  .error-overlay-call-stack-count {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n\n    width: var(--size-20);\n    height: var(--size-20);\n    gap: 4px;\n\n    color: var(--color-gray-1000);\n    text-align: center;\n    font-size: var(--size-11);\n    font-weight: 500;\n    line-height: var(--size-16);\n\n    border-radius: var(--rounded-full);\n    background: var(--color-gray-300);\n  }\n\n  .error-overlay-call-stack-ignored-list-toggle-button {\n    all: unset;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    color: var(--color-gray-900);\n    font-size: var(--size-14);\n    line-height: var(--size-20);\n    border-radius: 6px;\n    padding: 4px 6px;\n    margin-right: -6px;\n    transition: background 150ms ease;\n\n    &:hover {\n      background: var(--color-gray-100);\n    }\n\n    &:focus {\n      outline: var(--focus-ring);\n    }\n\n    svg {\n      width: var(--size-16);\n      height: var(--size-16);\n    }\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=call-stack.js.map
  },
  6862: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DEV_TOOLS_INDICATOR_STYLES: function () {
        return DEV_TOOLS_INDICATOR_STYLES;
      },
      DevToolsIndicator: function () {
        return DevToolsIndicator;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _toast = __webpack_require__(3709);
    const _nextlogo = __webpack_require__(3004);
    const _initialize = __webpack_require__(3125);
    const _devrenderindicator = __webpack_require__(9383);
    const _usedelayedrender = __webpack_require__(7000);
    const _turbopackinfo = __webpack_require__(4526);
    const _routeinfo = __webpack_require__(4926);
    const _gearicon = /*#__PURE__*/ _interop_require_default._(__webpack_require__(6149));
    const _userpreferences = __webpack_require__(4257);
    const _utils = __webpack_require__(9949);
    const _preferences = __webpack_require__(8708);
    function DevToolsIndicator(param) {
      let { state, errorCount, isBuildError, setIsErrorOverlayOpen, ...props } = param;
      const [isDevToolsIndicatorVisible, setIsDevToolsIndicatorVisible] = (0,
      _react.useState)(true);
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(DevToolsPopover, {
        routerType: state.routerType,
        semver: state.versionInfo.installed,
        issueCount: errorCount,
        isStaticRoute: state.staticIndicator,
        hide: () => {
          setIsDevToolsIndicatorVisible(false);
          fetch('/__nextjs_disable_dev_indicator', {
            method: 'POST',
          });
        },
        setIsErrorOverlayOpen: setIsErrorOverlayOpen,
        isTurbopack: !!false,
        disabled: state.disableDevIndicator || !isDevToolsIndicatorVisible,
        isBuildError: isBuildError,
        ...props,
      });
    }
    const Context = /*#__PURE__*/ (0, _react.createContext)({});
    const OVERLAYS = {
      Root: 'root',
      Turbo: 'turbo',
      Route: 'route',
      Preferences: 'preferences',
    };
    function DevToolsPopover(param) {
      let {
        routerType,
        disabled,
        issueCount,
        isStaticRoute,
        isTurbopack,
        isBuildError,
        hide,
        setIsErrorOverlayOpen,
        scale,
        setScale,
      } = param;
      const menuRef = (0, _react.useRef)(null);
      const triggerRef = (0, _react.useRef)(null);
      const [open, setOpen] = (0, _react.useState)(null);
      const [position, setPosition] = (0, _react.useState)(
        (0, _preferences.getInitialPosition)()
      );
      const [selectedIndex, setSelectedIndex] = (0, _react.useState)(-1);
      const isMenuOpen = open === OVERLAYS.Root;
      const isTurbopackInfoOpen = open === OVERLAYS.Turbo;
      const isRouteInfoOpen = open === OVERLAYS.Route;
      const isPreferencesOpen = open === OVERLAYS.Preferences;
      const { mounted: menuMounted, rendered: menuRendered } = (0,
      _usedelayedrender.useDelayedRender)(isMenuOpen, {
        // Intentionally no fade in, makes the UI feel more immediate
        enterDelay: 0,
        // Graceful fade out to confirm that the UI did not break
        exitDelay: _utils.MENU_DURATION_MS,
      });
      // Features to make the menu accessible
      (0, _utils.useFocusTrap)(menuRef, triggerRef, isMenuOpen);
      (0, _utils.useClickOutside)(menuRef, triggerRef, isMenuOpen, closeMenu);
      (0, _react.useEffect)(() => {
        if (open === null) {
          // Avoid flashing selected state
          const id = setTimeout(() => {
            setSelectedIndex(-1);
          }, _utils.MENU_DURATION_MS);
          return () => clearTimeout(id);
        }
      }, [open]);
      function select(index) {
        var _menuRef_current;
        if (index === 'first') {
          setTimeout(() => {
            var _menuRef_current;
            const all =
              (_menuRef_current = menuRef.current) == null
                ? void 0
                : _menuRef_current.querySelectorAll('[role="menuitem"]');
            if (all) {
              const firstIndex = all[0].getAttribute('data-index');
              select(Number(firstIndex));
            }
          });
          return;
        }
        if (index === 'last') {
          setTimeout(() => {
            var _menuRef_current;
            const all =
              (_menuRef_current = menuRef.current) == null
                ? void 0
                : _menuRef_current.querySelectorAll('[role="menuitem"]');
            if (all) {
              const lastIndex = all.length - 1;
              select(lastIndex);
            }
          });
          return;
        }
        const el =
          (_menuRef_current = menuRef.current) == null
            ? void 0
            : _menuRef_current.querySelector('[data-index="' + index + '"]');
        if (el) {
          setSelectedIndex(index);
          el == null ? void 0 : el.focus();
        }
      }
      function onMenuKeydown(e) {
        e.preventDefault();
        switch (e.key) {
          case 'ArrowDown':
            const next = selectedIndex + 1;
            select(next);
            break;
          case 'ArrowUp':
            const prev = selectedIndex - 1;
            select(prev);
            break;
          case 'Home':
            select('first');
            break;
          case 'End':
            select('last');
            break;
          default:
            break;
        }
      }
      function openErrorOverlay() {
        setOpen(null);
        if (issueCount > 0) {
          setIsErrorOverlayOpen(true);
        }
      }
      function toggleErrorOverlay() {
        setIsErrorOverlayOpen((prev) => !prev);
      }
      function openRootMenu() {
        setOpen((prevOpen) => {
          if (prevOpen === null) select('first');
          return OVERLAYS.Root;
        });
      }
      function onTriggerClick() {
        if (open === OVERLAYS.Root) {
          setOpen(null);
        } else {
          openRootMenu();
          setTimeout(() => {
            select('first');
          });
        }
      }
      function closeMenu() {
        // Only close when we were on `Root`,
        // otherwise it will close other overlays
        setOpen((prevOpen) => {
          if (prevOpen === OVERLAYS.Root) {
            return null;
          }
          return prevOpen;
        });
      }
      function handleHideDevtools() {
        setOpen(null);
        hide();
      }
      const [vertical, horizontal] = position.split('-', 2);
      const popover = {
        [vertical]: 'calc(100% + 8px)',
        [horizontal]: 0,
      };
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_toast.Toast, {
        'data-nextjs-toast': true,
        style: {
          '--animate-out-duration-ms': '' + _utils.MENU_DURATION_MS + 'ms',
          '--animate-out-timing-function': _utils.MENU_CURVE,
          boxShadow: 'none',
          zIndex: 2147483647,
          // Reset the toast component's default positions.
          bottom: 'initial',
          left: 'initial',
          [vertical]: '20px',
          [horizontal]: '20px',
        },
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_nextlogo.NextLogo, {
            ref: triggerRef,
            'aria-haspopup': 'menu',
            'aria-expanded': isMenuOpen,
            'aria-controls': 'nextjs-dev-tools-menu',
            'aria-label': '' + (isMenuOpen ? 'Close' : 'Open') + ' Next.js Dev Tools',
            'data-nextjs-dev-tools-button': true,
            disabled: disabled,
            issueCount: issueCount,
            onTriggerClick: onTriggerClick,
            toggleErrorOverlay: toggleErrorOverlay,
            isDevBuilding: (0, _initialize.useIsDevBuilding)(),
            isDevRendering: (0, _devrenderindicator.useIsDevRendering)(),
            isBuildError: isBuildError,
            scale: scale,
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_routeinfo.RouteInfo, {
            isOpen: isRouteInfoOpen,
            close: openRootMenu,
            triggerRef: triggerRef,
            style: popover,
            routerType: routerType,
            routeType: isStaticRoute ? 'Static' : 'Dynamic',
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_turbopackinfo.TurbopackInfo, {
            isOpen: isTurbopackInfoOpen,
            close: openRootMenu,
            triggerRef: triggerRef,
            style: popover,
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_userpreferences.UserPreferences, {
            isOpen: isPreferencesOpen,
            close: openRootMenu,
            triggerRef: triggerRef,
            style: popover,
            hide: handleHideDevtools,
            setPosition: setPosition,
            position: position,
            scale: scale,
            setScale: setScale,
          }),
          menuMounted &&
            /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
              ref: menuRef,
              id: 'nextjs-dev-tools-menu',
              role: 'menu',
              dir: 'ltr',
              'aria-orientation': 'vertical',
              'aria-label': 'Next.js Dev Tools Items',
              tabIndex: -1,
              className: 'dev-tools-indicator-menu',
              onKeyDown: onMenuKeydown,
              'data-rendered': menuRendered,
              style: popover,
              children: /*#__PURE__*/ (0, _jsxruntime.jsxs)(Context.Provider, {
                value: {
                  closeMenu,
                  selectedIndex,
                  setSelectedIndex,
                },
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                    className: 'dev-tools-indicator-inner',
                    children: [
                      issueCount > 0 &&
                        /*#__PURE__*/ (0, _jsxruntime.jsx)(MenuItem, {
                          title:
                            issueCount +
                            ' ' +
                            (issueCount === 1 ? 'issue' : 'issues') +
                            ' found. Click to view details in the dev overlay.',
                          index: 0,
                          label: 'Issues',
                          value: /*#__PURE__*/ (0, _jsxruntime.jsx)(IssueCount, {
                            children: issueCount,
                          }),
                          onClick: openErrorOverlay,
                        }),
                      /*#__PURE__*/ (0, _jsxruntime.jsx)(MenuItem, {
                        title:
                          'Current route is ' +
                          (isStaticRoute ? 'static' : 'dynamic') +
                          '.',
                        label: 'Route',
                        index: 1,
                        value: isStaticRoute ? 'Static' : 'Dynamic',
                        onClick: () => setOpen(OVERLAYS.Route),
                        'data-nextjs-route-type': isStaticRoute ? 'static' : 'dynamic',
                      }),
                      isTurbopack
                        ? /*#__PURE__*/ (0, _jsxruntime.jsx)(MenuItem, {
                            title: 'Turbopack is enabled.',
                            label: 'Turbopack',
                            value: 'Enabled',
                          })
                        : /*#__PURE__*/ (0, _jsxruntime.jsx)(MenuItem, {
                            index: 2,
                            title:
                              'Learn about Turbopack and how to enable it in your application.',
                            label: 'Try Turbopack',
                            value: /*#__PURE__*/ (0, _jsxruntime.jsx)(ChevronRight, {}),
                            onClick: () => setOpen(OVERLAYS.Turbo),
                          }),
                    ],
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                    className: 'dev-tools-indicator-footer',
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MenuItem, {
                      'data-preferences': true,
                      label: 'Preferences',
                      value: /*#__PURE__*/ (0, _jsxruntime.jsx)(_gearicon.default, {}),
                      onClick: () => setOpen(OVERLAYS.Preferences),
                      index: isTurbopack ? 2 : 3,
                    }),
                  }),
                ],
              }),
            }),
        ],
      });
    }
    function ChevronRight() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: '16',
        height: '16',
        viewBox: '0 0 16 16',
        fill: 'none',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fill: '#666',
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M5.50011 1.93945L6.03044 2.46978L10.8537 7.293C11.2442 7.68353 11.2442 8.31669 10.8537 8.70722L6.03044 13.5304L5.50011 14.0608L4.43945 13.0001L4.96978 12.4698L9.43945 8.00011L4.96978 3.53044L4.43945 3.00011L5.50011 1.93945Z',
        }),
      });
    }
    function MenuItem(param) {
      let { index, label, value, onClick, href, ...props } = param;
      const isInteractive = typeof onClick === 'function' || typeof href === 'string';
      const { closeMenu, selectedIndex, setSelectedIndex } = (0, _react.useContext)(
        Context
      );
      const selected = selectedIndex === index;
      function click() {
        if (isInteractive) {
          onClick == null ? void 0 : onClick();
          closeMenu();
          if (href) {
            window.open(href, '_blank', 'noopener, noreferrer');
          }
        }
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        className: 'dev-tools-indicator-item',
        'data-index': index,
        'data-selected': selected,
        onClick: click,
        // Needs `onMouseMove` instead of enter to work together
        // with keyboard and mouse input
        onMouseMove: () => {
          if (isInteractive && index !== undefined && selectedIndex !== index) {
            setSelectedIndex(index);
          }
        },
        onMouseLeave: () => setSelectedIndex(-1),
        onKeyDown: (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            click();
          }
        },
        role: isInteractive ? 'menuitem' : undefined,
        tabIndex: selected ? 0 : -1,
        ...props,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
            className: 'dev-tools-indicator-label',
            children: label,
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
            className: 'dev-tools-indicator-value',
            children: value,
          }),
        ],
      });
    }
    function IssueCount(param) {
      let { children } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('span', {
        className: 'dev-tools-indicator-issue-count',
        'data-has-issues': children > 0,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
            className: 'dev-tools-indicator-issue-count-indicator',
          }),
          children,
        ],
      });
    }
    const DEV_TOOLS_INDICATOR_STYLES =
      "\n  .dev-tools-indicator-menu {\n    -webkit-font-smoothing: antialiased;\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n    background: var(--color-background-100);\n    border: 1px solid var(--color-gray-alpha-400);\n    background-clip: padding-box;\n    box-shadow: var(--shadow-menu);\n    border-radius: var(--rounded-xl);\n    position: absolute;\n    font-family: var(--font-stack-sans);\n    z-index: 1000;\n    overflow: hidden;\n    opacity: 0;\n    outline: 0;\n    min-width: 248px;\n    transition: opacity var(--animate-out-duration-ms)\n      var(--animate-out-timing-function);\n\n    &[data-rendered='true'] {\n      opacity: 1;\n      scale: 1;\n    }\n  }\n\n  .dev-tools-indicator-inner {\n    padding: 6px;\n    width: 100%;\n  }\n\n  .dev-tools-indicator-item {\n    display: flex;\n    align-items: center;\n    padding: 8px 6px;\n    height: var(--size-36);\n    border-radius: 6px;\n    text-decoration: none !important;\n    user-select: none;\n    white-space: nowrap;\n\n    svg {\n      width: var(--size-16);\n      height: var(--size-16);\n    }\n\n    &:focus-visible {\n      outline: 0;\n    }\n  }\n\n  .dev-tools-indicator-footer {\n    background: var(--color-background-200);\n    padding: 6px;\n    border-top: 1px solid var(--color-gray-400);\n    width: 100%;\n  }\n\n  .dev-tools-indicator-item[data-selected='true'] {\n    cursor: pointer;\n    background-color: var(--color-gray-200);\n  }\n\n  .dev-tools-indicator-label {\n    font-size: var(--size-14);\n    line-height: var(--size-20);\n    color: var(--color-gray-1000);\n  }\n\n  .dev-tools-indicator-value {\n    font-size: var(--size-14);\n    line-height: var(--size-20);\n    color: var(--color-gray-900);\n    margin-left: auto;\n  }\n\n  .dev-tools-indicator-issue-count {\n    --color-primary: var(--color-gray-800);\n    --color-secondary: var(--color-gray-100);\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: center;\n    gap: 8px;\n    min-width: var(--size-40);\n    height: var(--size-24);\n    background: var(--color-background-100);\n    border: 1px solid var(--color-gray-alpha-400);\n    background-clip: padding-box;\n    box-shadow: var(--shadow-small);\n    padding: 2px;\n    color: var(--color-gray-1000);\n    border-radius: 128px;\n    font-weight: 500;\n    font-size: var(--size-13);\n    font-variant-numeric: tabular-nums;\n\n    &[data-has-issues='true'] {\n      --color-primary: var(--color-red-800);\n      --color-secondary: var(--color-red-100);\n    }\n\n    .dev-tools-indicator-issue-count-indicator {\n      width: var(--size-8);\n      height: var(--size-8);\n      background: var(--color-primary);\n      box-shadow: 0 0 0 2px var(--color-secondary);\n      border-radius: 50%;\n    }\n  }\n\n  .dev-tools-indicator-shortcut {\n    display: flex;\n    gap: 4px;\n\n    kbd {\n      width: var(--size-20);\n      height: var(--size-20);\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      border-radius: var(--rounded-md);\n      border: 1px solid var(--color-gray-400);\n      font-family: var(--font-stack-sans);\n      background: var(--color-background-100);\n      color: var(--color-gray-1000);\n      text-align: center;\n      font-size: var(--size-12);\n      line-height: var(--size-16);\n    }\n  }\n";
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dev-tools-indicator.js.map
  },
  6462: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DEV_TOOLS_INFO_STYLES: function () {
        return DEV_TOOLS_INFO_STYLES;
      },
      DevToolsInfo: function () {
        return DevToolsInfo;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _utils = __webpack_require__(9949);
    const _usedelayedrender = __webpack_require__(7000);
    function DevToolsInfo(param) {
      let { title, children, learnMoreLink, isOpen, triggerRef, close, ...props } = param;
      const ref = (0, _react.useRef)(null);
      const closeButtonRef = (0, _react.useRef)(null);
      const { mounted, rendered } = (0, _usedelayedrender.useDelayedRender)(isOpen, {
        // Intentionally no fade in, makes the UI feel more immediate
        enterDelay: 0,
        // Graceful fade out to confirm that the UI did not break
        exitDelay: _utils.MENU_DURATION_MS,
      });
      (0, _utils.useFocusTrap)(ref, triggerRef, isOpen, () => {
        var _closeButtonRef_current;
        (_closeButtonRef_current = closeButtonRef.current) == null
          ? void 0
          : _closeButtonRef_current.focus();
      });
      (0, _utils.useClickOutside)(ref, triggerRef, isOpen, close);
      if (!mounted) {
        return null;
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
        tabIndex: -1,
        role: 'dialog',
        ref: ref,
        'data-info-popover': true,
        ...props,
        'data-rendered': rendered,
        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
          className: 'dev-tools-info-container',
          children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)('h1', {
              className: 'dev-tools-info-title',
              children: title,
            }),
            children,
            /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
              className: 'dev-tools-info-button-container',
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
                  ref: closeButtonRef,
                  className: 'dev-tools-info-close-button',
                  onClick: close,
                  children: 'Close',
                }),
                learnMoreLink &&
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('a', {
                    className: 'dev-tools-info-learn-more-button',
                    href: learnMoreLink,
                    target: '_blank',
                    rel: 'noreferrer noopener',
                    children: 'Learn More',
                  }),
              ],
            }),
          ],
        }),
      });
    }
    const DEV_TOOLS_INFO_STYLES =
      "\n  [data-info-popover] {\n    -webkit-font-smoothing: antialiased;\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n    background: var(--color-background-100);\n    border: 1px solid var(--color-gray-alpha-400);\n    background-clip: padding-box;\n    box-shadow: var(--shadow-menu);\n    border-radius: var(--rounded-xl);\n    position: absolute;\n    font-family: var(--font-stack-sans);\n    z-index: 1000;\n    overflow: hidden;\n    opacity: 0;\n    outline: 0;\n    min-width: 350px;\n    transition: opacity var(--animate-out-duration-ms)\n      var(--animate-out-timing-function);\n\n    &[data-rendered='true'] {\n      opacity: 1;\n      scale: 1;\n    }\n\n    button:focus-visible {\n      outline: var(--focus-ring);\n    }\n  }\n\n  .dev-tools-info-container {\n    padding: 12px;\n  }\n\n  .dev-tools-info-title {\n    padding: 8px 6px;\n    color: var(--color-gray-1000);\n    font-size: var(--size-16);\n    font-weight: 600;\n    line-height: var(--size-20);\n    margin: 0;\n  }\n\n  .dev-tools-info-article {\n    padding: 8px 6px;\n    color: var(--color-gray-1000);\n    font-size: var(--size-14);\n    line-height: var(--size-20);\n    margin: 0;\n  }\n  .dev-tools-info-paragraph {\n    &:last-child {\n      margin-bottom: 0;\n    }\n  }\n\n  .dev-tools-info-button-container {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 8px 6px;\n  }\n\n  .dev-tools-info-close-button {\n    padding: 0 8px;\n    height: var(--size-28);\n    font-size: var(--size-14);\n    font-weight: 500;\n    line-height: var(--size-20);\n    transition: background var(--duration-short) ease;\n    color: var(--color-gray-1000);\n    border-radius: var(--rounded-md-2);\n    border: 1px solid var(--color-gray-alpha-400);\n    background: var(--color-background-200);\n  }\n\n  .dev-tools-info-close-button:hover {\n    background: var(--color-gray-400);\n  }\n\n  .dev-tools-info-learn-more-button {\n    align-content: center;\n    padding: 0 8px;\n    height: var(--size-28);\n    font-size: var(--size-14);\n    font-weight: 500;\n    line-height: var(--size-20);\n    transition: background var(--duration-short) ease;\n    color: var(--color-background-100);\n    border-radius: var(--rounded-md-2);\n    background: var(--color-gray-1000);\n  }\n\n  .dev-tools-info-learn-more-button:hover {\n    text-decoration: none;\n    color: var(--color-background-100);\n    opacity: 0.9;\n  }\n";
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dev-tools-info.js.map
  },
  8708: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      NEXT_DEV_TOOLS_SCALE: function () {
        return NEXT_DEV_TOOLS_SCALE;
      },
      getInitialPosition: function () {
        return getInitialPosition;
      },
      getInitialTheme: function () {
        return getInitialTheme;
      },
      useDevToolsScale: function () {
        return useDevToolsScale;
      },
    });
    const _react = __webpack_require__(863);
    const _shared = __webpack_require__(6172);
    const INDICATOR_POSITION = 'bottom-left' || 0;
    function getInitialPosition() {
      if (
        typeof localStorage !== 'undefined' &&
        localStorage.getItem(_shared.STORAGE_KEY_POSITION)
      ) {
        return localStorage.getItem(_shared.STORAGE_KEY_POSITION);
      }
      return INDICATOR_POSITION;
    }
    //////////////////////////////////////////////////////////////////////////////////////
    const BASE_SIZE = 16;
    const NEXT_DEV_TOOLS_SCALE = {
      Small: BASE_SIZE / 14,
      Medium: BASE_SIZE / 16,
      Large: BASE_SIZE / 18,
    };
    function getInitialScale() {
      if (
        typeof localStorage !== 'undefined' &&
        localStorage.getItem(_shared.STORAGE_KEY_SCALE)
      ) {
        return Number(localStorage.getItem(_shared.STORAGE_KEY_SCALE));
      }
      return NEXT_DEV_TOOLS_SCALE.Medium;
    }
    function useDevToolsScale() {
      const [scale, setScale] = (0, _react.useState)(getInitialScale());
      function set(value) {
        setScale(value);
        localStorage.setItem(_shared.STORAGE_KEY_SCALE, String(value));
      }
      return [scale, set];
    }
    function getInitialTheme() {
      if (typeof localStorage === 'undefined') {
        return 'system';
      }
      const theme = localStorage.getItem(_shared.STORAGE_KEY_THEME);
      return theme === 'dark' || theme === 'light' ? theme : 'system';
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=preferences.js.map
  },
  4926: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DEV_TOOLS_INFO_ROUTE_INFO_STYLES: function () {
        return DEV_TOOLS_INFO_ROUTE_INFO_STYLES;
      },
      RouteInfo: function () {
        return RouteInfo;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _devtoolsinfo = __webpack_require__(6462);
    function StaticRouteContent(param) {
      let { routerType } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('article', {
        className: 'dev-tools-info-article',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('p', {
            className: 'dev-tools-info-paragraph',
            children: [
              'The path',
              ' ',
              /*#__PURE__*/ (0, _jsxruntime.jsx)('code', {
                className: 'dev-tools-info-code',
                children: window.location.pathname,
              }),
              ' ',
              'is marked as "static" since it will be prerendered during the build time.',
            ],
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('p', {
            className: 'dev-tools-info-paragraph',
            children: [
              'With Static Rendering, routes are rendered at build time, or in the background after',
              ' ',
              /*#__PURE__*/ (0, _jsxruntime.jsx)('a', {
                className: 'dev-tools-info-link',
                href:
                  routerType === 'pages'
                    ? 'https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration'
                    : 'https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration',
                target: '_blank',
                rel: 'noopener noreferrer',
                children: 'data revalidation',
              }),
              '.',
            ],
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
            className: 'dev-tools-info-paragraph',
            children:
              'Static rendering is useful when a route has data that is not personalized to the user and can be known at build time, such as a static blog post or a product page.',
          }),
        ],
      });
    }
    function DynamicRouteContent(param) {
      let { routerType } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('article', {
        className: 'dev-tools-info-article',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('p', {
            className: 'dev-tools-info-paragraph',
            children: [
              'The path',
              ' ',
              /*#__PURE__*/ (0, _jsxruntime.jsx)('code', {
                className: 'dev-tools-info-code',
                children: window.location.pathname,
              }),
              ' ',
              'is marked as "dynamic" since it will be rendered for each user at',
              ' ',
              /*#__PURE__*/ (0, _jsxruntime.jsx)('strong', {
                children: 'request time',
              }),
              '.',
            ],
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
            className: 'dev-tools-info-paragraph',
            children:
              "Dynamic rendering is useful when a route has data that is personalized to the user or has information that can only be known at request time, such as cookies or the URL's search params.",
          }),
          routerType === 'pages'
            ? /*#__PURE__*/ (0, _jsxruntime.jsxs)('p', {
                className: 'dev-tools-info-pagraph',
                children: [
                  'Exporting the',
                  ' ',
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('a', {
                    className: 'dev-tools-info-link',
                    href: 'https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props',
                    target: '_blank',
                    rel: 'noopener noreferrer',
                    children: 'getServerSideProps',
                  }),
                  ' ',
                  'function will opt the route into dynamic rendering. This function will be called by the server on every request.',
                ],
              })
            : /*#__PURE__*/ (0, _jsxruntime.jsxs)('p', {
                className: 'dev-tools-info-paragraph',
                children: [
                  'During rendering, if a',
                  ' ',
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('a', {
                    className: 'dev-tools-info-link',
                    href: 'https://nextjs.org/docs/app/building-your-application/rendering/server-components#dynamic-apis',
                    target: '_blank',
                    rel: 'noopener noreferrer',
                    children: 'Dynamic API',
                  }),
                  ' ',
                  'or a',
                  ' ',
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('a', {
                    className: 'dev-tools-info-link',
                    href: 'https://nextjs.org/docs/app/api-reference/functions/fetch',
                    target: '_blank',
                    rel: 'noopener noreferrer',
                    children: 'fetch',
                  }),
                  ' ',
                  'option of',
                  ' ',
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('code', {
                    className: 'dev-tools-info-code',
                    children: "{ cache: 'no-store' }",
                  }),
                  ' ',
                  'is discovered, Next.js will switch to dynamically rendering the whole route.',
                ],
              }),
        ],
      });
    }
    const learnMoreLink = {
      pages: {
        static:
          'https://nextjs.org/docs/pages/building-your-application/rendering/static-site-generation',
        dynamic:
          'https://nextjs.org/docs/pages/building-your-application/rendering/server-side-rendering',
      },
      app: {
        static:
          'https://nextjs.org/docs/app/building-your-application/rendering/server-components#static-rendering-default',
        dynamic:
          'https://nextjs.org/docs/app/building-your-application/rendering/server-components#dynamic-rendering',
      },
    };
    function RouteInfo(param) {
      let { routeType, routerType, ...props } = param;
      const isStaticRoute = routeType === 'Static';
      const learnMore = isStaticRoute
        ? learnMoreLink[routerType].static
        : learnMoreLink[routerType].dynamic;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_devtoolsinfo.DevToolsInfo, {
        title: '' + routeType + ' Route',
        learnMoreLink: learnMore,
        ...props,
        children: isStaticRoute
          ? /*#__PURE__*/ (0, _jsxruntime.jsx)(StaticRouteContent, {
              routerType: routerType,
            })
          : /*#__PURE__*/ (0, _jsxruntime.jsx)(DynamicRouteContent, {
              routerType: routerType,
            }),
      });
    }
    const DEV_TOOLS_INFO_ROUTE_INFO_STYLES = '';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=route-info.js.map
  },
  4526: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DEV_TOOLS_INFO_TURBOPACK_INFO_STYLES: function () {
        return DEV_TOOLS_INFO_TURBOPACK_INFO_STYLES;
      },
      TurbopackInfo: function () {
        return TurbopackInfo;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _devtoolsinfo = __webpack_require__(6462);
    const _copybutton = __webpack_require__(4807);
    function TurbopackInfo(props) {
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_devtoolsinfo.DevToolsInfo, {
        title: 'Turbopack',
        learnMoreLink: 'https://nextjs.org/docs/app/api-reference/turbopack',
        ...props,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('article', {
            className: 'dev-tools-info-article',
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('p', {
                className: 'dev-tools-info-paragraph',
                children: [
                  'Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. Turbopack can be used in Next.js in both the',
                  ' ',
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('code', {
                    className: 'dev-tools-info-code',
                    children: 'pages',
                  }),
                  ' and',
                  ' ',
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('code', {
                    className: 'dev-tools-info-code',
                    children: 'app',
                  }),
                  ' directories for faster local development.',
                ],
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('p', {
                className: 'dev-tools-info-paragraph',
                children: [
                  'To enable Turbopack, use the',
                  ' ',
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('code', {
                    className: 'dev-tools-info-code',
                    children: '--turbopack',
                  }),
                  ' flag when running the Next.js development server.',
                ],
              }),
            ],
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
            className: 'dev-tools-info-code-block-container',
            children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
              className: 'dev-tools-info-code-block',
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)(_copybutton.CopyButton, {
                  actionLabel: 'Copy Next.js Turbopack Command',
                  successLabel: 'Next.js Turbopack Command Copied',
                  content: '--turbopack',
                  className: 'dev-tools-info-copy-button',
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)('pre', {
                  className: 'dev-tools-info-code-block-pre',
                  children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('code', {
                    children: [
                      /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                        className: 'dev-tools-info-code-block-line',
                        children: '  ',
                      }),
                      /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                        className: 'dev-tools-info-code-block-line',
                        children: '{',
                      }),
                      /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                        className: 'dev-tools-info-code-block-line',
                        children: [
                          '  ',
                          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                            className: 'dev-tools-info-code-block-json-key',
                            children: '"scripts"',
                          }),
                          ': ',
                          '{',
                        ],
                      }),
                      /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                        className:
                          'dev-tools-info-code-block-line dev-tools-info-highlight',
                        children: [
                          '    ',
                          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                            className: 'dev-tools-info-code-block-json-key',
                            children: '"dev"',
                          }),
                          ':',
                          ' ',
                          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                            className: 'dev-tools-info-code-block-json-value',
                            children: '"next dev --turbopack"',
                          }),
                          ',',
                        ],
                      }),
                      /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                        className: 'dev-tools-info-code-block-line',
                        children: [
                          '    ',
                          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                            className: 'dev-tools-info-code-block-json-key',
                            children: '"build"',
                          }),
                          ':',
                          ' ',
                          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                            className: 'dev-tools-info-code-block-json-value',
                            children: '"next build"',
                          }),
                          ',',
                        ],
                      }),
                      /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                        className: 'dev-tools-info-code-block-line',
                        children: [
                          '    ',
                          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                            className: 'dev-tools-info-code-block-json-key',
                            children: '"start"',
                          }),
                          ':',
                          ' ',
                          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                            className: 'dev-tools-info-code-block-json-value',
                            children: '"next start"',
                          }),
                          ',',
                        ],
                      }),
                      /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                        className: 'dev-tools-info-code-block-line',
                        children: [
                          '    ',
                          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                            className: 'dev-tools-info-code-block-json-key',
                            children: '"lint"',
                          }),
                          ':',
                          ' ',
                          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                            className: 'dev-tools-info-code-block-json-value',
                            children: '"next lint"',
                          }),
                        ],
                      }),
                      /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                        className: 'dev-tools-info-code-block-line',
                        children: '  }',
                      }),
                      /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                        className: 'dev-tools-info-code-block-line',
                        children: '}',
                      }),
                      /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                        className: 'dev-tools-info-code-block-line',
                        children: '  ',
                      }),
                    ],
                  }),
                }),
              ],
            }),
          }),
        ],
      });
    }
    const DEV_TOOLS_INFO_TURBOPACK_INFO_STYLES =
      '\n  .dev-tools-info-code {\n    background: var(--color-gray-400);\n    color: var(--color-gray-1000);\n    font-family: var(--font-stack-monospace);\n    padding: 2px 4px;\n    margin: 0;\n    font-size: var(--size-13);\n    white-space: break-spaces;\n    border-radius: var(--rounded-md-2);\n  }\n\n  .dev-tools-info-code-block-container {\n    padding: 6px;\n  }\n\n  .dev-tools-info-code-block {\n    position: relative;\n    background: var(--color-background-200);\n    border: 1px solid var(--color-gray-alpha-400);\n    border-radius: var(--rounded-md-2);\n    min-width: 326px;\n  }\n\n  .dev-tools-info-code-block-pre {\n    margin: 0;\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-12);\n  }\n\n  .dev-tools-info-copy-button {\n    position: absolute;\n\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    right: 8px;\n    top: 8px;\n    padding: 4px;\n    height: var(--size-24);\n    width: var(--size-24);\n    border-radius: var(--rounded-md-2);\n    border: 1px solid var(--color-gray-alpha-400);\n    background: var(--color-background-100);\n  }\n\n  .dev-tools-info-code-block-line {\n    display: block;\n    line-height: 1.5;\n    padding: 0 16px;\n  }\n\n  .dev-tools-info-code-block-line.dev-tools-info-highlight {\n    border-left: 2px solid var(--color-blue-900);\n    background: var(--color-blue-400);\n  }\n\n  .dev-tools-info-code-block-json-key {\n    color: var(--color-syntax-keyword);\n  }\n\n  .dev-tools-info-code-block-json-value {\n    color: var(--color-syntax-link);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=turbopack-info.js.map
  },
  4257: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DEV_TOOLS_INFO_USER_PREFERENCES_STYLES: function () {
        return DEV_TOOLS_INFO_USER_PREFERENCES_STYLES;
      },
      UserPreferences: function () {
        return UserPreferences;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _tagged_template_literal_loose = __webpack_require__(1637);
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _css = __webpack_require__(6216);
    const _eyeicon = /*#__PURE__*/ _interop_require_default._(__webpack_require__(9269));
    const _shared = __webpack_require__(6172);
    const _lighticon = /*#__PURE__*/ _interop_require_default._(
      __webpack_require__(3436)
    );
    const _darkicon = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8593));
    const _systemicon = /*#__PURE__*/ _interop_require_default._(
      __webpack_require__(809)
    );
    const _devtoolsinfo = __webpack_require__(6462);
    const _preferences = __webpack_require__(8708);
    function _templateObject() {
      const data = _tagged_template_literal_loose._([
        '\n  .preferences-container {\n    padding: 8px 6px;\n    width: 100%;\n  }\n\n  @media (min-width: 576px) {\n    .preferences-container {\n      width: 480px;\n    }\n  }\n\n  .preference-section:first-child {\n    padding-top: 0;\n  }\n\n  .preference-section {\n    padding: 12px 0;\n    border-bottom: 1px solid var(--color-gray-400);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    gap: 24px;\n  }\n\n  .preference-section:last-child {\n    border-bottom: none;\n  }\n\n  .preference-header {\n    margin-bottom: 0;\n    flex: 1;\n  }\n\n  .preference-header label {\n    font-size: var(--size-14);\n    font-weight: 500;\n    color: var(--color-gray-1000);\n    margin: 0;\n  }\n\n  .preference-description {\n    color: var(--color-gray-900);\n    font-size: var(--size-14);\n    margin: 0;\n  }\n\n  .select-button,\n  .action-button {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    background: var(--color-background-100);\n    border: 1px solid var(--color-gray-400);\n    border-radius: var(--rounded-lg);\n    font-weight: 400;\n    font-size: var(--size-14);\n    color: var(--color-gray-1000);\n    padding: 6px 8px;\n\n    &:hover {\n      background: var(--color-gray-100);\n    }\n  }\n\n  .select-button {\n    &:focus-within {\n      outline: var(--focus-ring);\n    }\n\n    select {\n      all: unset;\n    }\n  }\n\n  :global(.icon) {\n    width: 18px;\n    height: 18px;\n    color: #666;\n  }\n',
      ]);
      _templateObject = function () {
        return data;
      };
      return data;
    }
    function UserPreferences(param) {
      let { setPosition, position, hide, scale, setScale, ...props } = param;
      // derive initial theme from system preference
      const [theme, setTheme] = (0, _react.useState)((0, _preferences.getInitialTheme)());
      const handleThemeChange = (e) => {
        const portal = document.querySelector('nextjs-portal');
        if (!portal) return;
        setTheme(e.target.value);
        if (e.target.value === 'system') {
          portal.classList.remove('dark');
          portal.classList.remove('light');
          localStorage.removeItem(_shared.STORAGE_KEY_THEME);
          return;
        }
        if (e.target.value === 'dark') {
          portal.classList.add('dark');
          portal.classList.remove('light');
          localStorage.setItem(_shared.STORAGE_KEY_THEME, 'dark');
        } else {
          portal.classList.remove('dark');
          portal.classList.add('light');
          localStorage.setItem(_shared.STORAGE_KEY_THEME, 'light');
        }
      };
      function handlePositionChange(e) {
        setPosition(e.target.value);
        localStorage.setItem(_shared.STORAGE_KEY_POSITION, e.target.value);
      }
      function handleSizeChange(param) {
        let { target } = param;
        const value = Number(target.value);
        setScale(value);
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_devtoolsinfo.DevToolsInfo, {
        title: 'Preferences',
        ...props,
        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
          className: 'preferences-container',
          children: [
            /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
              className: 'preference-section',
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                  className: 'preference-header',
                  children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('label', {
                      htmlFor: 'theme',
                      children: 'Theme',
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
                      className: 'preference-description',
                      children: 'Select your theme preference.',
                    }),
                  ],
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsxs)(Select, {
                  id: 'theme',
                  name: 'theme',
                  prefix: /*#__PURE__*/ (0, _jsxruntime.jsx)(ThemeIcon, {
                    theme: theme,
                  }),
                  value: theme,
                  onChange: handleThemeChange,
                  children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('option', {
                      value: 'system',
                      children: 'System',
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('option', {
                      value: 'light',
                      children: 'Light',
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('option', {
                      value: 'dark',
                      children: 'Dark',
                    }),
                  ],
                }),
              ],
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
              className: 'preference-section',
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                  className: 'preference-header',
                  children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('label', {
                      htmlFor: 'position',
                      children: 'Position',
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
                      className: 'preference-description',
                      children: 'Adjust the placement of your dev tools.',
                    }),
                  ],
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsxs)(Select, {
                  id: 'position',
                  name: 'position',
                  value: position,
                  onChange: handlePositionChange,
                  children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('option', {
                      value: 'bottom-left',
                      children: 'Bottom Left',
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('option', {
                      value: 'bottom-right',
                      children: 'Bottom Right',
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('option', {
                      value: 'top-left',
                      children: 'Top Left',
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('option', {
                      value: 'top-right',
                      children: 'Top Right',
                    }),
                  ],
                }),
              ],
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
              className: 'preference-section',
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                  className: 'preference-header',
                  children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('label', {
                      htmlFor: 'size',
                      children: 'Size',
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
                      className: 'preference-description',
                      children: 'Adjust the size of your dev tools.',
                    }),
                  ],
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)(Select, {
                  id: 'size',
                  name: 'size',
                  value: scale,
                  onChange: handleSizeChange,
                  children: Object.entries(_preferences.NEXT_DEV_TOOLS_SCALE).map(
                    (param) => {
                      let [key, value] = param;
                      return /*#__PURE__*/ (0, _jsxruntime.jsx)(
                        'option',
                        {
                          value: value,
                          children: key,
                        },
                        key
                      );
                    }
                  ),
                }),
              ],
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
              className: 'preference-section',
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                  className: 'preference-header',
                  children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('label', {
                      id: 'hide-dev-tools',
                      children: 'Hide Dev Tools for this session',
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
                      className: 'preference-description',
                      children:
                        'Hide Dev Tools until you restart your dev server, or 1 day.',
                    }),
                  ],
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                  className: 'preference-control',
                  children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('button', {
                    'aria-describedby': 'hide-dev-tools',
                    name: 'hide-dev-tools',
                    'data-hide-dev-tools': true,
                    className: 'action-button',
                    onClick: hide,
                    children: [
                      /*#__PURE__*/ (0, _jsxruntime.jsx)(_eyeicon.default, {}),
                      /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                        children: 'Hide',
                      }),
                    ],
                  }),
                }),
              ],
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
              className: 'preference-section',
              children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                className: 'preference-header',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('label', {
                    children: 'Disable Dev Tools for this project',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsxs)('p', {
                    className: 'preference-description',
                    children: [
                      'To disable this UI completely, set',
                      ' ',
                      /*#__PURE__*/ (0, _jsxruntime.jsx)('code', {
                        className: 'dev-tools-info-code',
                        children: 'devIndicators: false',
                      }),
                      ' ',
                      'in your ',
                      /*#__PURE__*/ (0, _jsxruntime.jsx)('code', {
                        className: 'dev-tools-info-code',
                        children: 'next.config',
                      }),
                      ' ',
                      'file.',
                    ],
                  }),
                ],
              }),
            }),
          ],
        }),
      });
    }
    function Select(param) {
      let { children, prefix, ...props } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        className: 'select-button',
        children: [
          prefix,
          /*#__PURE__*/ (0, _jsxruntime.jsx)('select', {
            ...props,
            children: children,
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(ChevronDownIcon, {}),
        ],
      });
    }
    function ThemeIcon(param) {
      let { theme } = param;
      switch (theme) {
        case 'system':
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(_systemicon.default, {});
        case 'dark':
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(_darkicon.default, {});
        case 'light':
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(_lighticon.default, {});
        default:
          return null;
      }
    }
    const DEV_TOOLS_INFO_USER_PREFERENCES_STYLES = (0, _css.css)(_templateObject());
    function ChevronDownIcon() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '16',
        height: '16',
        viewBox: '0 0 16 16',
        'aria-hidden': true,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M14.0607 5.49999L13.5303 6.03032L8.7071 10.8535C8.31658 11.2441 7.68341 11.2441 7.29289 10.8535L2.46966 6.03032L1.93933 5.49999L2.99999 4.43933L3.53032 4.96966L7.99999 9.43933L12.4697 4.96966L13 4.43933L14.0607 5.49999Z',
          fill: 'currentColor',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=user-preferences.js.map
  },
  3004: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      Cross: function () {
        return Cross;
      },
      NextLogo: function () {
        return NextLogo;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _tagged_template_literal_loose = __webpack_require__(1637);
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _css = __webpack_require__(6216);
    const _mergerefs = /*#__PURE__*/ _interop_require_default._(
      __webpack_require__(5573)
    );
    const _useminimumloadingtimemultiple = __webpack_require__(5772);
    function _templateObject() {
      const data = _tagged_template_literal_loose._([
        "\n          [data-next-badge-root] {\n            --timing: cubic-bezier(0.23, 0.88, 0.26, 0.92);\n            --duration-long: 250ms;\n            --color-outer-border: #171717;\n            --color-inner-border: hsla(0, 0%, 100%, 0.14);\n            --color-hover-alpha-subtle: hsla(0, 0%, 100%, 0.13);\n            --color-hover-alpha-error: hsla(0, 0%, 100%, 0.2);\n            --color-hover-alpha-error-2: hsla(0, 0%, 100%, 0.25);\n            --mark-size: calc(var(--size) - var(--size-2) * 2);\n\n            --focus-color: var(--color-blue-800);\n            --focus-ring: 2px solid var(--focus-color);\n\n            &:has([data-next-badge][data-error='true']) {\n              --focus-color: #fff;\n            }\n          }\n\n          [data-disabled-icon] {\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            padding-right: 4px;\n          }\n\n          [data-next-badge] {\n            -webkit-font-smoothing: antialiased;\n            width: var(--size);\n            height: var(--size);\n            display: flex;\n            align-items: center;\n            position: relative;\n            background: rgba(0, 0, 0, 0.8);\n            box-shadow:\n              0 0 0 1px var(--color-outer-border),\n              inset 0 0 0 1px var(--color-inner-border),\n              0px 16px 32px -8px rgba(0, 0, 0, 0.24);\n            backdrop-filter: blur(48px);\n            border-radius: var(--rounded-full);\n            user-select: none;\n            cursor: pointer;\n            scale: 1;\n            overflow: hidden;\n            will-change: scale, box-shadow, width, background;\n            transition:\n              scale var(--duration-short) var(--timing),\n              width var(--duration-long) var(--timing),\n              box-shadow var(--duration-long) var(--timing),\n              background var(--duration-short) ease;\n\n            &:active[data-error='false'] {\n              scale: 0.95;\n            }\n\n            &[data-animate='true']:not(:hover) {\n              scale: 1.02;\n            }\n\n            &[data-error='false']:has([data-next-mark]:focus-visible) {\n              outline: var(--focus-ring);\n              outline-offset: 3px;\n            }\n\n            &[data-error='true'] {\n              background: #ca2a30;\n              --color-inner-border: #e5484d;\n\n              [data-next-mark] {\n                background: var(--color-hover-alpha-error);\n                outline-offset: 0px;\n\n                &:focus-visible {\n                  outline: var(--focus-ring);\n                  outline-offset: -1px;\n                }\n\n                &:hover {\n                  background: var(--color-hover-alpha-error-2);\n                }\n              }\n            }\n\n            &[data-error-expanded='false'][data-error='true'] ~ [data-dot] {\n              scale: 1;\n            }\n\n            > div {\n              display: flex;\n            }\n          }\n\n          [data-issues-collapse]:focus-visible {\n            outline: var(--focus-ring);\n          }\n\n          [data-issues]:has([data-issues-open]:focus-visible) {\n            outline: var(--focus-ring);\n            outline-offset: -1px;\n          }\n\n          [data-dot] {\n            content: '';\n            width: var(--size-8);\n            height: var(--size-8);\n            background: #fff;\n            box-shadow: 0 0 0 1px var(--color-outer-border);\n            border-radius: 50%;\n            position: absolute;\n            top: 2px;\n            right: 0px;\n            scale: 0;\n            pointer-events: none;\n            transition: scale 200ms var(--timing);\n            transition-delay: var(--duration-short);\n          }\n\n          [data-issues] {\n            --padding-left: 8px;\n            display: flex;\n            gap: 2px;\n            align-items: center;\n            padding-left: 8px;\n            padding-right: 8px;\n            height: var(--size-32);\n            margin: 0 2px;\n            border-radius: var(--rounded-full);\n            transition: background var(--duration-short) ease;\n\n            &:has([data-issues-open]:hover) {\n              background: var(--color-hover-alpha-error);\n            }\n\n            &:has([data-issues-collapse]) {\n              padding-right: calc(var(--padding-left) / 2);\n            }\n\n            [data-cross] {\n              translate: 0px -1px;\n            }\n          }\n\n          [data-issues-open] {\n            font-size: var(--size-13);\n            color: white;\n            width: fit-content;\n            height: 100%;\n            display: flex;\n            gap: 2px;\n            align-items: center;\n            margin: 0;\n            line-height: var(--size-36);\n            font-weight: 500;\n            z-index: 2;\n            white-space: nowrap;\n\n            &:focus-visible {\n              outline: 0;\n            }\n          }\n\n          [data-issues-collapse] {\n            width: var(--size-24);\n            height: var(--size-24);\n            border-radius: var(--rounded-full);\n            transition: background var(--duration-short) ease;\n\n            &:hover {\n              background: var(--color-hover-alpha-error);\n            }\n          }\n\n          [data-cross] {\n            color: #fff;\n            width: var(--size-12);\n            height: var(--size-12);\n          }\n\n          [data-next-mark] {\n            width: var(--mark-size);\n            height: var(--mark-size);\n            margin-left: 2px;\n            display: flex;\n            align-items: center;\n            border-radius: var(--rounded-full);\n            transition: background var(--duration-long) var(--timing);\n\n            &:focus-visible {\n              outline: 0;\n            }\n\n            &:hover {\n              background: var(--color-hover-alpha-subtle);\n            }\n\n            svg {\n              flex-shrink: 0;\n              width: var(--size-40);\n              height: var(--size-40);\n            }\n          }\n\n          [data-issues-count-animation] {\n            display: grid;\n            place-items: center center;\n            font-variant-numeric: tabular-nums;\n\n            &[data-animate='false'] {\n              [data-issues-count-exit],\n              [data-issues-count-enter] {\n                animation-duration: 0ms;\n              }\n            }\n\n            > * {\n              grid-area: 1 / 1;\n            }\n\n            [data-issues-count-exit] {\n              animation: fadeOut 300ms var(--timing) forwards;\n            }\n\n            [data-issues-count-enter] {\n              animation: fadeIn 300ms var(--timing) forwards;\n            }\n          }\n\n          [data-issues-count-plural] {\n            display: inline-block;\n            &[data-animate='true'] {\n              animation: fadeIn 300ms var(--timing) forwards;\n            }\n          }\n\n          .path0 {\n            animation: draw0 1.5s ease-in-out infinite;\n          }\n\n          .path1 {\n            animation: draw1 1.5s ease-out infinite;\n            animation-delay: 0.3s;\n          }\n\n          .paused {\n            stroke-dashoffset: 0;\n          }\n\n          @keyframes fadeIn {\n            0% {\n              opacity: 0;\n              filter: blur(2px);\n              transform: translateY(8px);\n            }\n            100% {\n              opacity: 1;\n              filter: blur(0px);\n              transform: translateY(0);\n            }\n          }\n\n          @keyframes fadeOut {\n            0% {\n              opacity: 1;\n              filter: blur(0px);\n              transform: translateY(0);\n            }\n            100% {\n              opacity: 0;\n              transform: translateY(-12px);\n              filter: blur(2px);\n            }\n          }\n\n          @keyframes draw0 {\n            0%,\n            25% {\n              stroke-dashoffset: -29.6;\n            }\n            25%,\n            50% {\n              stroke-dashoffset: 0;\n            }\n            50%,\n            75% {\n              stroke-dashoffset: 0;\n            }\n            75%,\n            100% {\n              stroke-dashoffset: 29.6;\n            }\n          }\n\n          @keyframes draw1 {\n            0%,\n            20% {\n              stroke-dashoffset: -11.6;\n            }\n            20%,\n            50% {\n              stroke-dashoffset: 0;\n            }\n            50%,\n            75% {\n              stroke-dashoffset: 0;\n            }\n            75%,\n            100% {\n              stroke-dashoffset: 11.6;\n            }\n          }\n\n          @media (prefers-reduced-motion) {\n            [data-issues-count-exit],\n            [data-issues-count-enter],\n            [data-issues-count-plural] {\n              animation-duration: 0ms !important;\n            }\n          }\n        ",
      ]);
      _templateObject = function () {
        return data;
      };
      return data;
    }
    const SHORT_DURATION_MS = 150;
    const NextLogo = /*#__PURE__*/ (0, _react.forwardRef)(
      function NextLogo(param, propRef) {
        let {
          disabled,
          issueCount,
          isDevBuilding,
          isDevRendering,
          isBuildError,
          onTriggerClick,
          toggleErrorOverlay,
          scale = 1,
          ...props
        } = param;
        const SIZE = 36 / scale;
        const hasError = issueCount > 0;
        const [isErrorExpanded, setIsErrorExpanded] = (0, _react.useState)(hasError);
        const [dismissed, setDismissed] = (0, _react.useState)(false);
        const newErrorDetected = useUpdateAnimation(issueCount, SHORT_DURATION_MS);
        const triggerRef = (0, _react.useRef)(null);
        const ref = (0, _react.useRef)(null);
        const [measuredWidth, pristine] = useMeasureWidth(ref);
        const isLoading = (0,
        _useminimumloadingtimemultiple.useMinimumLoadingTimeMultiple)(
          isDevBuilding || isDevRendering
        );
        const isExpanded = isErrorExpanded || disabled;
        const style = (0, _react.useMemo)(() => {
          let width = SIZE;
          // Animates the badge, if expanded
          if (measuredWidth > SIZE) width = measuredWidth;
          // No animations on page load, assume the intrinsic width immediately
          if (pristine && hasError) width = 'auto';
          // Default state, collapsed
          return {
            width,
          };
        }, [measuredWidth, pristine, hasError, SIZE]);
        (0, _react.useEffect)(() => {
          setIsErrorExpanded(hasError);
        }, [hasError]);
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
          'data-next-badge-root': true,
          style: {
            '--size': '' + SIZE + 'px',
            '--duration-short': '' + SHORT_DURATION_MS + 'ms',
            // if the indicator is disabled, hide the badge
            // also allow the "disabled" state be dismissed, as long as there are no build errors
            display: disabled && (!hasError || dismissed) ? 'none' : 'block',
          },
          children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)('style', {
              children: (0, _css.css)(_templateObject()),
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
              'data-next-badge': true,
              'data-error': hasError,
              'data-error-expanded': isExpanded,
              'data-animate': newErrorDetected,
              style: style,
              children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                ref: ref,
                children: [
                  !disabled &&
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
                      ref: (0, _mergerefs.default)(triggerRef, propRef),
                      'data-next-mark': true,
                      'data-next-mark-loading': isLoading,
                      onClick: onTriggerClick,
                      ...props,
                      children: /*#__PURE__*/ (0, _jsxruntime.jsx)(NextMark, {
                        isLoading: isLoading,
                        isDevBuilding: isDevBuilding,
                      }),
                    }),
                  isExpanded &&
                    /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                      'data-issues': true,
                      children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsxs)('button', {
                          'data-issues-open': true,
                          'aria-label': 'Open issues overlay',
                          onClick: toggleErrorOverlay,
                          children: [
                            disabled &&
                              /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                                'data-disabled-icon': true,
                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Warning, {}),
                              }),
                            /*#__PURE__*/ (0, _jsxruntime.jsx)(
                              AnimateCount,
                              {
                                animate: newErrorDetected,
                                'data-issues-count-animation': true,
                                children: issueCount,
                              },
                              issueCount
                            ),
                            ' ',
                            /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                              children: [
                                'Issue',
                                issueCount > 1 &&
                                  /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                                    'aria-hidden': true,
                                    'data-issues-count-plural': true,
                                    // This only needs to animate once the count changes from 1 -> 2,
                                    // otherwise it should stay static between re-renders.
                                    'data-animate': newErrorDetected && issueCount === 2,
                                    children: 's',
                                  }),
                              ],
                            }),
                          ],
                        }),
                        !isBuildError &&
                          /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
                            'data-issues-collapse': true,
                            'aria-label': 'Collapse issues badge',
                            onClick: () => {
                              var _triggerRef_current;
                              if (disabled) {
                                setDismissed(true);
                              } else {
                                setIsErrorExpanded(false);
                              }
                              (_triggerRef_current = triggerRef.current) == null
                                ? void 0
                                : _triggerRef_current.focus();
                            },
                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Cross, {
                              'data-cross': true,
                            }),
                          }),
                      ],
                    }),
                ],
              }),
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
              'aria-hidden': true,
              'data-dot': true,
            }),
          ],
        });
      }
    );
    function AnimateCount(param) {
      let { children: count, animate = true, ...props } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        ...props,
        'data-animate': animate,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
            'aria-hidden': true,
            'data-issues-count-exit': true,
            children: count - 1,
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
            'data-issues-count': true,
            'data-issues-count-enter': true,
            children: count,
          }),
        ],
      });
    }
    function useMeasureWidth(ref) {
      const [width, setWidth] = (0, _react.useState)(0);
      const [pristine, setPristine] = (0, _react.useState)(true);
      (0, _react.useEffect)(() => {
        const el = ref.current;
        if (!el) {
          return;
        }
        const observer = new ResizeObserver(() => {
          const { width: w } = el.getBoundingClientRect();
          setWidth((prevWidth) => {
            if (prevWidth !== 0) {
              setPristine(false);
            }
            return w;
          });
        });
        observer.observe(el);
        return () => observer.disconnect();
      }, [ref]);
      return [width, pristine];
    }
    function useUpdateAnimation(issueCount, animationDurationMs) {
      if (animationDurationMs === void 0) animationDurationMs = 0;
      const lastUpdatedTimeStamp = (0, _react.useRef)(null);
      const [animate, setAnimate] = (0, _react.useState)(false);
      (0, _react.useEffect)(() => {
        if (issueCount > 0) {
          const deltaMs = lastUpdatedTimeStamp.current
            ? Date.now() - lastUpdatedTimeStamp.current
            : -1;
          lastUpdatedTimeStamp.current = Date.now();
          // We don't animate if `issueCount` changes too quickly
          if (deltaMs <= animationDurationMs) {
            return;
          }
          setAnimate(true);
          // It is important to use a CSS transitioned state, not a CSS keyframed animation
          // because if the issue count increases faster than the animation duration, it
          // will abruptly stop and not transition smoothly back to its original state.
          const timeoutId = window.setTimeout(() => {
            setAnimate(false);
          }, animationDurationMs);
          return () => {
            clearTimeout(timeoutId);
          };
        }
      }, [issueCount, animationDurationMs]);
      return animate;
    }
    function NextMark(param) {
      let { isLoading, isDevBuilding } = param;
      const strokeColor = isDevBuilding ? 'rgba(255,255,255,0.7)' : 'white';
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('svg', {
        width: '40',
        height: '40',
        viewBox: '0 0 40 40',
        fill: 'none',
        'data-next-mark-loading': isLoading,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('g', {
            transform: 'translate(8.5, 13)',
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                className: isLoading ? 'path0' : 'paused',
                d: 'M13.3 15.2 L2.34 1 V12.6',
                fill: 'none',
                stroke: 'url(#next_logo_paint0_linear_1357_10853)',
                strokeWidth: '1.86',
                mask: 'url(#next_logo_mask0)',
                strokeDasharray: '29.6',
                strokeDashoffset: '29.6',
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                className: isLoading ? 'path1' : 'paused',
                d: 'M11.825 1.5 V13.1',
                strokeWidth: '1.86',
                stroke: 'url(#next_logo_paint1_linear_1357_10853)',
                strokeDasharray: '11.6',
                strokeDashoffset: '11.6',
              }),
            ],
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('defs', {
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('linearGradient', {
                id: 'next_logo_paint0_linear_1357_10853',
                x1: '9.95555',
                y1: '11.1226',
                x2: '15.4778',
                y2: '17.9671',
                gradientUnits: 'userSpaceOnUse',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    stopColor: strokeColor,
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '0.604072',
                    stopColor: strokeColor,
                    stopOpacity: '0',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '1',
                    stopColor: strokeColor,
                    stopOpacity: '0',
                  }),
                ],
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('linearGradient', {
                id: 'next_logo_paint1_linear_1357_10853',
                x1: '11.8222',
                y1: '1.40039',
                x2: '11.791',
                y2: '9.62542',
                gradientUnits: 'userSpaceOnUse',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    stopColor: strokeColor,
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '1',
                    stopColor: strokeColor,
                    stopOpacity: '0',
                  }),
                ],
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('mask', {
                id: 'next_logo_mask0',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('rect', {
                    width: '100%',
                    height: '100%',
                    fill: 'white',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('rect', {
                    width: '5',
                    height: '1.5',
                    fill: 'black',
                  }),
                ],
              }),
            ],
          }),
        ],
      });
    }
    function Warning() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '12',
        height: '12',
        viewBox: '0 0 12 12',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M3.98071 1.125L1.125 3.98071L1.125 8.01929L3.98071 10.875H8.01929L10.875 8.01929V3.98071L8.01929 1.125H3.98071ZM3.82538 0C3.62647 0 3.4357 0.0790176 3.29505 0.21967L0.21967 3.29505C0.0790176 3.4357 0 3.62647 0 3.82538V8.17462C0 8.37353 0.0790178 8.5643 0.21967 8.70495L3.29505 11.7803C3.4357 11.921 3.62647 12 3.82538 12H8.17462C8.37353 12 8.5643 11.921 8.70495 11.7803L11.7803 8.70495C11.921 8.5643 12 8.37353 12 8.17462V3.82538C12 3.62647 11.921 3.4357 11.7803 3.29505L8.70495 0.21967C8.5643 0.0790177 8.37353 0 8.17462 0H3.82538ZM6.5625 2.8125V3.375V6V6.5625H5.4375V6V3.375V2.8125H6.5625ZM6 9C6.41421 9 6.75 8.66421 6.75 8.25C6.75 7.83579 6.41421 7.5 6 7.5C5.58579 7.5 5.25 7.83579 5.25 8.25C5.25 8.66421 5.58579 9 6 9Z',
          fill: '#EAEAEA',
        }),
      });
    }
    function Cross(props) {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '12',
        height: '12',
        viewBox: '0 0 14 14',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        ...props,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M3.08889 11.8384L2.62486 12.3024L1.69678 11.3744L2.16082 10.9103L6.07178 6.99937L2.16082 3.08841L1.69678 2.62437L2.62486 1.69629L3.08889 2.16033L6.99986 6.07129L10.9108 2.16033L11.3749 1.69629L12.3029 2.62437L11.8389 3.08841L7.92793 6.99937L11.8389 10.9103L12.3029 11.3744L11.3749 12.3024L10.9108 11.8384L6.99986 7.92744L3.08889 11.8384Z',
          fill: 'currentColor',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=next-logo.js.map
  },
  5772: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'useMinimumLoadingTimeMultiple', {
      enumerable: true,
      get: function () {
        return useMinimumLoadingTimeMultiple;
      },
    });
    const _react = __webpack_require__(863);
    function useMinimumLoadingTimeMultiple(isLoadingTrigger, interval) {
      if (interval === void 0) interval = 750;
      const [isLoading, setIsLoading] = (0, _react.useState)(false);
      const loadStartTimeRef = (0, _react.useRef)(null);
      const timeoutIdRef = (0, _react.useRef)(null);
      (0, _react.useEffect)(() => {
        // Clear any pending timeout to avoid overlap
        if (timeoutIdRef.current) {
          clearTimeout(timeoutIdRef.current);
          timeoutIdRef.current = null;
        }
        if (isLoadingTrigger) {
          // If we enter "loading" state, record start time if not already
          if (loadStartTimeRef.current === null) {
            loadStartTimeRef.current = Date.now();
          }
          setIsLoading(true);
        } else {
          // If we're exiting the "loading" state:
          if (loadStartTimeRef.current === null) {
            // No start time was recorded, so just stop loading immediately
            setIsLoading(false);
          } else {
            // How long we've been "loading"
            const timeDiff = Date.now() - loadStartTimeRef.current;
            // Next multiple of `interval` after `timeDiff`
            const nextMultiple = interval * Math.ceil(timeDiff / interval);
            // Remaining time needed to reach that multiple
            const remainingTime = nextMultiple - timeDiff;
            if (remainingTime > 0) {
              // If not yet at that multiple, schedule the final step
              timeoutIdRef.current = setTimeout(() => {
                setIsLoading(false);
                loadStartTimeRef.current = null;
              }, remainingTime);
            } else {
              // We're already past the multiple boundary
              setIsLoading(false);
              loadStartTimeRef.current = null;
            }
          }
        }
        // Cleanup when effect is about to re-run or component unmounts
        return () => {
          if (timeoutIdRef.current) {
            clearTimeout(timeoutIdRef.current);
          }
        };
      }, [isLoadingTrigger, interval]);
      return isLoading;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=use-minimum-loading-time-multiple.js.map
  },
  9949: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      MENU_CURVE: function () {
        return MENU_CURVE;
      },
      MENU_DURATION_MS: function () {
        return MENU_DURATION_MS;
      },
      useClickOutside: function () {
        return useClickOutside;
      },
      useFocusTrap: function () {
        return useFocusTrap;
      },
    });
    const _react = __webpack_require__(863);
    function useFocusTrap(rootRef, triggerRef, active, onOpenFocus) {
      (0, _react.useEffect)(() => {
        let rootNode = null;
        function onTab(e) {
          if (e.key !== 'Tab' || rootNode === null) {
            return;
          }
          const [firstFocusableNode, lastFocusableNode] = getFocusableNodes(rootNode);
          const activeElement = getActiveElement(rootNode);
          if (e.shiftKey) {
            if (activeElement === firstFocusableNode) {
              lastFocusableNode == null ? void 0 : lastFocusableNode.focus();
              e.preventDefault();
            }
          } else {
            if (activeElement === lastFocusableNode) {
              firstFocusableNode == null ? void 0 : firstFocusableNode.focus();
              e.preventDefault();
            }
          }
        }
        const id = setTimeout(() => {
          // Grab this on next tick to ensure the content is mounted
          rootNode = rootRef.current;
          if (active) {
            if (onOpenFocus) {
              onOpenFocus();
            } else {
              rootNode == null ? void 0 : rootNode.focus();
            }
            rootNode == null ? void 0 : rootNode.addEventListener('keydown', onTab);
          } else {
            const activeElement = getActiveElement(rootNode);
            // Only restore focus if the focus was previously on the content.
            // This avoids us accidentally focusing on mount when the
            // user could want to interact with their own app instead.
            if (
              triggerRef &&
              (rootNode == null ? void 0 : rootNode.contains(activeElement))
            ) {
              var _triggerRef_current;
              (_triggerRef_current = triggerRef.current) == null
                ? void 0
                : _triggerRef_current.focus();
            }
          }
        });
        return () => {
          clearTimeout(id);
          rootNode == null ? void 0 : rootNode.removeEventListener('keydown', onTab);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [active]);
    }
    function getActiveElement(node) {
      const root = node == null ? void 0 : node.getRootNode();
      return root instanceof ShadowRoot
        ? root == null
          ? void 0
          : root.activeElement
        : null;
    }
    function getFocusableNodes(node) {
      const focusableElements = node.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      if (!focusableElements) return [];
      return [focusableElements[0], focusableElements[focusableElements.length - 1]];
    }
    function useClickOutside(rootRef, triggerRef, active, close) {
      (0, _react.useEffect)(() => {
        if (!active) {
          return;
        }
        function handleClickOutside(event) {
          var _rootRef_current, _triggerRef_current;
          if (
            !((
              (_rootRef_current = rootRef.current) == null
                ? void 0
                : _rootRef_current.getBoundingClientRect()
            )
              ? event.clientX >= rootRef.current.getBoundingClientRect().left &&
                event.clientX <= rootRef.current.getBoundingClientRect().right &&
                event.clientY >= rootRef.current.getBoundingClientRect().top &&
                event.clientY <= rootRef.current.getBoundingClientRect().bottom
              : false) &&
            !((
              (_triggerRef_current = triggerRef.current) == null
                ? void 0
                : _triggerRef_current.getBoundingClientRect()
            )
              ? event.clientX >= triggerRef.current.getBoundingClientRect().left &&
                event.clientX <= triggerRef.current.getBoundingClientRect().right &&
                event.clientY >= triggerRef.current.getBoundingClientRect().top &&
                event.clientY <= triggerRef.current.getBoundingClientRect().bottom
              : false)
          ) {
            close();
          }
        }
        function handleKeyDown(event) {
          if (event.key === 'Escape') {
            close();
          }
        }
        document.addEventListener('mousedown', handleClickOutside);
        document.addEventListener('keydown', handleKeyDown);
        return () => {
          document.removeEventListener('mousedown', handleClickOutside);
          document.removeEventListener('keydown', handleKeyDown);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [active]);
    }
    const MENU_DURATION_MS = 200;
    const MENU_CURVE = 'cubic-bezier(0.175, 0.885, 0.32, 1.1)';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=utils.js.map
  },
  8902: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DIALOG_BODY_STYLES: function () {
        return DIALOG_BODY_STYLES;
      },
      ErrorOverlayDialogBody: function () {
        return ErrorOverlayDialogBody;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _dialog = __webpack_require__(7074);
    function ErrorOverlayDialogBody(param) {
      let { children } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_dialog.DialogBody, {
        className: 'nextjs-container-errors-body',
        children: children,
      });
    }
    const DIALOG_BODY_STYLES = '';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=body.js.map
  },
  5993: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DIALOG_STYLES: function () {
        return DIALOG_STYLES;
      },
      ErrorOverlayDialog: function () {
        return ErrorOverlayDialog;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _dialog = __webpack_require__(8867);
    function ErrorOverlayDialog(param) {
      let { children, onClose, footer, ...props } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        className: 'error-overlay-dialog-container',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_dialog.Dialog, {
            type: 'error',
            'aria-labelledby': 'nextjs__container_errors_label',
            'aria-describedby': 'nextjs__container_errors_desc',
            className: 'error-overlay-dialog-scroll',
            onClose: onClose,
            ...props,
            children: children,
          }),
          footer,
        ],
      });
    }
    const DIALOG_STYLES =
      '\n  .error-overlay-dialog-container {\n    -webkit-font-smoothing: antialiased;\n    display: flex;\n    flex-direction: column;\n    background: var(--color-background-100);\n    background-clip: padding-box;\n    border: var(--next-dialog-border-width) solid var(--color-gray-400);\n    border-radius: 0 0 var(--next-dialog-radius) var(--next-dialog-radius);\n    box-shadow: var(--shadow-menu);\n    position: relative;\n    overflow: hidden;\n  }\n\n  .error-overlay-dialog-scroll {\n    overflow-y: auto;\n    height: 100%;\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dialog.js.map
  },
  7051: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DIALOG_HEADER_STYLES: function () {
        return DIALOG_HEADER_STYLES;
      },
      ErrorOverlayDialogHeader: function () {
        return ErrorOverlayDialogHeader;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _dialogheader = __webpack_require__(3259);
    function ErrorOverlayDialogHeader(param) {
      let { children } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_dialogheader.DialogHeader, {
        className: 'nextjs-container-errors-header',
        children: children,
      });
    }
    const DIALOG_HEADER_STYLES =
      '\n  .nextjs-container-errors-header {\n    position: relative;\n  }\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-20);\n    line-height: var(--size-24);\n    font-weight: bold;\n    margin: calc(16px * 1.5) 0;\n    color: var(--color-title-h1);\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-14);\n    color: var(--color-accents-1);\n    margin-left: 16px;\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: 4px;\n  }\n  .nextjs-container-errors-header > p > a {\n    color: inherit;\n    font-weight: bold;\n  }\n  .nextjs-container-errors-header\n    > .nextjs-container-build-error-version-status {\n    position: absolute;\n    top: 16px;\n    right: 16px;\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=header.js.map
  },
  5040: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ENVIRONMENT_NAME_LABEL_STYLES: function () {
        return ENVIRONMENT_NAME_LABEL_STYLES;
      },
      EnvironmentNameLabel: function () {
        return EnvironmentNameLabel;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function EnvironmentNameLabel(param) {
      let { environmentName } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
        'data-nextjs-environment-name-label': true,
        children: environmentName,
      });
    }
    const ENVIRONMENT_NAME_LABEL_STYLES =
      '\n  [data-nextjs-environment-name-label] {\n    padding: 2px 6px;\n    margin: 0;\n    border-radius: var(--rounded-md-2);\n    background: var(--color-gray-100);\n    font-weight: 600;\n    font-size: var(--size-12);\n    color: var(--color-gray-900);\n    font-family: var(--font-stack-monospace);\n    line-height: var(--size-20);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=environment-name-label.js.map
  },
  5342: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorMessage: function () {
        return ErrorMessage;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    function ErrorMessage(param) {
      let { errorMessage } = param;
      const [isExpanded, setIsExpanded] = (0, _react.useState)(false);
      const [shouldTruncate, setShouldTruncate] = (0, _react.useState)(false);
      const messageRef = (0, _react.useRef)(null);
      (0, _react.useLayoutEffect)(() => {
        if (messageRef.current) {
          setShouldTruncate(messageRef.current.scrollHeight > 200);
        }
      }, [errorMessage]);
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        className: 'nextjs__container_errors_wrapper',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
            ref: messageRef,
            id: 'nextjs__container_errors_desc',
            className:
              'nextjs__container_errors_desc ' +
              (shouldTruncate && !isExpanded ? 'truncated' : ''),
            children: errorMessage,
          }),
          shouldTruncate &&
            !isExpanded &&
            /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                  className: 'nextjs__container_errors_gradient_overlay',
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
                  onClick: () => setIsExpanded(true),
                  className: 'nextjs__container_errors_expand_button',
                  'aria-expanded': isExpanded,
                  'aria-controls': 'nextjs__container_errors_desc',
                  children: 'Show More',
                }),
              ],
            }),
        ],
      });
    }
    const styles =
      '\n  .nextjs__container_errors_wrapper {\n    position: relative;\n  }\n\n  .nextjs__container_errors_desc {\n    margin: 0;\n    margin-left: 4px;\n    color: var(--color-red-900);\n    font-weight: 500;\n    font-size: var(--size-16);\n    letter-spacing: -0.32px;\n    line-height: var(--size-24);\n    overflow-wrap: break-word;\n    white-space: pre-wrap;\n  }\n\n  .nextjs__container_errors_desc.truncated {\n    max-height: 200px;\n    overflow: hidden;\n  }\n\n  .nextjs__container_errors_gradient_overlay {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    height: 85px;\n    background: linear-gradient(\n      180deg,\n      rgba(250, 250, 250, 0) 0%,\n      var(--color-background-100) 100%\n    );\n  }\n\n  .nextjs__container_errors_expand_button {\n    position: absolute;\n    bottom: 10px;\n    left: 50%;\n    transform: translateX(-50%);\n    display: flex;\n    align-items: center;\n    padding: 6px 8px;\n    background: var(--color-background-100);\n    border: 1px solid var(--color-gray-alpha-400);\n    border-radius: 999px;\n    box-shadow:\n      0px 2px 2px var(--color-gray-alpha-100),\n      0px 8px 8px -8px var(--color-gray-alpha-100);\n    font-size: var(--size-13);\n    cursor: pointer;\n    color: var(--color-gray-900);\n    font-weight: 500;\n    transition: background-color 0.2s ease;\n  }\n\n  .nextjs__container_errors_expand_button:hover {\n    background: var(--color-gray-100);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-message.js.map
  },
  8976: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorOverlayBottomStack: function () {
        return ErrorOverlayBottomStack;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function ErrorOverlayBottomStack(param) {
      let { errorCount, activeIdx } = param;
      // If there are more than 2 errors to navigate, the stack count should remain at 2.
      const stackCount = Math.min(errorCount - activeIdx - 1, 2);
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
        'aria-hidden': true,
        className: 'error-overlay-bottom-stack',
        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
          className: 'error-overlay-bottom-stack-stack',
          'data-stack-count': stackCount,
          children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
              className:
                'error-overlay-bottom-stack-layer error-overlay-bottom-stack-layer-1',
              children: '1',
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
              className:
                'error-overlay-bottom-stack-layer error-overlay-bottom-stack-layer-2',
              children: '2',
            }),
          ],
        }),
      });
    }
    const styles =
      "\n  .error-overlay-bottom-stack-layer {\n    width: 100%;\n    height: var(--stack-layer-height);\n    position: relative;\n    border: 1px solid var(--color-gray-400);\n    border-radius: var(--rounded-xl);\n    background: var(--color-background-200);\n    transition:\n      translate 350ms var(--timing-swift),\n      box-shadow 350ms var(--timing-swift);\n  }\n\n  .error-overlay-bottom-stack-layer-1 {\n    width: calc(100% - var(--size-24));\n  }\n\n  .error-overlay-bottom-stack-layer-2 {\n    width: calc(100% - var(--size-48));\n    z-index: -1;\n  }\n\n  .error-overlay-bottom-stack {\n    width: 100%;\n    position: absolute;\n    bottom: -1px;\n    height: 0;\n    overflow: visible;\n  }\n\n  .error-overlay-bottom-stack-stack {\n    --stack-layer-height: 44px;\n    --stack-layer-height-half: calc(var(--stack-layer-height) / 2);\n    --stack-layer-trim: 13px;\n    --shadow: 0px 0.925px 0.925px 0px rgba(0, 0, 0, 0.02),\n      0px 3.7px 7.4px -3.7px rgba(0, 0, 0, 0.04),\n      0px 14.8px 22.2px -7.4px rgba(0, 0, 0, 0.06);\n\n    display: grid;\n    place-items: center center;\n    width: 100%;\n    position: fixed;\n    overflow: hidden;\n    z-index: -1;\n    max-width: var(--next-dialog-max-width);\n\n    .error-overlay-bottom-stack-layer {\n      grid-area: 1 / 1;\n      /* Hide */\n      translate: 0 calc(var(--stack-layer-height) * -1);\n    }\n\n    &[data-stack-count='1'],\n    &[data-stack-count='2'] {\n      .error-overlay-bottom-stack-layer-1 {\n        translate: 0\n          calc(var(--stack-layer-height-half) * -1 - var(--stack-layer-trim));\n      }\n    }\n\n    &[data-stack-count='2'] {\n      .error-overlay-bottom-stack-layer-2 {\n        translate: 0 calc(var(--stack-layer-trim) * -1 * 2);\n      }\n    }\n\n    /* Only the bottom stack should have the shadow */\n    &[data-stack-count='1'] .error-overlay-bottom-stack-layer-1 {\n      box-shadow: var(--shadow);\n    }\n\n    &[data-stack-count='2'] {\n      .error-overlay-bottom-stack-layer-2 {\n        box-shadow: var(--shadow);\n      }\n    }\n  }\n";
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=index.js.map
  },
  6093: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorFeedback: function () {
        return ErrorFeedback;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _thumbsup = __webpack_require__(6058);
    const _thumbsdown = __webpack_require__(9415);
    const _cx = __webpack_require__(6160);
    function ErrorFeedback(param) {
      let { errorCode, className } = param;
      const [votedMap, setVotedMap] = (0, _react.useState)({});
      const voted = votedMap[errorCode];
      const hasVoted = voted !== undefined;
      const disabled = false;
      const handleFeedback = (0, _react.useCallback)(
        async (wasHelpful) => {
          // Optimistically set feedback state without loading/error states to keep implementation simple
          setVotedMap((prev) => ({
            ...prev,
            [errorCode]: wasHelpful,
          }));
          try {
            const response = await fetch(
              (false || '') +
                '/__nextjs_error_feedback?' +
                new URLSearchParams({
                  errorCode,
                  wasHelpful: wasHelpful.toString(),
                })
            );
            if (!response.ok) {
              // Handle non-2xx HTTP responses here if needed
              console.error('Failed to record feedback on the server.');
            }
          } catch (error) {
            console.error('Failed to record feedback:', error);
          }
        },
        [errorCode]
      );
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
        className: (0, _cx.cx)('error-feedback', className),
        role: 'region',
        'aria-label': 'Error feedback',
        children: hasVoted
          ? /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
              className: 'error-feedback-thanks',
              role: 'status',
              'aria-live': 'polite',
              children: 'Thanks for your feedback!',
            })
          : /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
                  children: /*#__PURE__*/ (0, _jsxruntime.jsx)('a', {
                    href: 'https://nextjs.org/telemetry#error-feedback',
                    rel: 'noopener noreferrer',
                    target: '_blank',
                    children: 'Was this helpful?',
                  }),
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
                  'aria-disabled': disabled ? 'true' : undefined,
                  'aria-label': 'Mark as helpful',
                  onClick: disabled ? undefined : () => handleFeedback(true),
                  className: (0, _cx.cx)('feedback-button', voted === true && 'voted'),
                  title: disabled
                    ? 'Feedback disabled due to setting NEXT_TELEMETRY_DISABLED'
                    : undefined,
                  type: 'button',
                  children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_thumbsup.ThumbsUp, {
                    'aria-hidden': 'true',
                  }),
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
                  'aria-disabled': disabled ? 'true' : undefined,
                  'aria-label': 'Mark as not helpful',
                  onClick: disabled ? undefined : () => handleFeedback(false),
                  className: (0, _cx.cx)('feedback-button', voted === false && 'voted'),
                  title: disabled
                    ? 'Feedback disabled due to setting NEXT_TELEMETRY_DISABLED'
                    : undefined,
                  type: 'button',
                  children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_thumbsdown.ThumbsDown, {
                    'aria-hidden': 'true',
                    // Optical alignment
                    style: {
                      translate: '1px 1px',
                    },
                  }),
                }),
              ],
            }),
      });
    }
    const styles =
      "\n  .error-feedback {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    white-space: nowrap;\n    color: var(--color-gray-900);\n  }\n\n  .error-feedback-thanks {\n    height: var(--size-24);\n    display: flex;\n    align-items: center;\n    padding-right: 4px; /* To match the 4px inner padding of the thumbs up and down icons */\n  }\n\n  .feedback-button {\n    background: none;\n    border: none;\n    border-radius: var(--rounded-md);\n    width: var(--size-24);\n    height: var(--size-24);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n\n    &:focus {\n      outline: var(--focus-ring);\n    }\n\n    &:hover {\n      background: var(--color-gray-alpha-100);\n    }\n\n    &:active {\n      background: var(--color-gray-alpha-200);\n    }\n  }\n\n  .feedback-button[aria-disabled='true'] {\n    opacity: 0.7;\n    cursor: not-allowed;\n  }\n\n  .feedback-button.voted {\n    background: var(--color-gray-alpha-200);\n  }\n\n  .thumbs-up-icon,\n  .thumbs-down-icon {\n    color: var(--color-gray-900);\n    width: var(--size-16);\n    height: var(--size-16);\n  }\n";
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-feedback.js.map
  },
  4309: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorOverlayFooter: function () {
        return ErrorOverlayFooter;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _errorfeedback = __webpack_require__(6093);
    function ErrorOverlayFooter(param) {
      let { errorCode, footerMessage } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('footer', {
        className: 'error-overlay-footer',
        children: [
          footerMessage
            ? /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
                className: 'error-overlay-footer-message',
                children: footerMessage,
              })
            : null,
          errorCode
            ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorfeedback.ErrorFeedback, {
                className: 'error-feedback',
                errorCode: errorCode,
              })
            : null,
        ],
      });
    }
    const styles =
      '\n  .error-overlay-footer {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n\n    gap: 8px;\n    padding: 12px;\n    background: var(--color-background-200);\n    border-top: 1px solid var(--color-gray-400);\n  }\n\n  .error-feedback {\n    margin-left: auto;\n\n    p {\n      font-size: var(--size-14);\n      font-weight: 500;\n      margin: 0;\n    }\n  }\n\n  .error-overlay-footer-message {\n    color: var(--color-gray-900);\n    margin: 0;\n    font-size: var(--size-14);\n    font-weight: 400;\n    line-height: var(--size-20);\n  }\n\n  ' +
      _errorfeedback.styles +
      '\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-overlay-footer.js.map
  },
  3060: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorOverlayLayout: function () {
        return ErrorOverlayLayout;
      },
      styles: function () {
        return styles;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _dialog = __webpack_require__(7074);
    const _erroroverlaytoolbar = __webpack_require__(7717);
    const _erroroverlayfooter = __webpack_require__(4309);
    const _errormessage = __webpack_require__(5342);
    const _errortypelabel = __webpack_require__(65);
    const _erroroverlaynav = __webpack_require__(8812);
    const _dialog1 = __webpack_require__(5993);
    const _header = __webpack_require__(7051);
    const _body = __webpack_require__(8902);
    const _callstack = __webpack_require__(3498);
    const _overlay = __webpack_require__(988);
    const _erroroverlaybottomstack = __webpack_require__(8976);
    const _environmentnamelabel = __webpack_require__(5040);
    const _utils = __webpack_require__(9949);
    const _fader = __webpack_require__(3289);
    function ErrorOverlayLayout(param) {
      let {
        errorMessage,
        errorType,
        children,
        errorCode,
        error,
        debugInfo,
        isBuildError,
        onClose,
        versionInfo,
        runtimeErrors,
        activeIdx,
        setActiveIndex,
        footerMessage,
        isTurbopack,
        dialogResizerRef, // If it's not being passed, we should just render the component as it is being
        // used without the context of a parent component that controls its state (e.g. Storybook).
        rendered = true,
        transitionDurationMs,
      } = param;
      const animationProps = {
        'data-rendered': rendered,
        style: {
          '--transition-duration': '' + transitionDurationMs + 'ms',
        },
      };
      const faderRef = _react.useRef(null);
      const hasFooter = Boolean(footerMessage || errorCode);
      const dialogRef = _react.useRef(null);
      (0, _utils.useFocusTrap)(dialogRef, null, rendered);
      function onScroll(e) {
        if (faderRef.current) {
          const opacity = clamp(e.currentTarget.scrollTop / 17, [0, 1]);
          faderRef.current.style.opacity = String(opacity);
        }
      }
      var _runtimeErrors_length;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_overlay.ErrorOverlayOverlay, {
        fixed: isBuildError,
        ...animationProps,
        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
          'data-nextjs-dialog-root': true,
          ref: dialogRef,
          ...animationProps,
          children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_erroroverlaynav.ErrorOverlayNav, {
              runtimeErrors: runtimeErrors,
              activeIdx: activeIdx,
              setActiveIndex: setActiveIndex,
              versionInfo: versionInfo,
              isTurbopack: isTurbopack,
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsxs)(_dialog1.ErrorOverlayDialog, {
              onClose: onClose,
              dialogResizerRef: dialogResizerRef,
              'data-has-footer': hasFooter,
              onScroll: onScroll,
              footer:
                hasFooter &&
                /*#__PURE__*/ (0, _jsxruntime.jsx)(
                  _erroroverlayfooter.ErrorOverlayFooter,
                  {
                    footerMessage: footerMessage,
                    errorCode: errorCode,
                  }
                ),
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsxs)(_dialog.DialogContent, {
                  children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsxs)(
                      _header.ErrorOverlayDialogHeader,
                      {
                        children: [
                          /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
                            className: 'nextjs__container_errors__error_title',
                            // allow assertion in tests before error rating is implemented
                            'data-nextjs-error-code': errorCode,
                            children: [
                              /*#__PURE__*/ (0, _jsxruntime.jsxs)('span', {
                                'data-nextjs-error-label-group': true,
                                children: [
                                  /*#__PURE__*/ (0, _jsxruntime.jsx)(
                                    _errortypelabel.ErrorTypeLabel,
                                    {
                                      errorType: errorType,
                                    }
                                  ),
                                  error.environmentName &&
                                    /*#__PURE__*/ (0, _jsxruntime.jsx)(
                                      _environmentnamelabel.EnvironmentNameLabel,
                                      {
                                        environmentName: error.environmentName,
                                      }
                                    ),
                                ],
                              }),
                              /*#__PURE__*/ (0, _jsxruntime.jsx)(
                                _erroroverlaytoolbar.ErrorOverlayToolbar,
                                {
                                  error: error,
                                  debugInfo: debugInfo,
                                }
                              ),
                            ],
                          }),
                          /*#__PURE__*/ (0, _jsxruntime.jsx)(_errormessage.ErrorMessage, {
                            errorMessage: errorMessage,
                          }),
                        ],
                      }
                    ),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_body.ErrorOverlayDialogBody, {
                      children: children,
                    }),
                  ],
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)(
                  _erroroverlaybottomstack.ErrorOverlayBottomStack,
                  {
                    errorCount:
                      (_runtimeErrors_length =
                        runtimeErrors == null ? void 0 : runtimeErrors.length) != null
                        ? _runtimeErrors_length
                        : 0,
                    activeIdx: activeIdx != null ? activeIdx : 0,
                  }
                ),
              ],
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_fader.Fader, {
              ref: faderRef,
              side: 'top',
              stop: '50%',
              blur: '4px',
              height: 48,
            }),
          ],
        }),
      });
    }
    function clamp(value, param) {
      let [min, max] = param;
      return Math.min(Math.max(value, min), max);
    }
    const styles =
      '\n  ' +
      _overlay.OVERLAY_STYLES +
      '\n  ' +
      _dialog1.DIALOG_STYLES +
      '\n  ' +
      _header.DIALOG_HEADER_STYLES +
      '\n  ' +
      _body.DIALOG_BODY_STYLES +
      '\n\n  ' +
      _erroroverlaynav.styles +
      '\n  ' +
      _errortypelabel.styles +
      '\n  ' +
      _errormessage.styles +
      '\n  ' +
      _erroroverlaytoolbar.styles +
      '\n  ' +
      _callstack.CALL_STACK_STYLES +
      '\n\n  [data-nextjs-error-label-group] {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-overlay-layout.js.map
  },
  8812: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorOverlayNav: function () {
        return ErrorOverlayNav;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _erroroverlaypagination = __webpack_require__(4768);
    const _versionstalenessinfo = __webpack_require__(1937);
    function ErrorOverlayNav(param) {
      let { runtimeErrors, activeIdx, setActiveIndex, versionInfo } = param;
      const bundlerName = 'Rspack' || 0;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        'data-nextjs-error-overlay-nav': true,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)(Notch, {
            side: 'left',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(
              _erroroverlaypagination.ErrorOverlayPagination,
              {
                runtimeErrors: runtimeErrors != null ? runtimeErrors : [],
                activeIdx: activeIdx != null ? activeIdx : 0,
                onActiveIndexChange: setActiveIndex != null ? setActiveIndex : () => {},
              }
            ),
          }),
          versionInfo &&
            /*#__PURE__*/ (0, _jsxruntime.jsx)(Notch, {
              side: 'right',
              children: /*#__PURE__*/ (0, _jsxruntime.jsx)(
                _versionstalenessinfo.VersionStalenessInfo,
                {
                  versionInfo: versionInfo,
                  bundlerName: bundlerName,
                }
              ),
            }),
        ],
      });
    }
    const styles =
      "\n  [data-nextjs-error-overlay-nav] {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n\n    width: 100%;\n\n    position: relative;\n    z-index: 2;\n    outline: none;\n    translate: 1px 1px;\n    max-width: var(--next-dialog-max-width);\n\n    .error-overlay-notch {\n      --stroke-color: var(--color-gray-400);\n      --background-color: var(--color-background-100);\n\n      translate: -1px 0;\n      width: auto;\n      height: var(--next-dialog-notch-height);\n      padding: 12px;\n      background: var(--background-color);\n      border: 1px solid var(--stroke-color);\n      border-bottom: none;\n      position: relative;\n\n      &[data-side='left'] {\n        padding-right: 0;\n        border-radius: var(--rounded-xl) 0 0 0;\n\n        .error-overlay-notch-tail {\n          right: -54px;\n        }\n\n        > *:not(.error-overlay-notch-tail) {\n          margin-right: -10px;\n        }\n      }\n\n      &[data-side='right'] {\n        padding-left: 0;\n        border-radius: 0 var(--rounded-xl) 0 0;\n\n        .error-overlay-notch-tail {\n          left: -54px;\n          transform: rotateY(180deg);\n        }\n\n        > *:not(.error-overlay-notch-tail) {\n          margin-left: -12px;\n        }\n      }\n\n      .error-overlay-notch-tail {\n        position: absolute;\n        top: -1px;\n        pointer-events: none;\n        z-index: -1;\n        height: calc(100% + 1px);\n      }\n    }\n  }\n";
    function Notch(param) {
      let { children, side = 'left' } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        className: 'error-overlay-notch',
        'data-side': side,
        children: [children, /*#__PURE__*/ (0, _jsxruntime.jsx)(Tail, {})],
      });
    }
    function Tail() {
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('svg', {
        width: '60',
        height: '42',
        viewBox: '0 0 60 42',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        className: 'error-overlay-notch-tail',
        preserveAspectRatio: 'none',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('mask', {
            id: 'error_overlay_nav_mask0_2667_14687',
            style: {
              maskType: 'alpha',
            },
            maskUnits: 'userSpaceOnUse',
            x: '0',
            y: '-1',
            width: '60',
            height: '43',
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('mask', {
                id: 'error_overlay_nav_path_1_outside_1_2667_14687',
                maskUnits: 'userSpaceOnUse',
                x: '0',
                y: '-1',
                width: '60',
                height: '43',
                fill: 'black',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('rect', {
                    fill: 'white',
                    y: '-1',
                    width: '60',
                    height: '43',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                    d: 'M1 0L8.0783 0C15.772 0 22.7836 4.41324 26.111 11.3501L34.8889 29.6498C38.2164 36.5868 45.228 41 52.9217 41H60H1L1 0Z',
                  }),
                ],
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                d: 'M1 0L8.0783 0C15.772 0 22.7836 4.41324 26.111 11.3501L34.8889 29.6498C38.2164 36.5868 45.228 41 52.9217 41H60H1L1 0Z',
                fill: 'white',
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                d: 'M1 0V-1H0V0L1 0ZM1 41H0V42H1V41ZM34.8889 29.6498L33.9873 30.0823L34.8889 29.6498ZM26.111 11.3501L27.0127 10.9177L26.111 11.3501ZM1 1H8.0783V-1H1V1ZM60 40H1V42H60V40ZM2 41V0L0 0L0 41H2ZM25.2094 11.7826L33.9873 30.0823L35.7906 29.2174L27.0127 10.9177L25.2094 11.7826ZM52.9217 42H60V40H52.9217V42ZM33.9873 30.0823C37.4811 37.3661 44.8433 42 52.9217 42V40C45.6127 40 38.9517 35.8074 35.7906 29.2174L33.9873 30.0823ZM8.0783 1C15.3873 1 22.0483 5.19257 25.2094 11.7826L27.0127 10.9177C23.5188 3.6339 16.1567 -1 8.0783 -1V1Z',
                fill: 'black',
                mask: 'url(#error_overlay_nav_path_1_outside_1_2667_14687)',
              }),
            ],
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('g', {
            mask: 'url(#error_overlay_nav_mask0_2667_14687)',
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('mask', {
                id: 'error_overlay_nav_path_3_outside_2_2667_14687',
                maskUnits: 'userSpaceOnUse',
                x: '-1',
                y: '0.0244141',
                width: '60',
                height: '43',
                fill: 'black',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('rect', {
                    fill: 'white',
                    x: '-1',
                    y: '0.0244141',
                    width: '60',
                    height: '43',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                    d: 'M0 1.02441H7.0783C14.772 1.02441 21.7836 5.43765 25.111 12.3746L33.8889 30.6743C37.2164 37.6112 44.228 42.0244 51.9217 42.0244H59H0L0 1.02441Z',
                  }),
                ],
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                d: 'M0 1.02441H7.0783C14.772 1.02441 21.7836 5.43765 25.111 12.3746L33.8889 30.6743C37.2164 37.6112 44.228 42.0244 51.9217 42.0244H59H0L0 1.02441Z',
                fill: 'var(--background-color)',
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                d: 'M0 1.02441L0 0.0244141H-1V1.02441H0ZM0 42.0244H-1V43.0244H0L0 42.0244ZM33.8889 30.6743L32.9873 31.1068L33.8889 30.6743ZM25.111 12.3746L26.0127 11.9421L25.111 12.3746ZM0 2.02441H7.0783V0.0244141H0L0 2.02441ZM59 41.0244H0L0 43.0244H59V41.0244ZM1 42.0244L1 1.02441H-1L-1 42.0244H1ZM24.2094 12.8071L32.9873 31.1068L34.7906 30.2418L26.0127 11.9421L24.2094 12.8071ZM51.9217 43.0244H59V41.0244H51.9217V43.0244ZM32.9873 31.1068C36.4811 38.3905 43.8433 43.0244 51.9217 43.0244V41.0244C44.6127 41.0244 37.9517 36.8318 34.7906 30.2418L32.9873 31.1068ZM7.0783 2.02441C14.3873 2.02441 21.0483 6.21699 24.2094 12.8071L26.0127 11.9421C22.5188 4.65831 15.1567 0.0244141 7.0783 0.0244141V2.02441Z',
                fill: 'var(--stroke-color)',
                mask: 'url(#error_overlay_nav_path_3_outside_2_2667_14687)',
              }),
            ],
          }),
        ],
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-overlay-nav.js.map
  },
  4768: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorOverlayPagination: function () {
        return ErrorOverlayPagination;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _leftarrow = __webpack_require__(3176);
    const _rightarrow = __webpack_require__(9059);
    function ErrorOverlayPagination(param) {
      let { runtimeErrors, activeIdx, onActiveIndexChange } = param;
      const handlePrevious = (0, _react.useCallback)(
        () =>
          (0, _react.startTransition)(() => {
            if (activeIdx > 0) {
              onActiveIndexChange(Math.max(0, activeIdx - 1));
            }
          }),
        [activeIdx, onActiveIndexChange]
      );
      const handleNext = (0, _react.useCallback)(
        () =>
          (0, _react.startTransition)(() => {
            if (activeIdx < runtimeErrors.length - 1) {
              onActiveIndexChange(
                Math.max(0, Math.min(runtimeErrors.length - 1, activeIdx + 1))
              );
            }
          }),
        [activeIdx, runtimeErrors.length, onActiveIndexChange]
      );
      const buttonLeft = (0, _react.useRef)(null);
      const buttonRight = (0, _react.useRef)(null);
      const [nav, setNav] = (0, _react.useState)(null);
      const onNav = (0, _react.useCallback)((el) => {
        setNav(el);
      }, []);
      (0, _react.useEffect)(() => {
        if (nav == null) {
          return;
        }
        const root = nav.getRootNode();
        const d = self.document;
        function handler(e) {
          if (e.key === 'ArrowLeft') {
            e.preventDefault();
            e.stopPropagation();
            handlePrevious && handlePrevious();
          } else if (e.key === 'ArrowRight') {
            e.preventDefault();
            e.stopPropagation();
            handleNext && handleNext();
          }
        }
        root.addEventListener('keydown', handler);
        if (root !== d) {
          d.addEventListener('keydown', handler);
        }
        return function () {
          root.removeEventListener('keydown', handler);
          if (root !== d) {
            d.removeEventListener('keydown', handler);
          }
        };
      }, [nav, handleNext, handlePrevious]);
      // Unlock focus for browsers like Firefox, that break all user focus if the
      // currently focused item becomes disabled.
      (0, _react.useEffect)(() => {
        if (nav == null) {
          return;
        }
        const root = nav.getRootNode();
        // Always true, but we do this for TypeScript:
        if (root instanceof ShadowRoot) {
          const a = root.activeElement;
          if (activeIdx === 0) {
            if (buttonLeft.current && a === buttonLeft.current) {
              buttonLeft.current.blur();
            }
          } else if (activeIdx === runtimeErrors.length - 1) {
            if (buttonRight.current && a === buttonRight.current) {
              buttonRight.current.blur();
            }
          }
        }
      }, [nav, activeIdx, runtimeErrors.length]);
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('nav', {
        className: 'error-overlay-pagination dialog-exclude-closing-from-outside-click',
        ref: onNav,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
            ref: buttonLeft,
            type: 'button',
            disabled: activeIdx === 0,
            'aria-disabled': activeIdx === 0,
            onClick: handlePrevious,
            'data-nextjs-dialog-error-previous': true,
            className: 'error-overlay-pagination-button',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_leftarrow.LeftArrow, {
              title: 'previous',
              className: 'error-overlay-pagination-button-icon',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
            className: 'error-overlay-pagination-count',
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('span', {
                'data-nextjs-dialog-error-index': activeIdx,
                children: [activeIdx + 1, '/'],
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                'data-nextjs-dialog-header-total-count': true,
                children: runtimeErrors.length || 1,
              }),
            ],
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
            ref: buttonRight,
            type: 'button',
            // If no errors or the last error is active, disable the button.
            disabled: activeIdx >= runtimeErrors.length - 1,
            'aria-disabled': activeIdx >= runtimeErrors.length - 1,
            onClick: handleNext,
            'data-nextjs-dialog-error-next': true,
            className: 'error-overlay-pagination-button',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_rightarrow.RightArrow, {
              title: 'next',
              className: 'error-overlay-pagination-button-icon',
            }),
          }),
        ],
      });
    }
    const styles =
      '\n  .error-overlay-pagination {\n    -webkit-font-smoothing: antialiased;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    gap: 8px;\n    width: fit-content;\n  }\n\n  .error-overlay-pagination-count {\n    color: var(--color-gray-900);\n    text-align: center;\n    font-size: var(--size-14);\n    font-weight: 500;\n    line-height: var(--size-16);\n    font-variant-numeric: tabular-nums;\n  }\n\n  .error-overlay-pagination-button {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n\n    width: var(--size-24);\n    height: var(--size-24);\n    background: var(--color-gray-300);\n    flex-shrink: 0;\n\n    border: none;\n    border-radius: var(--rounded-full);\n\n    svg {\n      width: var(--size-16);\n      height: var(--size-16);\n    }\n\n    &:focus-visible {\n      outline: var(--focus-ring);\n    }\n\n    &:not(:disabled):active {\n      background: var(--color-gray-500);\n    }\n\n    &:disabled {\n      opacity: 0.5;\n      cursor: not-allowed;\n    }\n  }\n\n  .error-overlay-pagination-button-icon {\n    color: var(--color-gray-1000);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-overlay-pagination.js.map
  },
  5942: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'CopyStackTraceButton', {
      enumerable: true,
      get: function () {
        return CopyStackTraceButton;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _copybutton = __webpack_require__(4807);
    function CopyStackTraceButton(param) {
      let { error } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_copybutton.CopyButton, {
        'data-nextjs-data-runtime-error-copy-stack': true,
        className: 'copy-stack-trace-button',
        actionLabel: 'Copy Stack Trace',
        successLabel: 'Stack Trace Copied',
        content: error.stack || '',
        disabled: !error.stack,
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=copy-stack-trace-button.js.map
  },
  4910: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'DocsLinkButton', {
      enumerable: true,
      get: function () {
        return DocsLinkButton;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _ishydrationerror = __webpack_require__(4291);
    const _parseurlfromtext = __webpack_require__(6903);
    const docsURLAllowlist = ['https://nextjs.org', 'https://react.dev'];
    function docsLinkMatcher(text) {
      return docsURLAllowlist.some((url) => text.startsWith(url));
    }
    function getDocsURLFromErrorMessage(text) {
      const urls = (0, _parseurlfromtext.parseUrlFromText)(text, docsLinkMatcher);
      if (urls.length === 0) {
        return null;
      }
      const href = urls[0];
      // Replace react hydration error link with nextjs hydration error link
      if (href === _ishydrationerror.REACT_HYDRATION_ERROR_LINK) {
        return _ishydrationerror.NEXTJS_HYDRATION_ERROR_LINK;
      }
      return href;
    }
    function DocsLinkButton(param) {
      let { errorMessage } = param;
      const docsURL = getDocsURLFromErrorMessage(errorMessage);
      if (!docsURL) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
          title: 'No related documentation found',
          'aria-label': 'No related documentation found',
          className: 'docs-link-button',
          disabled: true,
          children: /*#__PURE__*/ (0, _jsxruntime.jsx)(DocsIcon, {
            className: 'error-overlay-toolbar-button-icon',
            width: 14,
            height: 14,
          }),
        });
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('a', {
        title: 'Go to related documentation',
        'aria-label': 'Go to related documentation',
        className: 'docs-link-button',
        href: docsURL,
        target: '_blank',
        rel: 'noopener noreferrer',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(DocsIcon, {
          className: 'error-overlay-toolbar-button-icon',
          width: 14,
          height: 14,
        }),
      });
    }
    function DocsIcon(props) {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '14',
        height: '14',
        viewBox: '0 0 14 14',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        ...props,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M0 .875h4.375C5.448.875 6.401 1.39 7 2.187A3.276 3.276 0 0 1 9.625.875H14v11.156H9.4c-.522 0-1.023.208-1.392.577l-.544.543h-.928l-.544-.543c-.369-.37-.87-.577-1.392-.577H0V.875zm6.344 3.281a1.969 1.969 0 0 0-1.969-1.968H1.312v8.53H4.6c.622 0 1.225.177 1.744.502V4.156zm1.312 7.064V4.156c0-1.087.882-1.968 1.969-1.968h3.063v8.53H9.4c-.622 0-1.225.177-1.744.502z',
          fill: 'currentColor',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=docs-link-button.js.map
  },
  7717: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorOverlayToolbar: function () {
        return ErrorOverlayToolbar;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _nodejsinspectorbutton = __webpack_require__(1325);
    const _copystacktracebutton = __webpack_require__(5942);
    const _docslinkbutton = __webpack_require__(4910);
    function ErrorOverlayToolbar(param) {
      let { error, debugInfo } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('span', {
        className: 'error-overlay-toolbar',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_copystacktracebutton.CopyStackTraceButton, {
            error: error,
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_docslinkbutton.DocsLinkButton, {
            errorMessage: error.message,
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(
            _nodejsinspectorbutton.NodejsInspectorButton,
            {
              devtoolsFrontendUrl:
                debugInfo == null ? void 0 : debugInfo.devtoolsFrontendUrl,
            }
          ),
        ],
      });
    }
    const styles =
      '\n  .error-overlay-toolbar {\n    display: flex;\n    gap: 6px;\n  }\n\n  .nodejs-inspector-button,\n  .copy-stack-trace-button,\n  .docs-link-button {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n\n    width: var(--size-28);\n    height: var(--size-28);\n    background: var(--color-background-100);\n    background-clip: padding-box;\n    border: 1px solid var(--color-gray-alpha-400);\n    box-shadow: var(--shadow-small);\n    border-radius: var(--rounded-full);\n\n    svg {\n      width: var(--size-14);\n      height: var(--size-14);\n    }\n\n    &:focus {\n      outline: var(--focus-ring);\n    }\n\n    &:not(:disabled):hover {\n      background: var(--color-gray-alpha-100);\n    }\n\n    &:not(:disabled):active {\n      background: var(--color-gray-alpha-200);\n    }\n\n    &:disabled {\n      background-color: var(--color-gray-100);\n      cursor: not-allowed;\n    }\n  }\n\n  .error-overlay-toolbar-button-icon {\n    color: var(--color-gray-900);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-overlay-toolbar.js.map
  },
  1325: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'NodejsInspectorButton', {
      enumerable: true,
      get: function () {
        return NodejsInspectorButton;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _copybutton = __webpack_require__(4807);
    // Inline this helper to avoid widely used across the codebase,
    // as for this feature the Chrome detector doesn't need to be super accurate.
    function isChrome() {
      if (true) return false;
      const isChromium = 'chrome' in window && window.chrome;
      const vendorName = window.navigator.vendor;
      return (
        isChromium !== null && isChromium !== undefined && vendorName === 'Google Inc.'
      );
    }
    const isChromeBrowser = isChrome();
    function NodeJsIcon(props) {
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('svg', {
        width: '14',
        height: '14',
        viewBox: '0 0 14 14',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        ...props,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('mask', {
            id: 'nodejs_icon_mask_a',
            style: {
              maskType: 'luminance',
            },
            maskUnits: 'userSpaceOnUse',
            x: '0',
            y: '0',
            width: '14',
            height: '14',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
              d: 'M6.67.089 1.205 3.256a.663.663 0 0 0-.33.573v6.339c0 .237.126.455.33.574l5.466 3.17a.66.66 0 0 0 .66 0l5.465-3.17a.664.664 0 0 0 .329-.574V3.829a.663.663 0 0 0-.33-.573L7.33.089a.663.663 0 0 0-.661 0',
              fill: '#fff',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('g', {
            mask: 'url(#nodejs_icon_mask_a)',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
              d: 'M18.648 2.717 3.248-4.86-4.648 11.31l15.4 7.58 7.896-16.174z',
              fill: 'url(#nodejs_icon_linear_gradient_b)',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('mask', {
            id: 'nodejs_icon_mask_c',
            style: {
              maskType: 'luminance',
            },
            maskUnits: 'userSpaceOnUse',
            x: '1',
            y: '0',
            width: '12',
            height: '14',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
              d: 'M1.01 10.57a.663.663 0 0 0 .195.17l4.688 2.72.781.45a.66.66 0 0 0 .51.063l5.764-10.597a.653.653 0 0 0-.153-.122L9.216 1.18 7.325.087a.688.688 0 0 0-.171-.07L1.01 10.57z',
              fill: '#fff',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('g', {
            mask: 'url(#nodejs_icon_mask_c)',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
              d: 'M-5.647 4.958 5.226 19.734l14.38-10.667L8.734-5.71-5.647 4.958z',
              fill: 'url(#nodejs_icon_linear_gradient_d)',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('g', {
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsx)('mask', {
                id: 'nodejs_icon_mask_e',
                style: {
                  maskType: 'luminance',
                },
                maskUnits: 'userSpaceOnUse',
                x: '1',
                y: '0',
                width: '13',
                height: '14',
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                  d: 'M6.934.004A.665.665 0 0 0 6.67.09L1.22 3.247l5.877 10.746a.655.655 0 0 0 .235-.08l5.465-3.17a.665.665 0 0 0 .319-.453L7.126.015a.684.684 0 0 0-.189-.01',
                  fill: '#fff',
                }),
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('g', {
                mask: 'url(#nodejs_icon_mask_e)',
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                  d: 'M1.22.002v13.992h11.894V.002H1.22z',
                  fill: 'url(#nodejs_icon_linear_gradient_f)',
                }),
              }),
            ],
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('defs', {
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('linearGradient', {
                id: 'nodejs_icon_linear_gradient_b',
                x1: '10.943',
                y1: '-1.084',
                x2: '2.997',
                y2: '15.062',
                gradientUnits: 'userSpaceOnUse',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.3',
                    stopColor: '#3E863D',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.5',
                    stopColor: '#55934F',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.8',
                    stopColor: '#5AAD45',
                  }),
                ],
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('linearGradient', {
                id: 'nodejs_icon_linear_gradient_d',
                x1: '-.145',
                y1: '12.431',
                x2: '14.277',
                y2: '1.818',
                gradientUnits: 'userSpaceOnUse',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.57',
                    stopColor: '#3E863D',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.72',
                    stopColor: '#619857',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '1',
                    stopColor: '#76AC64',
                  }),
                ],
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('linearGradient', {
                id: 'nodejs_icon_linear_gradient_f',
                x1: '1.225',
                y1: '6.998',
                x2: '13.116',
                y2: '6.998',
                gradientUnits: 'userSpaceOnUse',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.16',
                    stopColor: '#6BBF47',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.38',
                    stopColor: '#79B461',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.47',
                    stopColor: '#75AC64',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.7',
                    stopColor: '#659E5A',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.9',
                    stopColor: '#3E863D',
                  }),
                ],
              }),
            ],
          }),
        ],
      });
    }
    function NodeJsDisabledIcon(props) {
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('svg', {
        width: '14',
        height: '14',
        viewBox: '0 0 14 14',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        ...props,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('mask', {
            id: 'nodejs_icon_mask_a',
            style: {
              maskType: 'luminance',
            },
            maskUnits: 'userSpaceOnUse',
            x: '0',
            y: '0',
            width: '14',
            height: '14',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
              d: 'M6.67.089 1.205 3.256a.663.663 0 0 0-.33.573v6.339c0 .237.126.455.33.574l5.466 3.17a.66.66 0 0 0 .66 0l5.465-3.17a.664.664 0 0 0 .329-.574V3.829a.663.663 0 0 0-.33-.573L7.33.089a.663.663 0 0 0-.661 0',
              fill: '#fff',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('g', {
            mask: 'url(#nodejs_icon_mask_a)',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
              d: 'M18.648 2.717 3.248-4.86-4.646 11.31l15.399 7.58 7.896-16.174z',
              fill: 'url(#nodejs_icon_linear_gradient_b)',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('mask', {
            id: 'nodejs_icon_mask_c',
            style: {
              maskType: 'luminance',
            },
            maskUnits: 'userSpaceOnUse',
            x: '1',
            y: '0',
            width: '12',
            height: '15',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
              d: 'M1.01 10.571a.66.66 0 0 0 .195.172l4.688 2.718.781.451a.66.66 0 0 0 .51.063l5.764-10.597a.653.653 0 0 0-.153-.122L9.216 1.181 7.325.09a.688.688 0 0 0-.171-.07L1.01 10.572z',
              fill: '#fff',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('g', {
            mask: 'url(#nodejs_icon_mask_c)',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
              d: 'M-5.647 4.96 5.226 19.736 19.606 9.07 8.734-5.707-5.647 4.96z',
              fill: 'url(#nodejs_icon_linear_gradient_d)',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('g', {
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsx)('mask', {
                id: 'nodejs_icon_mask_e',
                style: {
                  maskType: 'luminance',
                },
                maskUnits: 'userSpaceOnUse',
                x: '1',
                y: '0',
                width: '13',
                height: '14',
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                  d: 'M6.935.003a.665.665 0 0 0-.264.085l-5.45 3.158 5.877 10.747a.653.653 0 0 0 .235-.082l5.465-3.17a.665.665 0 0 0 .319-.452L7.127.014a.684.684 0 0 0-.189-.01',
                  fill: '#fff',
                }),
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('g', {
                mask: 'url(#nodejs_icon_mask_e)',
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                  d: 'M1.222.001v13.992h11.893V0H1.222z',
                  fill: 'url(#nodejs_icon_linear_gradient_f)',
                }),
              }),
            ],
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('defs', {
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('linearGradient', {
                id: 'nodejs_icon_linear_gradient_b',
                x1: '10.944',
                y1: '-1.084',
                x2: '2.997',
                y2: '15.062',
                gradientUnits: 'userSpaceOnUse',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.3',
                    stopColor: '#676767',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.5',
                    stopColor: '#858585',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.8',
                    stopColor: '#989A98',
                  }),
                ],
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('linearGradient', {
                id: 'nodejs_icon_linear_gradient_d',
                x1: '-.145',
                y1: '12.433',
                x2: '14.277',
                y2: '1.819',
                gradientUnits: 'userSpaceOnUse',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.57',
                    stopColor: '#747474',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.72',
                    stopColor: '#707070',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '1',
                    stopColor: '#929292',
                  }),
                ],
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsxs)('linearGradient', {
                id: 'nodejs_icon_linear_gradient_f',
                x1: '1.226',
                y1: '6.997',
                x2: '13.117',
                y2: '6.997',
                gradientUnits: 'userSpaceOnUse',
                children: [
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.16',
                    stopColor: '#878787',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.38',
                    stopColor: '#A9A9A9',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.47',
                    stopColor: '#A5A5A5',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.7',
                    stopColor: '#8F8F8F',
                  }),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)('stop', {
                    offset: '.9',
                    stopColor: '#626262',
                  }),
                ],
              }),
            ],
          }),
        ],
      });
    }
    const label =
      'Learn more about enabling Node.js inspector for server code with Chrome DevTools';
    function NodejsInspectorButton(param) {
      let { devtoolsFrontendUrl } = param;
      const content = devtoolsFrontendUrl || '';
      const disabled = !content || !isChromeBrowser;
      if (disabled) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)('a', {
          title: label,
          'aria-label': label,
          className: 'nodejs-inspector-button',
          href: 'https://nextjs.org/docs/app/building-your-application/configuring/debugging#server-side-code',
          target: '_blank',
          rel: 'noopener noreferrer',
          children: /*#__PURE__*/ (0, _jsxruntime.jsx)(NodeJsDisabledIcon, {
            className: 'error-overlay-toolbar-button-icon',
            width: 14,
            height: 14,
          }),
        });
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_copybutton.CopyButton, {
        'data-nextjs-data-runtime-error-copy-devtools-url': true,
        className: 'nodejs-inspector-button',
        actionLabel: 'Copy Chrome DevTools URL',
        successLabel: 'Copied',
        content: content,
        icon: /*#__PURE__*/ (0, _jsxruntime.jsx)(NodeJsIcon, {
          className: 'error-overlay-toolbar-button-icon',
          width: 14,
          height: 14,
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=nodejs-inspector-button.js.map
  },
  8748: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ErrorOverlay', {
      enumerable: true,
      get: function () {
        return ErrorOverlay;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _builderror = __webpack_require__(1095);
    const _errors = __webpack_require__(7709);
    const _usedelayedrender = __webpack_require__(7000);
    const transitionDurationMs = 200;
    function ErrorOverlay(param) {
      let { state, runtimeErrors, isErrorOverlayOpen, setIsErrorOverlayOpen } = param;
      const isTurbopack = !!false;
      // This hook lets us do an exit animation before unmounting the component
      const { mounted, rendered } = (0, _usedelayedrender.useDelayedRender)(
        isErrorOverlayOpen,
        {
          exitDelay: transitionDurationMs,
        }
      );
      const commonProps = {
        rendered,
        transitionDurationMs,
        isTurbopack,
        versionInfo: state.versionInfo,
      };
      if (state.buildError !== null) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_builderror.BuildError, {
          ...commonProps,
          message: state.buildError,
          // This is not a runtime error, forcedly display error overlay
          rendered: true,
        });
      }
      // No Runtime Errors.
      if (!runtimeErrors.length) {
        // Workaround React quirk that triggers "Switch to client-side rendering" if
        // we return no Suspense boundary here.
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {});
      }
      if (!mounted) {
        // Workaround React quirk that triggers "Switch to client-side rendering" if
        // we return no Suspense boundary here.
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {});
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errors.Errors, {
        ...commonProps,
        debugInfo: state.debugInfo,
        runtimeErrors: runtimeErrors,
        onClose: () => {
          setIsErrorOverlayOpen(false);
        },
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-overlay.js.map
  },
  65: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorTypeLabel: function () {
        return ErrorTypeLabel;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function ErrorTypeLabel(param) {
      let { errorType } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
        id: 'nextjs__container_errors_label',
        className: 'nextjs__container_errors_label',
        children: errorType,
      });
    }
    const styles =
      '\n  .nextjs__container_errors_label {\n    padding: 2px 6px;\n    margin: 0;\n    border-radius: var(--rounded-md-2);\n    background: var(--color-red-100);\n    font-weight: 600;\n    font-size: var(--size-12);\n    color: var(--color-red-900);\n    font-family: var(--font-stack-monospace);\n    line-height: var(--size-20);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-type-label.js.map
  },
  988: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ErrorOverlayOverlay: function () {
        return ErrorOverlayOverlay;
      },
      OVERLAY_STYLES: function () {
        return OVERLAY_STYLES;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _overlay = __webpack_require__(2155);
    function ErrorOverlayOverlay(param) {
      let { children, ...props } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_overlay.Overlay, {
        ...props,
        children: children,
      });
    }
    const OVERLAY_STYLES =
      '\n  [data-nextjs-dialog-overlay] {\n    padding: initial;\n    top: 10vh;\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=overlay.js.map
  },
  3289: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      FADER_STYLES: function () {
        return FADER_STYLES;
      },
      Fader: function () {
        return Fader;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const Fader = /*#__PURE__*/ (0, _react.forwardRef)(function Fader(param, ref) {
      let { stop, blur, side, style, height } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
        ref: ref,
        'aria-hidden': true,
        'data-nextjs-scroll-fader': true,
        className: 'nextjs-scroll-fader',
        'data-side': side,
        style: {
          '--stop': stop,
          '--blur': blur,
          '--height': '' + height + 'px',
          ...style,
        },
      });
    });
    const FADER_STYLES =
      '\n  .nextjs-scroll-fader {\n    --blur: 1px;\n    --stop: 25%;\n    --height: 150px;\n    --color-bg: var(--color-background-100);\n    position: absolute;\n    pointer-events: none;\n    user-select: none;\n    width: 100%;\n    height: var(--height);\n    left: 0;\n    backdrop-filter: blur(var(--blur));\n\n    &[data-side="top"] {\n      top: 0;\n      background: linear-gradient(to top, transparent, var(--color-bg));\n      mask-image: linear-gradient(to bottom, var(--color-bg) var(--stop), transparent);\n    }\n  }\n\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=index.js.map
  },
  3704: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'HotlinkedText', {
      enumerable: true,
      get: function () {
        return HotlinkedText;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(863));
    const _magicidentifier = __webpack_require__(5329);
    const linkRegex = /https?:\/\/[^\s/$.?#].[^\s)'"]*/i;
    const splitRegexp = new RegExp(
      '(' + _magicidentifier.MAGIC_IDENTIFIER_REGEX.source + '|\\s+)'
    );
    const HotlinkedText = function HotlinkedText(props) {
      const { text, matcher } = props;
      const wordsAndWhitespaces = text.split(splitRegexp);
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: wordsAndWhitespaces.map((word, index) => {
          if (linkRegex.test(word)) {
            const link = linkRegex.exec(word);
            const href = link[0];
            // If link matcher is present but the link doesn't match, don't turn it into a link
            if (typeof matcher === 'function' && !matcher(href)) {
              return word;
            }
            return /*#__PURE__*/ (0, _jsxruntime.jsx)(
              _react.default.Fragment,
              {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)('a', {
                  href: href,
                  target: '_blank',
                  rel: 'noreferrer noopener',
                  children: word,
                }),
              },
              'link-' + index
            );
          }
          try {
            const decodedWord = (0, _magicidentifier.decodeMagicIdentifier)(word);
            if (decodedWord !== word) {
              return /*#__PURE__*/ (0, _jsxruntime.jsxs)(
                'i',
                {
                  children: ['{', decodedWord, '}'],
                },
                'ident-' + index
              );
            }
          } catch (e) {
            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(
              'i',
              {
                children: ['{', word, ' (decoding failed: ', '' + e, ')', '}'],
              },
              'ident-' + index
            );
          }
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(
            _react.default.Fragment,
            {
              children: word,
            },
            'text-' + index
          );
        }),
      });
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=index.js.map
  },
  9976: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'PseudoHtmlDiff', {
      enumerable: true,
      get: function () {
        return PseudoHtmlDiff;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _collapseicon = __webpack_require__(8186);
    function PseudoHtmlDiff(param) {
      let {
        firstContent,
        secondContent,
        hydrationMismatchType,
        reactOutputComponentDiff,
        ...props
      } = param;
      const [isDiffCollapsed, toggleCollapseHtml] = (0, _react.useState)(true);
      const htmlComponents = (0, _react.useMemo)(() => {
        const componentStacks = [];
        const reactComponentDiffLines = reactOutputComponentDiff.split('\n');
        reactComponentDiffLines.forEach((line, index) => {
          const isDiffLine = line[0] === '+' || line[0] === '-';
          const isHighlightedLine = line[0] === '>';
          const hasSign = isDiffLine || isHighlightedLine;
          const sign = hasSign ? line[0] : '';
          const signIndex = hasSign ? line.indexOf(sign) : -1;
          const [prefix, suffix] = hasSign
            ? [line.slice(0, signIndex), line.slice(signIndex + 1)]
            : [line, ''];
          if (isDiffLine) {
            componentStacks.push(
              /*#__PURE__*/ (0, _jsxruntime.jsx)(
                'span',
                {
                  'data-nextjs-container-errors-pseudo-html-line': true,
                  'data-nextjs-container-errors-pseudo-html--diff':
                    sign === '+' ? 'add' : 'remove',
                  children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('span', {
                    children: [
                      prefix,
                      /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                        'data-nextjs-container-errors-pseudo-html-line-sign': true,
                        children: sign,
                      }),
                      suffix,
                      '\n',
                    ],
                  }),
                },
                'comp-diff' + index
              )
            );
          } else {
            // In general, if it's not collapsed, show the whole diff
            componentStacks.push(
              /*#__PURE__*/ (0, _jsxruntime.jsxs)(
                'span',
                {
                  'data-nextjs-container-errors-pseudo-html-line': true,
                  ...(isHighlightedLine
                    ? {
                        'data-nextjs-container-errors-pseudo-html--diff': 'error',
                      }
                    : undefined),
                  children: [
                    prefix,
                    /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                      'data-nextjs-container-errors-pseudo-html-line-sign': true,
                      children: sign,
                    }),
                    suffix,
                    '\n',
                  ],
                },
                'comp-diff' + index
              )
            );
          }
        });
        return componentStacks;
      }, [reactOutputComponentDiff]);
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        'data-nextjs-container-errors-pseudo-html': true,
        'data-nextjs-container-errors-pseudo-html-collapse': isDiffCollapsed,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
            tabIndex: 10,
            'data-nextjs-container-errors-pseudo-html-collapse-button': true,
            onClick: () => toggleCollapseHtml(!isDiffCollapsed),
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_collapseicon.CollapseIcon, {
              collapsed: isDiffCollapsed,
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('pre', {
            ...props,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('code', {
              children: htmlComponents,
            }),
          }),
        ],
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=diff-view.js.map
  },
  7381: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      lock: function () {
        return lock;
      },
      unlock: function () {
        return unlock;
      },
    });
    let previousBodyPaddingRight;
    let previousBodyOverflowSetting;
    let activeLocks = 0;
    function lock() {
      setTimeout(() => {
        if (activeLocks++ > 0) {
          return;
        }
        const scrollBarGap = window.innerWidth - document.documentElement.clientWidth;
        if (scrollBarGap > 0) {
          previousBodyPaddingRight = document.body.style.paddingRight;
          document.body.style.paddingRight = '' + scrollBarGap + 'px';
        }
        previousBodyOverflowSetting = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
      });
    }
    function unlock() {
      setTimeout(() => {
        if (activeLocks === 0 || --activeLocks !== 0) {
          return;
        }
        if (previousBodyPaddingRight !== undefined) {
          document.body.style.paddingRight = previousBodyPaddingRight;
          previousBodyPaddingRight = undefined;
        }
        if (previousBodyOverflowSetting !== undefined) {
          document.body.style.overflow = previousBodyOverflowSetting;
          previousBodyOverflowSetting = undefined;
        }
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=body-locker.js.map
  },
  6165: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'Overlay', {
      enumerable: true,
      get: function () {
        return _overlay.Overlay;
      },
    });
    const _overlay = __webpack_require__(2155);
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=index.js.map
  },
  2155: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'Overlay', {
      enumerable: true,
      get: function () {
        return Overlay;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _bodylocker = __webpack_require__(7381);
    const Overlay = function Overlay(param) {
      let { className, children, fixed, ...props } = param;
      _react.useEffect(
        {
          'Overlay.useEffect': () => {
            (0, _bodylocker.lock)();
            return {
              'Overlay.useEffect': () => {
                (0, _bodylocker.unlock)();
              },
            }['Overlay.useEffect'];
          },
        }['Overlay.useEffect'],
        []
      );
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        'data-nextjs-dialog-overlay': true,
        className: className,
        ...props,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
            'data-nextjs-dialog-backdrop': true,
            'data-nextjs-dialog-backdrop-fixed': fixed ? true : undefined,
          }),
          children,
        ],
      });
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=overlay.js.map
  },
  9781: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'styles', {
      enumerable: true,
      get: function () {
        return styles;
      },
    });
    const styles =
      '\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  @media (max-height: 812px) {\n    [data-nextjs-dialog-overlay] {\n      padding: 15px 15px 0;\n    }\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: var(--color-backdrop);\n    backdrop-filter: blur(10px);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=styles.js.map
  },
  1128: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ShadowPortal', {
      enumerable: true,
      get: function () {
        return ShadowPortal;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _reactdom = __webpack_require__(2951);
    const _shared = __webpack_require__(6172);
    function ShadowPortal(param) {
      let { children } = param;
      let portalNode = _react.useRef(null);
      let shadowNode = _react.useRef(null);
      let [, forceUpdate] = _react.useState();
      // Don't use useLayoutEffect here, as it will cause warnings during SSR in React 18.
      // Don't use useSyncExternalStore as an SSR gate unless you verified it doesn't
      // downgrade a Transition of the initial root render to a sync render or
      // we can assure the root render is not a Transition.
      _react.useEffect(
        {
          'ShadowPortal.useEffect': () => {
            const ownerDocument = document;
            portalNode.current = ownerDocument.createElement('nextjs-portal');
            // load default color preference from localstorage
            if (typeof localStorage !== 'undefined') {
              const theme = localStorage.getItem(_shared.STORAGE_KEY_THEME);
              if (theme === 'dark') {
                portalNode.current.classList.add('dark');
                portalNode.current.classList.remove('light');
              } else if (theme === 'light') {
                portalNode.current.classList.remove('dark');
                portalNode.current.classList.add('light');
              }
            }
            shadowNode.current = portalNode.current.attachShadow({
              mode: 'open',
            });
            ownerDocument.body.appendChild(portalNode.current);
            forceUpdate({});
            return {
              'ShadowPortal.useEffect': () => {
                if (portalNode.current && portalNode.current.ownerDocument) {
                  portalNode.current.ownerDocument.body.removeChild(portalNode.current);
                }
              },
            }['ShadowPortal.useEffect'];
          },
        }['ShadowPortal.useEffect'],
        []
      );
      return shadowNode.current
        ? /*#__PURE__*/ (0, _reactdom.createPortal)(children, shadowNode.current)
        : null;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=shadow-portal.js.map
  },
  7019: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      EDITOR_LINK_STYLES: function () {
        return EDITOR_LINK_STYLES;
      },
      EditorLink: function () {
        return EditorLink;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _useopenineditor = __webpack_require__(9051);
    function EditorLink(param) {
      let { file, location } = param;
      var _location_line, _location_column;
      const open = (0, _useopenineditor.useOpenInEditor)({
        file,
        lineNumber:
          (_location_line = location == null ? void 0 : location.line) != null
            ? _location_line
            : 1,
        column:
          (_location_column = location == null ? void 0 : location.column) != null
            ? _location_column
            : 0,
      });
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        'data-with-open-in-editor-link': true,
        'data-with-open-in-editor-link-import-trace': true,
        tabIndex: 10,
        role: 'link',
        onClick: open,
        title: 'Click to open in your editor',
        children: [
          file,
          location ? ':' + location.line + ':' + location.column : null,
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('svg', {
            xmlns: 'http://www.w3.org/2000/svg',
            viewBox: '0 0 24 24',
            fill: 'none',
            stroke: 'currentColor',
            strokeWidth: '2',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
            children: [
              /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                d: 'M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6',
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('polyline', {
                points: '15 3 21 3 21 9',
              }),
              /*#__PURE__*/ (0, _jsxruntime.jsx)('line', {
                x1: '10',
                y1: '14',
                x2: '21',
                y2: '3',
              }),
            ],
          }),
        ],
      });
    }
    const EDITOR_LINK_STYLES =
      '\n  [data-with-open-in-editor-link] svg {\n    width: auto;\n    height: var(--size-14);\n    margin-left: 8px;\n  }\n  [data-with-open-in-editor-link] {\n    cursor: pointer;\n  }\n  [data-with-open-in-editor-link]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-with-open-in-editor-link-import-trace] {\n    margin-left: 16px;\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=editor-link.js.map
  },
  6790: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'Terminal', {
      enumerable: true,
      get: function () {
        return _terminal.Terminal;
      },
    });
    const _terminal = __webpack_require__(4325);
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=index.js.map
  },
  4325: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      TERMINAL_STYLES: function () {
        return TERMINAL_STYLES;
      },
      Terminal: function () {
        return Terminal;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _anser = /*#__PURE__*/ _interop_require_default._(__webpack_require__(1238));
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _hotlinkedtext = __webpack_require__(3704);
    const _editorlink = __webpack_require__(7019);
    const _external = __webpack_require__(8540);
    const _stackframe = __webpack_require__(9667);
    const _useopenineditor = __webpack_require__(9051);
    const _file = __webpack_require__(7378);
    function getFile(lines) {
      const contentFileName = lines.shift();
      if (!contentFileName) return null;
      const [fileName, line, column] = contentFileName.split(':', 3);
      const parsedLine = Number(line);
      const parsedColumn = Number(column);
      const hasLocation = !Number.isNaN(parsedLine) && !Number.isNaN(parsedColumn);
      return {
        fileName: hasLocation ? fileName : contentFileName,
        location: hasLocation
          ? {
              line: parsedLine,
              column: parsedColumn,
            }
          : undefined,
      };
    }
    function getImportTraceFiles(lines) {
      if (
        lines.some((line) => /ReactServerComponentsError:/.test(line)) ||
        lines.some((line) => /Import trace for requested module:/.test(line))
      ) {
        // Grab the lines at the end containing the files
        const files = [];
        while (
          /.+\..+/.test(lines[lines.length - 1]) &&
          !lines[lines.length - 1].includes(':')
        ) {
          const file = lines.pop().trim();
          files.unshift(file);
        }
        return files;
      }
      return [];
    }
    function getEditorLinks(content) {
      const lines = content.split('\n');
      const file = getFile(lines);
      const importTraceFiles = getImportTraceFiles(lines);
      return {
        file,
        source: lines.join('\n'),
        importTraceFiles,
      };
    }
    const Terminal = function Terminal(param) {
      let { content } = param;
      var _file_location,
        _file_location1,
        _file_location2,
        _file_location3,
        _stackFrame_file;
      const { file, source, importTraceFiles } = _react.useMemo(
        {
          'Terminal.useMemo': () => getEditorLinks(content),
        }['Terminal.useMemo'],
        [content]
      );
      const decoded = _react.useMemo(
        {
          'Terminal.useMemo[decoded]': () => {
            return _anser.default.ansiToJson(source, {
              json: true,
              use_classes: true,
              remove_empty: true,
            });
          },
        }['Terminal.useMemo[decoded]'],
        [source]
      );
      var _file_location_line, _file_location_column;
      const open = (0, _useopenineditor.useOpenInEditor)({
        file: file == null ? void 0 : file.fileName,
        lineNumber:
          (_file_location_line =
            file == null
              ? void 0
              : (_file_location = file.location) == null
                ? void 0
                : _file_location.line) != null
            ? _file_location_line
            : 1,
        column:
          (_file_location_column =
            file == null
              ? void 0
              : (_file_location1 = file.location) == null
                ? void 0
                : _file_location1.column) != null
            ? _file_location_column
            : 0,
      });
      var _file_fileName, _file_location_line1, _file_location_column1;
      const stackFrame = {
        file:
          (_file_fileName = file == null ? void 0 : file.fileName) != null
            ? _file_fileName
            : null,
        methodName: '',
        arguments: [],
        lineNumber:
          (_file_location_line1 =
            file == null
              ? void 0
              : (_file_location2 = file.location) == null
                ? void 0
                : _file_location2.line) != null
            ? _file_location_line1
            : null,
        column:
          (_file_location_column1 =
            file == null
              ? void 0
              : (_file_location3 = file.location) == null
                ? void 0
                : _file_location3.column) != null
            ? _file_location_column1
            : null,
      };
      const fileExtension =
        stackFrame == null
          ? void 0
          : (_stackFrame_file = stackFrame.file) == null
            ? void 0
            : _stackFrame_file.split('.').pop();
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
        'data-nextjs-codeframe': true,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
            className: 'code-frame-header',
            children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
              className: 'code-frame-link',
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                  className: 'code-frame-icon',
                  children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_file.FileIcon, {
                    lang: fileExtension,
                  }),
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                  'data-text': true,
                  children: (0, _stackframe.getFrameSource)(stackFrame),
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)('button', {
                  'aria-label': 'Open in editor',
                  'data-with-open-in-editor-link-source-file': true,
                  onClick: open,
                  children: /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
                    className: 'code-frame-icon',
                    'data-icon': 'right',
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_external.ExternalIcon, {
                      width: 16,
                      height: 16,
                    }),
                  }),
                }),
              ],
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('pre', {
            className: 'code-frame-pre',
            children: [
              decoded.map((entry, index) =>
                /*#__PURE__*/ (0, _jsxruntime.jsx)(
                  'span',
                  {
                    style: {
                      color: entry.fg ? 'var(--color-' + entry.fg + ')' : undefined,
                      ...(entry.decoration === 'bold' // above 600, hence a temporary fix is to use 500 for bold.
                        ? {
                            fontWeight: 500,
                          }
                        : entry.decoration === 'italic'
                          ? {
                              fontStyle: 'italic',
                            }
                          : undefined),
                    },
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(
                      _hotlinkedtext.HotlinkedText,
                      {
                        text: entry.content,
                      }
                    ),
                  },
                  'terminal-entry-' + index
                )
              ),
              importTraceFiles.map((importTraceFile) =>
                /*#__PURE__*/ (0, _jsxruntime.jsx)(
                  _editorlink.EditorLink,
                  {
                    isSourceFile: false,
                    file: importTraceFile,
                  },
                  importTraceFile
                )
              ),
            ],
          }),
        ],
      });
    };
    const TERMINAL_STYLES =
      '\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-terminal] > div > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n    margin: 0;\n  }\n  [data-nextjs-terminal] > div > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-terminal] div > pre {\n    overflow: hidden;\n    display: inline-block;\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=terminal.js.map
  },
  3709: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      Toast: function () {
        return _toast.Toast;
      },
      styles: function () {
        return _styles.styles;
      },
    });
    const _styles = __webpack_require__(5913);
    const _toast = __webpack_require__(2236);
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=index.js.map
  },
  5913: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'styles', {
      enumerable: true,
      get: function () {
        return styles;
      },
    });
    const styles =
      '\n  .nextjs-toast {\n    position: fixed;\n    bottom: 16px;\n    left: 16px;\n    max-width: 420px;\n    z-index: 9000;\n    box-shadow: 0px 16px 32px\n      rgba(0, 0, 0, 0.25);\n  }\n\n  @media (max-width: 440px) {\n    .nextjs-toast {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  .nextjs-toast-errors-parent {\n    padding: 16px;\n    border-radius: var(--rounded-4xl);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=styles.js.map
  },
  2236: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'Toast', {
      enumerable: true,
      get: function () {
        return Toast;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _cx = __webpack_require__(6160);
    const Toast = function Toast(param) {
      let { onClick, children, className, ...props } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
        ...props,
        onClick: (e) => {
          if (!e.target.closest('a')) {
            e.preventDefault();
          }
          return onClick == null ? void 0 : onClick();
        },
        className: (0, _cx.cx)('nextjs-toast', className),
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
          'data-nextjs-toast-wrapper': true,
          children: children,
        }),
      });
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=toast.js.map
  },
  1937: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      VersionStalenessInfo: function () {
        return VersionStalenessInfo;
      },
      getStaleness: function () {
        return getStaleness;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _cx = __webpack_require__(6160);
    function VersionStalenessInfo(param) {
      let { versionInfo, bundlerName } = param;
      const { staleness } = versionInfo;
      let { text, indicatorClass, title } = getStaleness(versionInfo);
      const isTurbopack = bundlerName === 'Turbopack';
      const shouldBeLink = staleness.startsWith('stale');
      if (shouldBeLink) {
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)('a', {
          className:
            'nextjs-container-build-error-version-status dialog-exclude-closing-from-outside-click',
          target: '_blank',
          rel: 'noopener noreferrer',
          href: 'https://nextjs.org/docs/messages/version-staleness',
          children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(Eclipse, {
              className: (0, _cx.cx)('version-staleness-indicator', indicatorClass),
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
              'data-nextjs-version-checker': true,
              title: title,
              children: text,
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
              className: (0, _cx.cx)(isTurbopack && 'turbopack-text'),
              children: bundlerName,
            }),
          ],
        });
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('span', {
        className:
          'nextjs-container-build-error-version-status dialog-exclude-closing-from-outside-click',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)(Eclipse, {
            className: (0, _cx.cx)('version-staleness-indicator', indicatorClass),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
            'data-nextjs-version-checker': true,
            title: title,
            children: text,
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('span', {
            className: (0, _cx.cx)(isTurbopack && 'turbopack-text'),
            children: bundlerName,
          }),
        ],
      });
    }
    function getStaleness(param) {
      let { installed, staleness, expected } = param;
      let text = '';
      let title = '';
      let indicatorClass = '';
      const versionLabel = 'Next.js ' + installed;
      switch (staleness) {
        case 'newer-than-npm':
        case 'fresh':
          text = versionLabel;
          title = 'Latest available version is detected (' + installed + ').';
          indicatorClass = 'fresh';
          break;
        case 'stale-patch':
        case 'stale-minor':
          text = '' + versionLabel + ' (stale)';
          title =
            'There is a newer version (' +
            expected +
            ') available, upgrade recommended! ';
          indicatorClass = 'stale';
          break;
        case 'stale-major': {
          text = '' + versionLabel + ' (outdated)';
          title =
            'An outdated version detected (latest is ' +
            expected +
            '), upgrade is highly recommended!';
          indicatorClass = 'outdated';
          break;
        }
        case 'stale-prerelease': {
          text = '' + versionLabel + ' (stale)';
          title =
            'There is a newer canary version (' +
            expected +
            ') available, please upgrade! ';
          indicatorClass = 'stale';
          break;
        }
        case 'unknown':
          text = '' + versionLabel + ' (unknown)';
          title = 'No Next.js version data was found.';
          indicatorClass = 'unknown';
          break;
        default:
          break;
      }
      return {
        text,
        indicatorClass,
        title,
      };
    }
    const styles =
      '\n  .nextjs-container-build-error-version-status {\n    -webkit-font-smoothing: antialiased;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    gap: 4px;\n\n    height: var(--size-26);\n    padding: 6px 8px 6px 6px;\n    background: var(--color-background-100);\n    background-clip: padding-box;\n    border: 1px solid var(--color-gray-alpha-400);\n    box-shadow: var(--shadow-small);\n    border-radius: var(--rounded-full);\n\n    color: var(--color-gray-900);\n    font-size: var(--size-12);\n    font-weight: 500;\n    line-height: var(--size-16);\n  }\n\n  a.nextjs-container-build-error-version-status {\n    text-decoration: none;\n    color: var(--color-gray-900);\n\n    &:hover {\n      background: var(--color-gray-100);\n    }\n\n    &:focus {\n      outline: var(--focus-ring);\n    }\n  }\n\n  .version-staleness-indicator.fresh {\n    fill: var(--color-green-800);\n    stroke: var(--color-green-300);\n  }\n  .version-staleness-indicator.stale {\n    fill: var(--color-amber-800);\n    stroke: var(--color-amber-300);\n  }\n  .version-staleness-indicator.outdated {\n    fill: var(--color-red-800);\n    stroke: var(--color-red-300);\n  }\n  .version-staleness-indicator.unknown {\n    fill: var(--color-gray-800);\n    stroke: var(--color-gray-300);\n  }\n\n  .nextjs-container-build-error-version-status > .turbopack-text {\n    background: linear-gradient(\n      to right,\n      var(--color-turbopack-text-red) 0%,\n      var(--color-turbopack-text-blue) 100%\n    );\n    background-clip: text;\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n  }\n';
    function Eclipse(param) {
      let { className } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '14',
        height: '14',
        viewBox: '0 0 14 14',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('circle', {
          className: className,
          cx: '7',
          cy: '7',
          r: '5.5',
          strokeWidth: '3',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=version-staleness-info.js.map
  },
  1095: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      BuildError: function () {
        return BuildError;
      },
      styles: function () {
        return styles;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _stripansi = /*#__PURE__*/ _interop_require_default._(
      __webpack_require__(7976)
    );
    const _terminal = __webpack_require__(6790);
    const _erroroverlaylayout = __webpack_require__(3060);
    const getErrorTextFromBuildErrorMessage = (multiLineMessage) => {
      const lines = multiLineMessage.split('\n');
      // The multi-line build error message looks like:
      // <file path>:<line number>:<column number>
      // <error message>
      // <error code frame of compiler or bundler>
      // e.g.
      // ./path/to/file.js:1:1
      // SyntaxError: ...
      // > 1 | con st foo =
      // ...
      return (0, _stripansi.default)(lines[1] || '');
    };
    const BuildError = function BuildError(param) {
      let { message, ...props } = param;
      const noop = (0, _react.useCallback)(() => {}, []);
      const error = Object.defineProperty(new Error(message), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: false,
        configurable: true,
      });
      const formattedMessage = (0, _react.useMemo)(
        () => getErrorTextFromBuildErrorMessage(message) || 'Failed to compile',
        [message]
      );
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_erroroverlaylayout.ErrorOverlayLayout, {
        errorType: 'Build Error',
        errorMessage: formattedMessage,
        onClose: noop,
        error: error,
        footerMessage:
          'This error occurred during the build process and can only be dismissed by fixing the error.',
        ...props,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_terminal.Terminal, {
          content: message,
        }),
      });
    };
    const styles = '';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=build-error.js.map
  },
  7709: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      Errors: function () {
        return Errors;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _overlay = __webpack_require__(6165);
    const _runtimeerror = __webpack_require__(4819);
    const _errorsource = __webpack_require__(4557);
    const _hotlinkedtext = __webpack_require__(3704);
    const _componentstackpseudohtml = __webpack_require__(1615);
    const _hydrationerrorinfo = __webpack_require__(4614);
    const _consoleerror = __webpack_require__(4980);
    const _errortelemetryutils = __webpack_require__(8053);
    const _erroroverlaylayout = __webpack_require__(3060);
    const _ishydrationerror = __webpack_require__(4291);
    function isNextjsLink(text) {
      return text.startsWith('https://nextjs.org');
    }
    function ErrorDescription(param) {
      let { error, hydrationWarning } = param;
      const unhandledErrorType = (0, _consoleerror.isConsoleError)(error)
        ? (0, _consoleerror.getConsoleErrorType)(error)
        : null;
      const isConsoleErrorStringMessage = unhandledErrorType === 'string';
      // If the error is:
      // - hydration warning
      // - captured console error or unhandled rejection
      // skip displaying the error name
      const title =
        isConsoleErrorStringMessage || hydrationWarning ? '' : error.name + ': ';
      const environmentName = 'environmentName' in error ? error.environmentName : '';
      const envPrefix = environmentName ? '[ ' + environmentName + ' ] ' : '';
      // The environment name will be displayed as a label, so remove it
      // from the message (e.g. "[ Server ] hello world" -> "hello world").
      let message = error.message;
      if (message.startsWith(envPrefix)) {
        message = message.slice(envPrefix.length);
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
          title,
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_hotlinkedtext.HotlinkedText, {
            text: hydrationWarning || message,
            matcher: isNextjsLink,
          }),
        ],
      });
    }
    function getErrorType(error) {
      if ((0, _consoleerror.isConsoleError)(error)) {
        return 'Console Error';
      }
      return 'Runtime Error';
    }
    function Errors(param) {
      let { runtimeErrors, debugInfo, onClose, ...props } = param;
      var _activeError_componentStackFrames;
      const dialogResizerRef = (0, _react.useRef)(null);
      (0, _react.useEffect)(() => {
        // Close the error overlay when pressing escape
        function handleKeyDown(event) {
          if (event.key === 'Escape') {
            onClose();
          }
        }
        document.addEventListener('keydown', handleKeyDown);
        return () => document.removeEventListener('keydown', handleKeyDown);
      }, [onClose]);
      const isLoading = (0, _react.useMemo)(() => {
        return runtimeErrors.length < 1;
      }, [runtimeErrors.length]);
      const [activeIdx, setActiveIndex] = (0, _react.useState)(0);
      const activeError = (0, _react.useMemo)(() => {
        var _runtimeErrors_activeIdx;
        return (_runtimeErrors_activeIdx = runtimeErrors[activeIdx]) != null
          ? _runtimeErrors_activeIdx
          : null;
      }, [activeIdx, runtimeErrors]);
      if (isLoading) {
        // TODO: better loading state
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_overlay.Overlay, {});
      }
      if (!activeError) {
        return null;
      }
      const error = activeError.error;
      const isServerError = ['server', 'edge-server'].includes(
        (0, _errorsource.getErrorSource)(error) || ''
      );
      const errorType = getErrorType(error);
      const errorDetails = error.details || {};
      const notes = errorDetails.notes || '';
      const [warningTemplate, serverContent, clientContent] = errorDetails.warning || [
        null,
        '',
        '',
      ];
      const hydrationErrorType = (0, _hydrationerrorinfo.getHydrationWarningType)(
        warningTemplate
      );
      const hydrationWarning = warningTemplate
        ? warningTemplate
            .replace('%s', serverContent)
            .replace('%s', clientContent)
            .replace('%s', '') // remove the %s for stack
            .replace(/%s$/, '') // If there's still a %s at the end, remove it
            .replace(/^Warning: /, '')
            .replace(/^Error: /, '')
        : null;
      const errorCode = (0, _errortelemetryutils.extractNextErrorCode)(error);
      const footerMessage = isServerError
        ? 'This error happened while generating the page. Any console logs will be displayed in the terminal window.'
        : undefined;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_erroroverlaylayout.ErrorOverlayLayout, {
        errorCode: errorCode,
        errorType: errorType,
        errorMessage: /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorDescription, {
          error: error,
          hydrationWarning: hydrationWarning,
        }),
        onClose: isServerError ? undefined : onClose,
        debugInfo: debugInfo,
        error: error,
        runtimeErrors: runtimeErrors,
        activeIdx: activeIdx,
        setActiveIndex: setActiveIndex,
        footerMessage: footerMessage,
        dialogResizerRef: dialogResizerRef,
        ...props,
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
            className: 'error-overlay-notes-container',
            children: [
              notes
                ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
                      id: 'nextjs__container_errors__notes',
                      className: 'nextjs__container_errors__notes',
                      children: notes,
                    }),
                  })
                : null,
              hydrationWarning
                ? /*#__PURE__*/ (0, _jsxruntime.jsx)('p', {
                    id: 'nextjs__container_errors__link',
                    className: 'nextjs__container_errors__link',
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(
                      _hotlinkedtext.HotlinkedText,
                      {
                        text:
                          'See more info here: ' +
                          _ishydrationerror.NEXTJS_HYDRATION_ERROR_LINK,
                      }
                    ),
                  })
                : null,
            ],
          }),
          hydrationWarning &&
          (((_activeError_componentStackFrames = activeError.componentStackFrames) == null
            ? void 0
            : _activeError_componentStackFrames.length) ||
            !!errorDetails.reactOutputComponentDiff)
            ? /*#__PURE__*/ (0, _jsxruntime.jsx)(
                _componentstackpseudohtml.PseudoHtmlDiff,
                {
                  className: 'nextjs__container_errors__component-stack',
                  hydrationMismatchType: hydrationErrorType,
                  firstContent: serverContent,
                  secondContent: clientContent,
                  reactOutputComponentDiff: errorDetails.reactOutputComponentDiff || '',
                }
              )
            : null,
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {
            fallback: /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
              'data-nextjs-error-suspended': true,
            }),
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(
              _runtimeerror.RuntimeError,
              {
                error: activeError,
                dialogResizerRef: dialogResizerRef,
              },
              activeError.id.toString()
            ),
          }),
        ],
      });
    }
    const styles =
      '\n  .nextjs-error-with-static {\n    bottom: calc(16px * 4.5);\n  }\n  p.nextjs__container_errors__link {\n    font-size: var(--size-14);\n  }\n  p.nextjs__container_errors__notes {\n    color: var(--color-stack-notes);\n    font-size: var(--size-14);\n    line-height: 1.5;\n  }\n  .nextjs-container-errors-body > h2:not(:first-child) {\n    margin-top: calc(16px + 8px);\n  }\n  .nextjs-container-errors-body > h2 {\n    color: var(--color-title-color);\n    margin-bottom: 8px;\n    font-size: var(--size-20);\n  }\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: 8px;\n  }\n  .nextjs-toast-hide-button {\n    margin-left: 24px;\n    border: none;\n    background: none;\n    color: var(--color-ansi-bright-white);\n    padding: 0;\n    transition: opacity 0.25s ease;\n    opacity: 0.7;\n  }\n  .nextjs-toast-hide-button:hover {\n    opacity: 1;\n  }\n  .nextjs__container_errors_inspect_copy_button {\n    cursor: pointer;\n    background: none;\n    border: none;\n    color: var(--color-ansi-bright-white);\n    font-size: var(--size-24);\n    padding: 0;\n    margin: 0;\n    margin-left: 8px;\n    transition: opacity 0.25s ease;\n  }\n  .nextjs__container_errors__error_title {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin-bottom: 14px;\n  }\n  .error-overlay-notes-container {\n    margin: 8px 2px;\n  }\n  .error-overlay-notes-container p {\n    white-space: pre-wrap;\n  }\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=errors.js.map
  },
  1615: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      PSEUDO_HTML_DIFF_STYLES: function () {
        return PSEUDO_HTML_DIFF_STYLES;
      },
      PseudoHtmlDiff: function () {
        return _diffview.PseudoHtmlDiff;
      },
    });
    const _diffview = __webpack_require__(9976);
    const PSEUDO_HTML_DIFF_STYLES =
      "\n  [data-nextjs-container-errors-pseudo-html] {\n    padding: 8px 0;\n    margin: 8px 0;\n    border: 1px solid var(--color-gray-400);\n    background: var(--color-background-200);\n    color: var(--color-syntax-constant);\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-12);\n    line-height: 1.33em; /* 16px in 12px font size */\n    border-radius: var(--rounded-md-2);\n  }\n  [data-nextjs-container-errors-pseudo-html-line] {\n    display: inline-block;\n    width: 100%;\n    padding-left: 40px;\n    line-height: calc(5 / 3);\n  }\n  [data-nextjs-container-errors-pseudo-html--diff='error'] {\n    background: var(--color-amber-100);\n    box-shadow: 2px 0 0 0 var(--color-amber-900) inset;\n    font-weight: bold;\n  }\n  [data-nextjs-container-errors-pseudo-html-collapse-button] {\n    all: unset;\n    margin-left: 12px;\n    &:focus {\n      outline: none;\n    }\n  }\n  [data-nextjs-container-errors-pseudo-html--diff='add'] {\n    background: var(--color-green-300);\n  }\n  [data-nextjs-container-errors-pseudo-html-line-sign] {\n    margin-left: calc(24px * -1);\n    margin-right: 24px;\n  }\n  [data-nextjs-container-errors-pseudo-html--diff='add']\n    [data-nextjs-container-errors-pseudo-html-line-sign] {\n    color: var(--color-green-900);\n  }\n  [data-nextjs-container-errors-pseudo-html--diff='remove'] {\n    background: var(--color-red-300);\n  }\n  [data-nextjs-container-errors-pseudo-html--diff='remove']\n    [data-nextjs-container-errors-pseudo-html-line-sign] {\n    color: var(--color-red-900);\n    margin-left: calc(24px * -1);\n    margin-right: 24px;\n  }\n  [data-nextjs-container-errors-pseudo-html--diff='error']\n    [data-nextjs-container-errors-pseudo-html-line-sign] {\n    color: var(--color-amber-900);\n  }\n  \n  [data-nextjs-container-errors-pseudo-html--hint] {\n    display: inline-block;\n    font-size: 0;\n    height: 0;\n  }\n  [data-nextjs-container-errors-pseudo-html--tag-adjacent='false'] {\n    color: var(--color-accents-1);\n  }\n  .nextjs__container_errors__component-stack {\n    margin: 0;\n  }\n  [data-nextjs-container-errors-pseudo-html-collapse='true']\n    .nextjs__container_errors__component-stack\n    code {\n    max-height: 120px;\n    mask-image: linear-gradient(to bottom,rgba(0,0,0,0) 0%,black 10%);\n    padding-bottom: 40px;\n  }\n  .nextjs__container_errors__component-stack code {\n    display: block;\n    width: 100%;\n    white-space: pre-wrap;\n    scroll-snap-type: y mandatory;\n    overflow-y: hidden;\n  }\n  [data-nextjs-container-errors-pseudo-html--diff] {\n    scroll-snap-align: center;\n  }\n  .error-overlay-hydration-error-diff-plus-icon {\n    color: var(--color-green-900);\n  }\n  .error-overlay-hydration-error-diff-minus-icon {\n    color: var(--color-red-900);\n  }\n";
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=component-stack-pseudo-html.js.map
  },
  4819: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      RuntimeError: function () {
        return RuntimeError;
      },
      styles: function () {
        return styles;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _codeframe = __webpack_require__(8467);
    const _callstack = __webpack_require__(3498);
    const _componentstackpseudohtml = __webpack_require__(1615);
    const _geterrorbytype = __webpack_require__(8597);
    function RuntimeError(param) {
      let { error, dialogResizerRef } = param;
      const frames = (0, _geterrorbytype.useFrames)(error);
      const firstFrame = (0, _react.useMemo)(() => {
        const firstFirstPartyFrameIndex = frames.findIndex(
          (entry) =>
            !entry.ignored &&
            Boolean(entry.originalCodeFrame) &&
            Boolean(entry.originalStackFrame)
        );
        var _frames_firstFirstPartyFrameIndex;
        return (_frames_firstFirstPartyFrameIndex = frames[firstFirstPartyFrameIndex]) !=
          null
          ? _frames_firstFirstPartyFrameIndex
          : null;
      }, [frames]);
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
          firstFrame &&
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_codeframe.CodeFrame, {
              stackFrame: firstFrame.originalStackFrame,
              codeFrame: firstFrame.originalCodeFrame,
            }),
          frames.length > 0 &&
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_callstack.CallStack, {
              dialogResizerRef: dialogResizerRef,
              frames: frames,
            }),
        ],
      });
    }
    const styles = '\n  ' + _componentstackpseudohtml.PSEUDO_HTML_DIFF_STYLES + '\n';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=index.js.map
  },
  6203: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'RenderError', {
      enumerable: true,
      get: function () {
        return RenderError;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _react = __webpack_require__(863);
    const _shared = __webpack_require__(6172);
    const _geterrorbytype = __webpack_require__(8597);
    function getErrorSignature(ev) {
      const { event } = ev;
      // eslint-disable-next-line default-case -- TypeScript checks this
      switch (event.type) {
        case _shared.ACTION_UNHANDLED_ERROR:
        case _shared.ACTION_UNHANDLED_REJECTION: {
          return (
            event.reason.name + '::' + event.reason.message + '::' + event.reason.stack
          );
        }
      }
    }
    const RenderError = (props) => {
      const { state } = props;
      const isBuildError = !!state.buildError;
      if (isBuildError) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(RenderBuildError, {
          ...props,
        });
      } else {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(RenderRuntimeError, {
          ...props,
        });
      }
    };
    const RenderRuntimeError = (param) => {
      let { children, state, isAppDir } = param;
      const { errors } = state;
      const [lookups, setLookups] = (0, _react.useState)({});
      const [runtimeErrors, nextError] = (0, _react.useMemo)(() => {
        let ready = [];
        let next = null;
        // Ensure errors are displayed in the order they occurred in:
        for (let idx = 0; idx < errors.length; ++idx) {
          const e = errors[idx];
          const { id } = e;
          if (id in lookups) {
            ready.push(lookups[id]);
            continue;
          }
          // Check for duplicate errors
          if (idx > 0) {
            const prev = errors[idx - 1];
            if (getErrorSignature(prev) === getErrorSignature(e)) {
              continue;
            }
          }
          next = e;
          break;
        }
        return [ready, next];
      }, [errors, lookups]);
      (0, _react.useEffect)(() => {
        if (nextError == null) {
          return;
        }
        let mounted = true;
        (0, _geterrorbytype.getErrorByType)(nextError, isAppDir).then((resolved) => {
          if (mounted) {
            // We don't care if the desired error changed while we were resolving,
            // thus we're not tracking it using a ref. Once the work has been done,
            // we'll store it.
            setLookups((m) => ({
              ...m,
              [resolved.id]: resolved,
            }));
          }
        });
        return () => {
          mounted = false;
        };
      }, [nextError, isAppDir]);
      const totalErrorCount = errors.filter((err, idx) => {
        const prev = errors[idx - 1];
        // Check for duplicates
        if (idx > 0) return getErrorSignature(prev) !== getErrorSignature(err);
        return true;
      }).length;
      return children({
        runtimeErrors,
        totalErrorCount,
      });
    };
    const RenderBuildError = (param) => {
      let { children } = param;
      return children({
        runtimeErrors: [],
        // Build errors and missing root layout tags persist until fixed,
        // so we can set a fixed error count of 1
        totalErrorCount: 1,
      });
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=render-error.js.map
  },
  124: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'DevOverlay', {
      enumerable: true,
      get: function () {
        return DevOverlay;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    const _shadowportal = __webpack_require__(1128);
    const _base = __webpack_require__(6696);
    const _componentstyles = __webpack_require__(1107);
    const _cssreset = __webpack_require__(4345);
    const _colors = __webpack_require__(6455);
    const _erroroverlay = __webpack_require__(8748);
    const _devtoolsindicator = __webpack_require__(6862);
    const _rendererror = __webpack_require__(6203);
    const _darktheme = __webpack_require__(231);
    const _preferences = __webpack_require__(8708);
    function DevOverlay(param) {
      let { state, isErrorOverlayOpen, setIsErrorOverlayOpen } = param;
      const [scale, setScale] = (0, _preferences.useDevToolsScale)();
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_shadowportal.ShadowPortal, {
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_cssreset.CssReset, {}),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_base.Base, {
            scale: scale,
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_colors.Colors, {}),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_componentstyles.ComponentStyles, {}),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_darktheme.DarkTheme, {}),
          /*#__PURE__*/ (0, _jsxruntime.jsx)(_rendererror.RenderError, {
            state: state,
            isAppDir: true,
            children: (param) => {
              let { runtimeErrors, totalErrorCount } = param;
              const isBuildError = state.buildError !== null;
              return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                children: [
                  state.showIndicator &&
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(
                      _devtoolsindicator.DevToolsIndicator,
                      {
                        scale: scale,
                        setScale: setScale,
                        state: state,
                        errorCount: totalErrorCount,
                        isBuildError: isBuildError,
                        setIsErrorOverlayOpen: setIsErrorOverlayOpen,
                      }
                    ),
                  /*#__PURE__*/ (0, _jsxruntime.jsx)(_erroroverlay.ErrorOverlay, {
                    state: state,
                    runtimeErrors: runtimeErrors,
                    isErrorOverlayOpen: isErrorOverlayOpen,
                    setIsErrorOverlayOpen: setIsErrorOverlayOpen,
                  }),
                ],
              });
            },
          }),
        ],
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dev-overlay.js.map
  },
  7000: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'useDelayedRender', {
      enumerable: true,
      get: function () {
        return useDelayedRender;
      },
    });
    const _react = __webpack_require__(863);
    function useDelayedRender(active, options) {
      if (active === void 0) active = false;
      if (options === void 0) options = {};
      const [mounted, setMounted] = (0, _react.useState)(active);
      const [rendered, setRendered] = (0, _react.useState)(false);
      const renderTimerRef = (0, _react.useRef)(null);
      const unmountTimerRef = (0, _react.useRef)(null);
      const clearTimers = (0, _react.useCallback)(() => {
        if (renderTimerRef.current !== null) {
          window.clearTimeout(renderTimerRef.current);
          renderTimerRef.current = null;
        }
        if (unmountTimerRef.current !== null) {
          window.clearTimeout(unmountTimerRef.current);
          unmountTimerRef.current = null;
        }
      }, []);
      (0, _react.useEffect)(() => {
        const { enterDelay = 1, exitDelay = 0 } = options;
        clearTimers();
        if (active) {
          setMounted(true);
          if (enterDelay <= 0) {
            setRendered(true);
          } else {
            renderTimerRef.current = window.setTimeout(() => {
              setRendered(true);
            }, enterDelay);
          }
        } else {
          setRendered(false);
          if (exitDelay <= 0) {
            setMounted(false);
          } else {
            unmountTimerRef.current = window.setTimeout(() => {
              setMounted(false);
            }, exitDelay);
          }
        }
        return clearTimers;
      }, [active, options, clearTimers]);
      return {
        mounted,
        rendered,
      };
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=use-delayed-render.js.map
  },
  465: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'useMeasureHeight', {
      enumerable: true,
      get: function () {
        return useMeasureHeight;
      },
    });
    const _react = __webpack_require__(863);
    function useMeasureHeight(ref) {
      const [pristine, setPristine] = (0, _react.useState)(true);
      const [height, setHeight] = (0, _react.useState)(0);
      (0, _react.useEffect)(() => {
        const el = ref.current;
        if (!el) {
          return;
        }
        const observer = new ResizeObserver(() => {
          const { height: h } = el.getBoundingClientRect();
          setHeight((prevHeight) => {
            if (prevHeight !== 0) {
              setPristine(false);
            }
            return h;
          });
        });
        observer.observe(el);
        return () => {
          observer.disconnect();
          setPristine(true);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, []);
      return [height, pristine];
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=use-measure-height.js.map
  },
  694: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'useOnClickOutside', {
      enumerable: true,
      get: function () {
        return useOnClickOutside;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    function useOnClickOutside(el, cssSelectorsToExclude, handler) {
      _react.useEffect(
        {
          'useOnClickOutside.useEffect': () => {
            if (el == null || handler == null) {
              return;
            }
            const listener = {
              'useOnClickOutside.useEffect.listener': (e) => {
                // Do nothing if clicking ref's element or descendent elements
                if (!el || el.contains(e.target)) {
                  return;
                }
                if (
                  cssSelectorsToExclude.some(
                    {
                      'useOnClickOutside.useEffect.listener': (cssSelector) =>
                        e.target.closest(cssSelector),
                    }['useOnClickOutside.useEffect.listener']
                  )
                ) {
                  return;
                }
                handler(e);
              },
            }['useOnClickOutside.useEffect.listener'];
            const root = el.getRootNode();
            root.addEventListener('mouseup', listener);
            root.addEventListener('touchend', listener, {
              passive: false,
            });
            return {
              'useOnClickOutside.useEffect': function () {
                root.removeEventListener('mouseup', listener);
                root.removeEventListener('touchend', listener);
              },
            }['useOnClickOutside.useEffect'];
          },
        }['useOnClickOutside.useEffect'],
        [handler, el, cssSelectorsToExclude]
      );
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=use-on-click-outside.js.map
  },
  8186: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'CollapseIcon', {
      enumerable: true,
      get: function () {
        return CollapseIcon;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function CollapseIcon(param) {
      let { collapsed } = param === void 0 ? {} : param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        'data-nextjs-call-stack-chevron-icon': true,
        'data-collapsed': collapsed,
        width: '16',
        height: '16',
        fill: 'none',
        ...(typeof collapsed === 'boolean'
          ? {
              style: {
                transform: collapsed ? undefined : 'rotate(90deg)',
              },
            }
          : {}),
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          style: {
            fill: 'var(--color-font)',
          },
          fillRule: 'evenodd',
          d: 'm6.75 3.94.53.53 2.824 2.823a1 1 0 0 1 0 1.414L7.28 11.53l-.53.53L5.69 11l.53-.53L8.69 8 6.22 5.53 5.69 5l1.06-1.06Z',
          clipRule: 'evenodd',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=collapse-icon.js.map
  },
  8593: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return DarkIcon;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function DarkIcon() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        'data-testid': 'geist-icon',
        height: '16',
        strokeLinejoin: 'round',
        viewBox: '0 0 16 16',
        width: '16',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M1.5 8.00005C1.5 5.53089 2.99198 3.40932 5.12349 2.48889C4.88136 3.19858 4.75 3.95936 4.75 4.7501C4.75 8.61609 7.88401 11.7501 11.75 11.7501C11.8995 11.7501 12.048 11.7454 12.1953 11.7361C11.0955 13.1164 9.40047 14.0001 7.5 14.0001C4.18629 14.0001 1.5 11.3138 1.5 8.00005ZM6.41706 0.577759C2.78784 1.1031 0 4.22536 0 8.00005C0 12.1422 3.35786 15.5001 7.5 15.5001C10.5798 15.5001 13.2244 13.6438 14.3792 10.9921L13.4588 9.9797C12.9218 10.155 12.3478 10.2501 11.75 10.2501C8.71243 10.2501 6.25 7.78767 6.25 4.7501C6.25 3.63431 6.58146 2.59823 7.15111 1.73217L6.41706 0.577759ZM13.25 1V1.75V2.75L14.25 2.75H15V4.25H14.25H13.25V5.25V6H11.75V5.25V4.25H10.75L10 4.25V2.75H10.75L11.75 2.75V1.75V1H13.25Z',
          fill: 'currentColor',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dark-icon.js.map
  },
  8540: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ExternalIcon: function () {
        return ExternalIcon;
      },
      SourceMappingErrorIcon: function () {
        return SourceMappingErrorIcon;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function ExternalIcon(props) {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: '16',
        height: '16',
        viewBox: '0 0 16 16',
        fill: 'none',
        ...props,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          fill: 'currentColor',
          d: 'M11.5 9.75V11.25C11.5 11.3881 11.3881 11.5 11.25 11.5H4.75C4.61193 11.5 4.5 11.3881 4.5 11.25L4.5 4.75C4.5 4.61193 4.61193 4.5 4.75 4.5H6.25H7V3H6.25H4.75C3.7835 3 3 3.7835 3 4.75V11.25C3 12.2165 3.7835 13 4.75 13H11.25C12.2165 13 13 12.2165 13 11.25V9.75V9H11.5V9.75ZM8.5 3H9.25H12.2495C12.6637 3 12.9995 3.33579 12.9995 3.75V6.75V7.5H11.4995V6.75V5.56066L8.53033 8.52978L8 9.06011L6.93934 7.99945L7.46967 7.46912L10.4388 4.5H9.25H8.5V3Z',
        }),
      });
    }
    function SourceMappingErrorIcon(props) {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        height: '16',
        strokeLinejoin: 'round',
        viewBox: '-4 -4 24 24',
        width: '16',
        ...props,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M8.55846 2H7.44148L1.88975 13.5H14.1102L8.55846 2ZM9.90929 1.34788C9.65902 0.829456 9.13413 0.5 8.55846 0.5H7.44148C6.86581 0.5 6.34092 0.829454 6.09065 1.34787L0.192608 13.5653C-0.127943 14.2293 0.355835 15 1.09316 15H14.9068C15.6441 15 16.1279 14.2293 15.8073 13.5653L9.90929 1.34788ZM8.74997 4.75V5.5V8V8.75H7.24997V8V5.5V4.75H8.74997ZM7.99997 12C8.55226 12 8.99997 11.5523 8.99997 11C8.99997 10.4477 8.55226 10 7.99997 10C7.44769 10 6.99997 10.4477 6.99997 11C6.99997 11.5523 7.44769 12 7.99997 12Z',
          fill: 'currentColor',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=external.js.map
  },
  9269: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return EyeIcon;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function EyeIcon() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: '16',
        height: '16',
        fill: 'none',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'm.191 2.063.56.498 13.5 12 .561.498.997-1.121-.56-.498-1.81-1.608 2.88-3.342v-.98l-3.204-3.72C10.645.923 6.365.686 3.594 3.08L1.748 1.44 1.188.94.19 2.063ZM14.761 8l-2.442 2.836-1.65-1.466a3.001 3.001 0 0 0-4.342-3.86l-1.6-1.422a5.253 5.253 0 0 1 7.251.682L14.76 8ZM7.526 6.576l1.942 1.727a1.499 1.499 0 0 0-1.942-1.727Zm-7.845.935 1.722-2 1.137.979L1.24 8l2.782 3.23A5.25 5.25 0 0 0 9.9 12.703l.54 1.4a6.751 6.751 0 0 1-7.555-1.892L-.318 8.49v-.98Z',
          clipRule: 'evenodd',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=eye-icon.js.map
  },
  7378: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'FileIcon', {
      enumerable: true,
      get: function () {
        return FileIcon;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function FileIcon(param) {
      let { lang } = param;
      if (!lang) return /*#__PURE__*/ (0, _jsxruntime.jsx)(File, {});
      switch (lang.toLowerCase()) {
        case 'jsx':
        case 'tsx':
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(React, {});
        case 'ts':
        case 'typescript':
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(Ts, {});
        case 'javascript':
        case 'js':
        case 'mjs':
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(Js, {});
        case 'json':
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(Json, {});
        default:
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(File, {});
      }
    }
    function Json() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        clipRule: 'evenodd',
        fillRule: 'evenodd',
        height: '16',
        viewBox: '0 0 1321.45 1333.33',
        width: '16',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          d: 'M221.37 618.44h757.94V405.15H755.14c-23.5 0-56.32-12.74-71.82-28.24-15.5-15.5-25-43.47-25-66.97V82.89H88.39c-1.99 0-3.49 1-4.49 2-1.5 1-2 2.5-2 4.5v1155.04c0 1.5 1 3.5 2 4.5 1 1.49 3 1.99 4.49 1.99H972.8c2 0 1.89-.99 2.89-1.99 1.5-1 3.61-3 3.61-4.5v-121.09H221.36c-44.96 0-82-36.9-82-81.99V700.44c0-45.1 36.9-82 82-82zm126.51 117.47h75.24v146.61c0 30.79-2.44 54.23-7.33 70.31-4.92 16.03-14.8 29.67-29.65 40.85-14.86 11.12-33.91 16.72-57.05 16.72-24.53 0-43.51-3.71-56.94-11.06-13.5-7.36-23.89-18.1-31.23-32.3-7.35-14.14-11.69-31.67-12.99-52.53l71.5-10.81c.11 11.81 1.07 20.61 2.81 26.33 1.76 5.78 4.75 10.37 9 13.95 2.87 2.33 6.94 3.46 12.25 3.46 8.4 0 14.58-3.46 18.53-10.37 3.9-6.92 5.87-18.6 5.87-35V735.92zm112.77 180.67l71.17-4.97c1.54 12.81 4.69 22.62 9.44 29.28 7.74 10.88 18.74 16.34 33.09 16.34 10.68 0 18.93-2.76 24.68-8.36 5.81-5.58 8.7-12.07 8.7-19.41 0-6.97-2.71-13.26-8.2-18.79-5.47-5.53-18.23-10.68-38.28-15.65-32.89-8.17-56.27-19.1-70.26-32.74-14.12-13.57-21.18-30.92-21.18-52.03 0-13.83 3.61-26.89 10.85-39.21 7.22-12.38 18.07-22.06 32.59-29.09 14.52-7.04 34.4-10.56 59.65-10.56 31 0 54.62 6.41 70.88 19.29 16.28 12.81 25.92 33.24 29.04 61.27l-70.5 4.65c-1.87-12.25-5.81-21.17-11.81-26.7-6.05-5.6-14.35-8.36-24.9-8.36-8.71 0-15.31 2.07-19.73 6.16-4.4 4.09-6.59 9.12-6.59 15.02 0 4.27 1.81 8.11 5.37 11.57 3.45 3.59 11.8 6.85 25.02 9.93 32.75 7.86 56.2 15.84 70.31 23.87 14.18 8.05 24.52 17.98 30.96 29.92 6.44 11.88 9.66 25.2 9.66 39.96 0 17.29-4.3 33.24-12.88 47.89-8.63 14.58-20.61 25.7-36.08 33.24-15.41 7.54-34.85 11.31-58.33 11.31-41.24 0-69.81-8.86-85.68-26.52-15.88-17.65-24.85-40.09-26.96-67.3zm248.74-45.5c0-44.05 11.02-78.36 33.09-102.87 22.09-24.57 52.82-36.82 92.24-36.82 40.38 0 71.5 12.07 93.34 36.13 21.86 24.13 32.77 57.94 32.77 101.37 0 31.54-4.75 57.36-14.3 77.54-9.54 20.18-23.37 35.89-41.4 47.13-18.07 11.24-40.55 16.84-67.48 16.84-27.33 0-49.99-4.83-67.94-14.52-17.92-9.74-32.49-25.07-43.62-46.06-11.13-20.92-16.72-47.19-16.72-78.74zm74.89.19c0 27.21 4.57 46.81 13.68 58.68 9.13 11.88 21.57 17.85 37.26 17.85 16.1 0 28.65-5.84 37.45-17.47 8.87-11.68 13.28-32.54 13.28-62.77 0-25.39-4.63-43.92-13.84-55.61-9.26-11.76-21.75-17.6-37.56-17.6-15.13 0-27.34 5.97-36.49 17.85-9.21 11.88-13.78 31.61-13.78 59.07zm209.08-135.36h69.99l90.98 149.05V735.91h70.83v269.96h-70.83l-90.48-148.24v148.24h-70.49V735.91zm67.71-117.47h178.37c45.1 0 82 37.04 82 82v340.91c0 44.96-37.03 81.99-82 81.99h-178.37v147c0 17.5-6.99 32.99-18.5 44.5-11.5 11.49-27 18.5-44.5 18.5H62.97c-17.5 0-32.99-7-44.5-18.5-11.49-11.5-18.5-27-18.5-44.5V63.49c0-17.5 7-33 18.5-44.5S45.97.49 62.97.49H700.1c1.5-.5 3-.5 4.5-.5 7 0 14 3 19 7.49h1c1 .5 1.5 1 2.5 2l325.46 329.47c5.5 5.5 9.5 13 9.5 21.5 0 2.5-.5 4.5-1 7v250.98zM732.61 303.47V96.99l232.48 235.47H761.6c-7.99 0-14.99-3.5-20.5-8.49-4.99-5-8.49-12.5-8.49-20.5z',
          fill: 'currentColor',
        }),
      });
    }
    function Js() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        height: '16',
        viewBox: '0 0 50 50',
        width: '16',
        xmlns: 'http://www.w3.org/2000/svg',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          d: 'M 43.335938 4 L 6.667969 4 C 5.195313 4 4 5.195313 4 6.667969 L 4 43.332031 C 4 44.804688 5.195313 46 6.667969 46 L 43.332031 46 C 44.804688 46 46 44.804688 46 43.335938 L 46 6.667969 C 46 5.195313 44.804688 4 43.335938 4 Z M 27 36.183594 C 27 40.179688 24.65625 42 21.234375 42 C 18.140625 42 15.910156 39.925781 15 38 L 18.144531 36.097656 C 18.75 37.171875 19.671875 38 21 38 C 22.269531 38 23 37.503906 23 35.574219 L 23 23 L 27 23 Z M 35.675781 42 C 32.132813 42 30.121094 40.214844 29 38 L 32 36 C 32.816406 37.335938 33.707031 38.613281 35.589844 38.613281 C 37.171875 38.613281 38 37.824219 38 36.730469 C 38 35.425781 37.140625 34.960938 35.402344 34.199219 L 34.449219 33.789063 C 31.695313 32.617188 29.863281 31.148438 29.863281 28.039063 C 29.863281 25.179688 32.046875 23 35.453125 23 C 37.878906 23 39.621094 23.84375 40.878906 26.054688 L 37.910156 27.964844 C 37.253906 26.789063 36.550781 26.328125 35.453125 26.328125 C 34.335938 26.328125 33.628906 27.039063 33.628906 27.964844 C 33.628906 29.109375 34.335938 29.570313 35.972656 30.28125 L 36.925781 30.691406 C 40.171875 32.078125 42 33.496094 42 36.683594 C 42 40.117188 39.300781 42 35.675781 42 Z',
          fill: 'currentColor',
        }),
      });
    }
    function Ts() {
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('svg', {
        fill: 'none',
        height: '14',
        viewBox: '0 0 512 512',
        width: '14',
        xmlns: 'http://www.w3.org/2000/svg',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('rect', {
            fill: 'currentColor',
            height: '512',
            rx: '50',
            width: '512',
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('rect', {
            fill: 'currentColor',
            height: '512',
            rx: '50',
            width: '512',
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
            clipRule: 'evenodd',
            d: 'm316.939 407.424v50.061c8.138 4.172 17.763 7.3 28.875 9.386s22.823 3.129 35.135 3.129c11.999 0 23.397-1.147 34.196-3.442 10.799-2.294 20.268-6.075 28.406-11.342 8.138-5.266 14.581-12.15 19.328-20.65s7.121-19.007 7.121-31.522c0-9.074-1.356-17.026-4.069-23.857s-6.625-12.906-11.738-18.225c-5.112-5.319-11.242-10.091-18.389-14.315s-15.207-8.213-24.18-11.967c-6.573-2.712-12.468-5.345-17.685-7.9-5.217-2.556-9.651-5.163-13.303-7.822-3.652-2.66-6.469-5.476-8.451-8.448-1.982-2.973-2.974-6.336-2.974-10.091 0-3.441.887-6.544 2.661-9.308s4.278-5.136 7.512-7.118c3.235-1.981 7.199-3.52 11.894-4.615 4.696-1.095 9.912-1.642 15.651-1.642 4.173 0 8.581.313 13.224.938 4.643.626 9.312 1.591 14.008 2.894 4.695 1.304 9.259 2.947 13.694 4.928 4.434 1.982 8.529 4.276 12.285 6.884v-46.776c-7.616-2.92-15.937-5.084-24.962-6.492s-19.381-2.112-31.066-2.112c-11.895 0-23.163 1.278-33.805 3.833s-20.006 6.544-28.093 11.967c-8.086 5.424-14.476 12.333-19.171 20.729-4.695 8.395-7.043 18.433-7.043 30.114 0 14.914 4.304 27.638 12.912 38.172 8.607 10.533 21.675 19.45 39.204 26.751 6.886 2.816 13.303 5.579 19.25 8.291s11.086 5.528 15.415 8.448c4.33 2.92 7.747 6.101 10.252 9.543 2.504 3.441 3.756 7.352 3.756 11.733 0 3.233-.783 6.231-2.348 8.995s-3.939 5.162-7.121 7.196-7.147 3.624-11.894 4.771c-4.748 1.148-10.303 1.721-16.668 1.721-10.851 0-21.597-1.903-32.24-5.71-10.642-3.806-20.502-9.516-29.579-17.13zm-84.159-123.342h64.22v-41.082h-179v41.082h63.906v182.918h50.874z',
            fill: 'var(--color-background-100)',
            fillRule: 'evenodd',
          }),
        ],
      });
    }
    function File() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '16',
        height: '17',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M14.5 7v7a2.5 2.5 0 0 1-2.5 2.5H4A2.5 2.5 0 0 1 1.5 14V.5h7.586a1 1 0 0 1 .707.293l4.414 4.414a1 1 0 0 1 .293.707V7zM13 7v7a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2h5v5h5zM9.5 2.621V5.5h2.879L9.5 2.621z',
          fill: 'currentColor',
        }),
      });
    }
    function React() {
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('svg', {
        height: '16',
        strokeLinejoin: 'round',
        viewBox: '0 0 16 16',
        width: '16',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('g', {
            clipPath: 'url(#file_react_clip0_872_3183)',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
              fillRule: 'evenodd',
              clipRule: 'evenodd',
              d: 'M4.5 1.93782C4.70129 1.82161 4.99472 1.7858 5.41315 1.91053C5.83298 2.03567 6.33139 2.31073 6.87627 2.73948C7.01136 2.84578 7.14803 2.96052 7.28573 3.08331C6.86217 3.53446 6.44239 4.04358 6.03752 4.60092C5.35243 4.67288 4.70164 4.78186 4.09916 4.92309C4.06167 4.74244 4.03064 4.56671 4.00612 4.39656C3.90725 3.71031 3.91825 3.14114 4.01979 2.71499C4.12099 2.29025 4.29871 2.05404 4.5 1.93782ZM7.49466 1.95361C7.66225 2.08548 7.83092 2.22804 7.99999 2.38067C8.16906 2.22804 8.33773 2.08548 8.50532 1.95361C9.10921 1.47842 9.71982 1.12549 10.3012 0.952202C10.8839 0.778496 11.4838 0.7738 12 1.0718C12.5161 1.3698 12.812 1.89169 12.953 2.48322C13.0936 3.07333 13.0932 3.77858 12.9836 4.53917C12.9532 4.75024 12.9141 4.9676 12.8665 5.19034C13.0832 5.26044 13.291 5.33524 13.489 5.41444C14.2025 5.69983 14.8134 6.05217 15.2542 6.46899C15.696 6.8868 16 7.404 16 8C16 8.596 15.696 9.11319 15.2542 9.53101C14.8134 9.94783 14.2025 10.3002 13.489 10.5856C13.291 10.6648 13.0832 10.7396 12.8665 10.8097C12.9141 11.0324 12.9532 11.2498 12.9837 11.4608C13.0932 12.2214 13.0936 12.9267 12.953 13.5168C12.812 14.1083 12.5161 14.6302 12 14.9282C11.4839 15.2262 10.8839 15.2215 10.3012 15.0478C9.71984 14.8745 9.10923 14.5216 8.50534 14.0464C8.33775 13.9145 8.16906 13.7719 7.99999 13.6193C7.83091 13.7719 7.66223 13.9145 7.49464 14.0464C6.89075 14.5216 6.28014 14.8745 5.69879 15.0478C5.11605 15.2215 4.51613 15.2262 3.99998 14.9282C3.48383 14.6302 3.18794 14.1083 3.047 13.5168C2.9064 12.9267 2.90674 12.2214 3.01632 11.4608C3.04673 11.2498 3.08586 11.0324 3.13351 10.8097C2.91679 10.7395 2.709 10.6648 2.511 10.5856C1.79752 10.3002 1.18658 9.94783 0.745833 9.53101C0.304028 9.11319 0 8.596 0 8C0 7.404 0.304028 6.8868 0.745833 6.46899C1.18658 6.05217 1.79752 5.69983 2.511 5.41444C2.709 5.33524 2.9168 5.26044 3.13352 5.19034C3.08587 4.9676 3.04675 4.75024 3.01634 4.53917C2.90676 3.77858 2.90642 3.07332 3.04702 2.48321C3.18796 1.89169 3.48385 1.3698 4 1.0718C4.51615 0.773798 5.11607 0.778495 5.69881 0.952201C6.28016 1.12549 6.89077 1.47841 7.49466 1.95361ZM7.36747 4.51025C7.57735 4.25194 7.78881 4.00927 7.99999 3.78356C8.21117 4.00927 8.42263 4.25194 8.63251 4.51025C8.42369 4.50346 8.21274 4.5 8 4.5C7.78725 4.5 7.5763 4.50345 7.36747 4.51025ZM8.71425 3.08331C9.13781 3.53447 9.55759 4.04358 9.96246 4.60092C10.6475 4.67288 11.2983 4.78186 11.9008 4.92309C11.9383 4.74244 11.9693 4.56671 11.9939 4.39657C12.0927 3.71031 12.0817 3.14114 11.9802 2.71499C11.879 2.29025 11.7013 2.05404 11.5 1.93782C11.2987 1.82161 11.0053 1.7858 10.5868 1.91053C10.167 2.03568 9.66859 2.31073 9.12371 2.73948C8.98862 2.84578 8.85196 2.96052 8.71425 3.08331ZM8 5.5C8.48433 5.5 8.95638 5.51885 9.41188 5.55456C9.67056 5.93118 9.9229 6.33056 10.1651 6.75C10.4072 7.16944 10.6269 7.58766 10.8237 7.99998C10.6269 8.41232 10.4072 8.83055 10.165 9.25C9.92288 9.66944 9.67053 10.0688 9.41185 10.4454C8.95636 10.4812 8.48432 10.5 8 10.5C7.51567 10.5 7.04363 10.4812 6.58813 10.4454C6.32945 10.0688 6.0771 9.66944 5.83494 9.25C5.59277 8.83055 5.37306 8.41232 5.17624 7.99998C5.37306 7.58765 5.59275 7.16944 5.83492 6.75C6.07708 6.33056 6.32942 5.93118 6.5881 5.55456C7.04361 5.51884 7.51566 5.5 8 5.5ZM11.0311 6.25C11.1375 6.43423 11.2399 6.61864 11.3385 6.80287C11.4572 6.49197 11.5616 6.18752 11.6515 5.89178C11.3505 5.82175 11.0346 5.75996 10.706 5.70736C10.8163 5.8848 10.9247 6.06576 11.0311 6.25ZM11.0311 9.75C11.1374 9.56576 11.2399 9.38133 11.3385 9.19709C11.4572 9.50801 11.5617 9.81246 11.6515 10.1082C11.3505 10.1782 11.0346 10.24 10.7059 10.2926C10.8162 10.1152 10.9247 9.93424 11.0311 9.75ZM11.9249 7.99998C12.2051 8.62927 12.4362 9.24738 12.6151 9.83977C12.7903 9.78191 12.958 9.72092 13.1176 9.65708C13.7614 9.39958 14.2488 9.10547 14.5671 8.80446C14.8843 8.50445 15 8.23243 15 8C15 7.76757 14.8843 7.49555 14.5671 7.19554C14.2488 6.89453 13.7614 6.60042 13.1176 6.34292C12.958 6.27907 12.7903 6.21808 12.6151 6.16022C12.4362 6.7526 12.2051 7.37069 11.9249 7.99998ZM9.96244 11.3991C10.6475 11.3271 11.2983 11.2181 11.9008 11.0769C11.9383 11.2576 11.9694 11.4333 11.9939 11.6034C12.0928 12.2897 12.0817 12.8589 11.9802 13.285C11.879 13.7098 11.7013 13.946 11.5 14.0622C11.2987 14.1784 11.0053 14.2142 10.5868 14.0895C10.167 13.9643 9.66861 13.6893 9.12373 13.2605C8.98863 13.1542 8.85196 13.0395 8.71424 12.9167C9.1378 12.4655 9.55758 11.9564 9.96244 11.3991ZM8.63249 11.4898C8.42262 11.7481 8.21116 11.9907 7.99999 12.2164C7.78881 11.9907 7.57737 11.7481 7.36749 11.4897C7.57631 11.4965 7.78726 11.5 8 11.5C8.21273 11.5 8.42367 11.4965 8.63249 11.4898ZM4.96891 9.75C5.07528 9.93424 5.18375 10.1152 5.29404 10.2926C4.9654 10.24 4.64951 10.1782 4.34844 10.1082C4.43833 9.81246 4.54276 9.508 4.66152 9.19708C4.76005 9.38133 4.86254 9.56575 4.96891 9.75ZM6.03754 11.3991C5.35244 11.3271 4.70163 11.2181 4.09914 11.0769C4.06165 11.2576 4.03062 11.4333 4.0061 11.6034C3.90723 12.2897 3.91823 12.8589 4.01977 13.285C4.12097 13.7098 4.29869 13.946 4.49998 14.0622C4.70127 14.1784 4.9947 14.2142 5.41313 14.0895C5.83296 13.9643 6.33137 13.6893 6.87625 13.2605C7.01135 13.1542 7.14802 13.0395 7.28573 12.9167C6.86217 12.4655 6.4424 11.9564 6.03754 11.3991ZM4.07507 7.99998C3.79484 8.62927 3.56381 9.24737 3.38489 9.83977C3.20969 9.78191 3.042 9.72092 2.88239 9.65708C2.23864 9.39958 1.75123 9.10547 1.43294 8.80446C1.11571 8.50445 1 8.23243 1 8C1 7.76757 1.11571 7.49555 1.43294 7.19554C1.75123 6.89453 2.23864 6.60042 2.88239 6.34292C3.042 6.27907 3.2097 6.21808 3.3849 6.16022C3.56383 6.75261 3.79484 7.37069 4.07507 7.99998ZM4.66152 6.80287C4.54277 6.49197 4.43835 6.18752 4.34846 5.89178C4.64952 5.82175 4.96539 5.75996 5.29402 5.70736C5.18373 5.8848 5.07526 6.06576 4.96889 6.25C4.86253 6.43423 4.76005 6.61864 4.66152 6.80287ZM9.25 8C9.25 8.69036 8.69036 9.25 8 9.25C7.30964 9.25 6.75 8.69036 6.75 8C6.75 7.30965 7.30964 6.75 8 6.75C8.69036 6.75 9.25 7.30965 9.25 8Z',
              fill: 'currentColor',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('defs', {
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('clipPath', {
              id: 'file_react_clip0_872_3183',
              children: /*#__PURE__*/ (0, _jsxruntime.jsx)('rect', {
                width: '16',
                height: '16',
                fill: 'white',
              }),
            }),
          }),
        ],
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=file.js.map
  },
  6149: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return GearIcon;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function GearIcon() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: '16',
        height: '16',
        viewBox: '0 0 20 20',
        fill: 'none',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'm9.7 3.736.045-.236h.51l.044.236a2.024 2.024 0 0 0 1.334 1.536c.19.066.375.143.554.23.618.301 1.398.29 2.03-.143l.199-.136.36.361-.135.199a2.024 2.024 0 0 0-.143 2.03c.087.179.164.364.23.554.224.65.783 1.192 1.536 1.334l.236.044v.51l-.236.044a2.024 2.024 0 0 0-1.536 1.334 4.95 4.95 0 0 1-.23.554 2.024 2.024 0 0 0 .143 2.03l.136.199-.361.36-.199-.135a2.024 2.024 0 0 0-2.03-.143c-.179.087-.364.164-.554.23a2.024 2.024 0 0 0-1.334 1.536l-.044.236h-.51l-.044-.236a2.024 2.024 0 0 0-1.334-1.536 4.952 4.952 0 0 1-.554-.23 2.024 2.024 0 0 0-2.03.143l-.199.136-.36-.361.135-.199a2.024 2.024 0 0 0 .143-2.03 4.958 4.958 0 0 1-.23-.554 2.024 2.024 0 0 0-1.536-1.334l-.236-.044v-.51l.236-.044a2.024 2.024 0 0 0 1.536-1.334 4.96 4.96 0 0 1 .23-.554 2.024 2.024 0 0 0-.143-2.03l-.136-.199.361-.36.199.135a2.024 2.024 0 0 0 2.03.143c.179-.087.364-.164.554-.23a2.024 2.024 0 0 0 1.334-1.536ZM8.5 2h3l.274 1.46c.034.185.17.333.348.394.248.086.49.186.722.3.17.082.37.074.526-.033l1.226-.839 2.122 2.122-.84 1.226a.524.524 0 0 0-.032.526c.114.233.214.474.3.722.061.177.21.314.394.348L18 8.5v3l-1.46.274a.524.524 0 0 0-.394.348 6.47 6.47 0 0 1-.3.722.524.524 0 0 0 .033.526l.839 1.226-2.122 2.122-1.226-.84a.524.524 0 0 0-.526-.032 6.477 6.477 0 0 1-.722.3.524.524 0 0 0-.348.394L11.5 18h-3l-.274-1.46a.524.524 0 0 0-.348-.394 6.477 6.477 0 0 1-.722-.3.524.524 0 0 0-.526.033l-1.226.839-2.122-2.122.84-1.226a.524.524 0 0 0 .032-.526 6.453 6.453 0 0 1-.3-.722.524.524 0 0 0-.394-.348L2 11.5v-3l1.46-.274a.524.524 0 0 0 .394-.348c.086-.248.186-.49.3-.722a.524.524 0 0 0-.033-.526l-.839-1.226 2.122-2.122 1.226.84a.524.524 0 0 0 .526.032 6.46 6.46 0 0 1 .722-.3.524.524 0 0 0 .348-.394L8.5 2Zm3 8a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Zm1.5 0a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z',
          clipRule: 'evenodd',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=gear-icon.js.map
  },
  3176: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'LeftArrow', {
      enumerable: true,
      get: function () {
        return LeftArrow;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function LeftArrow(param) {
      let { title, className } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '16',
        height: '16',
        viewBox: '0 0 16 16',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        'aria-label': title,
        className: className,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M9.24996 12.0608L8.71963 11.5304L5.89641 8.70722C5.50588 8.3167 5.50588 7.68353 5.89641 7.29301L8.71963 4.46978L9.24996 3.93945L10.3106 5.00011L9.78029 5.53044L7.31062 8.00011L9.78029 10.4698L10.3106 11.0001L9.24996 12.0608Z',
          fill: 'currentColor',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=left-arrow.js.map
  },
  3436: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return LightIcon;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function LightIcon() {
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: '20',
        height: '16',
        viewBox: '0 0 16 16',
        fill: 'none',
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('g', {
            clipPath: 'url(#light_icon_clip_path)',
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
              fill: 'currentColor',
              fillRule: 'evenodd',
              d: 'M8.75.75V0h-1.5v2h1.5V.75ZM3.26 4.32l-.53-.53-.354-.353-.53-.53 1.06-1.061.53.53.354.354.53.53-1.06 1.06Zm8.42-1.06.53-.53.353-.354.53-.53 1.061 1.06-.53.53-.354.354-.53.53-1.06-1.06ZM8 11.25a3.25 3.25 0 1 0 0-6.5 3.25 3.25 0 0 0 0 6.5Zm0 1.5a4.75 4.75 0 1 0 0-9.5 4.75 4.75 0 0 0 0 9.5Zm6-5.5h2v1.5h-2v-1.5Zm-13.25 0H0v1.5h2v-1.5H.75Zm1.62 5.32-.53.53 1.06 1.06.53-.53.354-.353.53-.53-1.06-1.061-.53.53-.354.354Zm10.2 1.06.53.53 1.06-1.06-.53-.53-.354-.354-.53-.53-1.06 1.06.53.53.353.354ZM8.75 14v2h-1.5v-2h1.5Z',
              clipRule: 'evenodd',
            }),
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('defs', {
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)('clipPath', {
              id: 'light_icon_clip_path',
              children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
                fill: 'currentColor',
                d: 'M0 0h16v16H0z',
              }),
            }),
          }),
        ],
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=light-icon.js.map
  },
  9059: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'RightArrow', {
      enumerable: true,
      get: function () {
        return RightArrow;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function RightArrow(param) {
      let { title, className } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '16',
        height: '16',
        viewBox: '0 0 16 16',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        className: className,
        'aria-label': title,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M6.75011 3.93945L7.28044 4.46978L10.1037 7.29301C10.4942 7.68353 10.4942 8.3167 10.1037 8.70722L7.28044 11.5304L6.75011 12.0608L5.68945 11.0001L6.21978 10.4698L8.68945 8.00011L6.21978 5.53044L5.68945 5.00011L6.75011 3.93945Z',
          fill: 'currentColor',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=right-arrow.js.map
  },
  809: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return SystemIcon;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function SystemIcon() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '16',
        height: '16',
        strokeLinejoin: 'round',
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M0 2a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v8.5a1 1 0 0 1-1 1H8.75v3h1.75V16h-5v-1.5h1.75v-3H1a1 1 0 0 1-1-1V2Zm1.5.5V10h13V2.5h-13Z',
          clipRule: 'evenodd',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=system-icon.js.map
  },
  9415: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ThumbsDown', {
      enumerable: true,
      get: function () {
        return ThumbsDown;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function ThumbsDown(props) {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '16',
        height: '16',
        viewBox: '0 0 16 16',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        className: 'thumbs-down-icon',
        ...props,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
          fillRule: 'evenodd',
          clipRule: 'evenodd',
          d: 'M5.89531 12.7603C5.72984 12.8785 5.5 12.7602 5.5 12.5569V9.75C5.5 8.7835 4.7165 8 3.75 8H1.5V1.5H11.1884C11.762 1.5 12.262 1.89037 12.4011 2.44683L13.4011 6.44683C13.5984 7.23576 13.0017 8 12.1884 8H8.25H7.5V8.75V11.4854C7.5 11.5662 7.46101 11.6419 7.39531 11.6889L5.89531 12.7603ZM4 12.5569C4 13.9803 5.6089 14.8082 6.76717 13.9809L8.26717 12.9095C8.72706 12.581 9 12.0506 9 11.4854V9.5H12.1884C13.9775 9.5 15.2903 7.81868 14.8563 6.08303L13.8563 2.08303C13.5503 0.858816 12.4503 0 11.1884 0H0.75H0V0.75V8.75V9.5H0.75H3.75C3.88807 9.5 4 9.61193 4 9.75V12.5569Z',
          fill: 'currentColor',
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=thumbs-down.js.map
  },
  6058: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ThumbsUp', {
      enumerable: true,
      get: function () {
        return ThumbsUp;
      },
    });
    const _jsxruntime = __webpack_require__(3263);
    function ThumbsUp(props) {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('svg', {
        width: '16',
        height: '16',
        viewBox: '0 0 16 16',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        className: 'thumbs-up-icon',
        ...props,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)('g', {
          id: 'thumb-up-16',
          children: /*#__PURE__*/ (0, _jsxruntime.jsx)('path', {
            id: 'Union',
            fillRule: 'evenodd',
            clipRule: 'evenodd',
            d: 'M6.89531 2.23959C6.72984 2.1214 6.5 2.23968 6.5 2.44303V5.24989C6.5 6.21639 5.7165 6.99989 4.75 6.99989H2.5V13.4999H12.1884C12.762 13.4999 13.262 13.1095 13.4011 12.5531L14.4011 8.55306C14.5984 7.76412 14.0017 6.99989 13.1884 6.99989H9.25H8.5V6.24989V3.51446C8.5 3.43372 8.46101 3.35795 8.39531 3.31102L6.89531 2.23959ZM5 2.44303C5 1.01963 6.6089 0.191656 7.76717 1.01899L9.26717 2.09042C9.72706 2.41892 10 2.94929 10 3.51446V5.49989H13.1884C14.9775 5.49989 16.2903 7.18121 15.8563 8.91686L14.8563 12.9169C14.5503 14.1411 13.4503 14.9999 12.1884 14.9999H1.75H1V14.2499V6.24989V5.49989H1.75H4.75C4.88807 5.49989 5 5.38796 5 5.24989V2.44303Z',
            fill: 'currentColor',
          }),
        }),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=thumbs-up.js.map
  },
  6696: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'Base', {
      enumerable: true,
      get: function () {
        return Base;
      },
    });
    const _tagged_template_literal_loose = __webpack_require__(1637);
    const _jsxruntime = __webpack_require__(3263);
    const _css = __webpack_require__(6216);
    function _templateObject() {
      const data = _tagged_template_literal_loose._([
        "\n        :host {\n          /* \n           * Although the style applied to the shadow host is isolated,\n           * the element that attached the shadow host (i.e. \"nextjs-portal\")\n           * is still affected by the parent's style (e.g. \"body\"). This may\n           * occur style conflicts like \"display: flex\", with other children\n           * elements therefore give the shadow host an absolute position.\n           */\n          position: absolute;\n\n          --color-font: #757575;\n          --color-backdrop: rgba(250, 250, 250, 0.8);\n          --color-border-shadow: rgba(0, 0, 0, 0.145);\n\n          --color-title-color: #1f1f1f;\n          --color-stack-notes: #777;\n\n          --color-accents-1: #808080;\n          --color-accents-2: #222222;\n          --color-accents-3: #404040;\n\n          --font-stack-monospace: '__nextjs-Geist Mono', 'Geist Mono',\n            'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier,\n            monospace;\n          --font-stack-sans: '__nextjs-Geist', 'Geist', -apple-system,\n            'Source Sans Pro', sans-serif;\n\n          font-family: var(--font-stack-sans);\n          font-variant-ligatures: none;\n\n          /* TODO: Remove replaced ones. */\n          --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n          --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1),\n            0 1px 2px -1px rgb(0 0 0 / 0.1);\n          --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1),\n            0 2px 4px -2px rgb(0 0 0 / 0.1);\n          --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),\n            0 4px 6px -4px rgb(0 0 0 / 0.1);\n          --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1),\n            0 8px 10px -6px rgb(0 0 0 / 0.1);\n          --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);\n          --shadow-inner: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);\n          --shadow-none: 0 0 #0000;\n\n          --shadow-small: 0px 2px 2px rgba(0, 0, 0, 0.04);\n          --shadow-menu: 0px 1px 1px rgba(0, 0, 0, 0.02),\n            0px 4px 8px -4px rgba(0, 0, 0, 0.04),\n            0px 16px 24px -8px rgba(0, 0, 0, 0.06);\n\n          --focus-color: var(--color-blue-800);\n          --focus-ring: 2px solid var(--focus-color);\n\n          --timing-swift: cubic-bezier(0.23, 0.88, 0.26, 0.92);\n          --timing-overlay: cubic-bezier(0.175, 0.885, 0.32, 1.1);\n\n          --rounded-none: 0px;\n          --rounded-sm: 2px;\n          --rounded-md: 4px;\n          --rounded-md-2: 6px;\n          --rounded-lg: 8px;\n          --rounded-xl: 12px;\n          --rounded-2xl: 16px;\n          --rounded-3xl: 24px;\n          --rounded-4xl: 32px;\n          --rounded-full: 9999px;\n\n          /* \n            This value gets set from the Dev Tools preferences,\n            and we use the following --size-* variables to \n            scale the relevant elements.\n\n            The reason why we don't rely on rem values is because\n            if an app sets their root font size to something tiny, \n            it feels unexpected to have the app root size leak \n            into a Next.js surface.\n\n            https://github.com/vercel/next.js/discussions/76812\n          */\n          --nextjs-dev-tools-scale: ",
        ';\n          --size-1: calc(1px / var(--nextjs-dev-tools-scale));\n          --size-2: calc(2px / var(--nextjs-dev-tools-scale));\n          --size-3: calc(3px / var(--nextjs-dev-tools-scale));\n          --size-4: calc(4px / var(--nextjs-dev-tools-scale));\n          --size-5: calc(5px / var(--nextjs-dev-tools-scale));\n          --size-6: calc(6px / var(--nextjs-dev-tools-scale));\n          --size-7: calc(7px / var(--nextjs-dev-tools-scale));\n          --size-8: calc(8px / var(--nextjs-dev-tools-scale));\n          --size-9: calc(9px / var(--nextjs-dev-tools-scale));\n          --size-10: calc(10px / var(--nextjs-dev-tools-scale));\n          --size-11: calc(11px / var(--nextjs-dev-tools-scale));\n          --size-12: calc(12px / var(--nextjs-dev-tools-scale));\n          --size-13: calc(13px / var(--nextjs-dev-tools-scale));\n          --size-14: calc(14px / var(--nextjs-dev-tools-scale));\n          --size-15: calc(15px / var(--nextjs-dev-tools-scale));\n          --size-16: calc(16px / var(--nextjs-dev-tools-scale));\n          --size-17: calc(17px / var(--nextjs-dev-tools-scale));\n          --size-18: calc(18px / var(--nextjs-dev-tools-scale));\n          --size-20: calc(20px / var(--nextjs-dev-tools-scale));\n          --size-22: calc(22px / var(--nextjs-dev-tools-scale));\n          --size-24: calc(24px / var(--nextjs-dev-tools-scale));\n          --size-26: calc(26px / var(--nextjs-dev-tools-scale));\n          --size-28: calc(28px / var(--nextjs-dev-tools-scale));\n          --size-30: calc(30px / var(--nextjs-dev-tools-scale));\n          --size-32: calc(32px / var(--nextjs-dev-tools-scale));\n          --size-34: calc(34px / var(--nextjs-dev-tools-scale));\n          --size-36: calc(36px / var(--nextjs-dev-tools-scale));\n          --size-38: calc(38px / var(--nextjs-dev-tools-scale));\n          --size-40: calc(40px / var(--nextjs-dev-tools-scale));\n          --size-42: calc(42px / var(--nextjs-dev-tools-scale));\n          --size-44: calc(44px / var(--nextjs-dev-tools-scale));\n          --size-46: calc(46px / var(--nextjs-dev-tools-scale));\n          --size-48: calc(48px / var(--nextjs-dev-tools-scale));\n\n          @media print {\n            display: none;\n          }\n        }\n\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6 {\n          margin-bottom: 8px;\n          font-weight: 500;\n          line-height: 1.5;\n        }\n\n        a {\n          color: var(--color-blue-900);\n          &:hover {\n            color: var(--color-blue-900);\n          }\n          &:focus {\n            outline: var(--focus-ring);\n          }\n        }\n      ',
      ]);
      _templateObject = function () {
        return data;
      };
      return data;
    }
    function Base(param) {
      let { scale = 1 } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('style', {
        children: (0, _css.css)(_templateObject(), String(scale)),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=base.js.map
  },
  6455: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'Colors', {
      enumerable: true,
      get: function () {
        return Colors;
      },
    });
    const _tagged_template_literal_loose = __webpack_require__(1637);
    const _jsxruntime = __webpack_require__(3263);
    const _css = __webpack_require__(6216);
    function _templateObject() {
      const data = _tagged_template_literal_loose._([
        '\n        :host {\n          /* \n           * CAUTION: THIS IS A WORKAROUND!\n           * For now, we use @babel/code-frame to parse the code frame which does not support option to change the color.\n           * x-ref: https://github.com/babel/babel/blob/efa52324ff835b794c48080f14877b6caf32cd15/packages/babel-code-frame/src/defs.ts#L40-L54\n           * So, we do a workaround mapping to change the color matching the theme.\n           *\n           * For example, in @babel/code-frame, the "keyword" is mapped to ANSI "cyan".\n           * We want the "keyword" to use the "syntax-keyword" color in the theme.\n           * So, we map the "cyan" to the "syntax-keyword" in the theme.\n           */\n          /* cyan: keyword */\n          --color-ansi-cyan: var(--color-syntax-keyword);\n          /* yellow: capitalized, jsxIdentifier, punctuation */\n          --color-ansi-yellow: var(--color-syntax-function);\n          /* magenta: number, regex */\n          --color-ansi-magenta: var(--color-syntax-keyword);\n          /* green: string */\n          --color-ansi-green: var(--color-syntax-string);\n          /* gray (bright black): comment, gutter */\n          --color-ansi-bright-black: var(--color-syntax-comment);\n\n          /* Ansi - Temporary */\n          --color-ansi-selection: var(--color-gray-alpha-300);\n          --color-ansi-bg: var(--color-background-200);\n          --color-ansi-fg: var(--color-gray-1000);\n\n          --color-ansi-white: var(--color-gray-700);\n          --color-ansi-black: var(--color-gray-200);\n          --color-ansi-blue: var(--color-blue-700);\n          --color-ansi-red: var(--color-red-700);\n          --color-ansi-bright-white: var(--color-gray-1000);\n          --color-ansi-bright-blue: var(--color-blue-800);\n          --color-ansi-bright-cyan: var(--color-blue-800);\n          --color-ansi-bright-green: var(--color-green-800);\n          --color-ansi-bright-magenta: var(--color-blue-800);\n          --color-ansi-bright-red: var(--color-red-800);\n          --color-ansi-bright-yellow: var(--color-amber-900);\n\n          /* Background Light */\n          --color-background-100: #ffffff;\n          --color-background-200: #fafafa;\n\n          /* Syntax Light */\n          --color-syntax-comment: #545454;\n          --color-syntax-constant: #171717;\n          --color-syntax-function: #0054ad;\n          --color-syntax-keyword: #a51850;\n          --color-syntax-link: #066056;\n          --color-syntax-parameter: #8f3e00;\n          --color-syntax-punctuation: #171717;\n          --color-syntax-string: #036157;\n          --color-syntax-string-expression: #066056;\n\n          /* Gray Scale Light */\n          --color-gray-100: #f2f2f2;\n          --color-gray-200: #ebebeb;\n          --color-gray-300: #e6e6e6;\n          --color-gray-400: #eaeaea;\n          --color-gray-500: #c9c9c9;\n          --color-gray-600: #a8a8a8;\n          --color-gray-700: #8f8f8f;\n          --color-gray-800: #7d7d7d;\n          --color-gray-900: #666666;\n          --color-gray-1000: #171717;\n\n          /* Gray Alpha Scale Light */\n          --color-gray-alpha-100: rgba(0, 0, 0, 0.05);\n          --color-gray-alpha-200: rgba(0, 0, 0, 0.081);\n          --color-gray-alpha-300: rgba(0, 0, 0, 0.1);\n          --color-gray-alpha-400: rgba(0, 0, 0, 0.08);\n          --color-gray-alpha-500: rgba(0, 0, 0, 0.21);\n          --color-gray-alpha-600: rgba(0, 0, 0, 0.34);\n          --color-gray-alpha-700: rgba(0, 0, 0, 0.44);\n          --color-gray-alpha-800: rgba(0, 0, 0, 0.51);\n          --color-gray-alpha-900: rgba(0, 0, 0, 0.605);\n          --color-gray-alpha-1000: rgba(0, 0, 0, 0.91);\n\n          /* Blue Scale Light */\n          --color-blue-100: #f0f7ff;\n          --color-blue-200: #edf6ff;\n          --color-blue-300: #e1f0ff;\n          --color-blue-400: #cde7ff;\n          --color-blue-500: #99ceff;\n          --color-blue-600: #52aeff;\n          --color-blue-700: #0070f3;\n          --color-blue-800: #0060d1;\n          --color-blue-900: #0067d6;\n          --color-blue-1000: #0025ad;\n\n          /* Red Scale Light */\n          --color-red-100: #fff0f0;\n          --color-red-200: #ffebeb;\n          --color-red-300: #ffe5e5;\n          --color-red-400: #fdd8d8;\n          --color-red-500: #f8baba;\n          --color-red-600: #f87274;\n          --color-red-700: #e5484d;\n          --color-red-800: #da3036;\n          --color-red-900: #ca2a30;\n          --color-red-1000: #381316;\n\n          /* Amber Scale Light */\n          --color-amber-100: #fff6e5;\n          --color-amber-200: #fff4d5;\n          --color-amber-300: #fef0cd;\n          --color-amber-400: #ffddbf;\n          --color-amber-500: #ffc96b;\n          --color-amber-600: #f5b047;\n          --color-amber-700: #ffb224;\n          --color-amber-800: #ff990a;\n          --color-amber-900: #a35200;\n          --color-amber-1000: #4e2009;\n\n          /* Green Scale Light */\n          --color-green-100: #effbef;\n          --color-green-200: #eafaea;\n          --color-green-300: #dcf6dc;\n          --color-green-400: #c8f1c9;\n          --color-green-500: #99e59f;\n          --color-green-600: #6cda76;\n          --color-green-700: #46a758;\n          --color-green-800: #388e4a;\n          --color-green-900: #297c3b;\n          --color-green-1000: #18311e;\n\n          /* Turbopack Light - Temporary */\n          --color-turbopack-text-red: #ff1e56;\n          --color-turbopack-text-blue: #0096ff;\n          --color-turbopack-border-red: #f0adbe;\n          --color-turbopack-border-blue: #adccea;\n          --color-turbopack-background-red: #fff7f9;\n          --color-turbopack-background-blue: #f6fbff;\n        }\n      ',
      ]);
      _templateObject = function () {
        return data;
      };
      return data;
    }
    function Colors() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('style', {
        children: (0, _css.css)(_templateObject()),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=colors.js.map
  },
  1107: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ComponentStyles', {
      enumerable: true,
      get: function () {
        return ComponentStyles;
      },
    });
    const _tagged_template_literal_loose = __webpack_require__(1637);
    const _jsxruntime = __webpack_require__(3263);
    const _codeframe = __webpack_require__(8467);
    const _dialog = __webpack_require__(7074);
    const _erroroverlaylayout = __webpack_require__(3060);
    const _erroroverlaybottomstack = __webpack_require__(8976);
    const _erroroverlaypagination = __webpack_require__(4768);
    const _styles = __webpack_require__(9781);
    const _erroroverlayfooter = __webpack_require__(4309);
    const _terminal = __webpack_require__(4325);
    const _toast = __webpack_require__(3709);
    const _versionstalenessinfo = __webpack_require__(1937);
    const _builderror = __webpack_require__(1095);
    const _errors = __webpack_require__(7709);
    const _runtimeerror = __webpack_require__(4819);
    const _copybutton = __webpack_require__(4807);
    const _callstackframe = __webpack_require__(7893);
    const _devtoolsindicator = __webpack_require__(6862);
    const _css = __webpack_require__(6216);
    const _editorlink = __webpack_require__(7019);
    const _environmentnamelabel = __webpack_require__(5040);
    const _devtoolsinfo = __webpack_require__(6462);
    const _turbopackinfo = __webpack_require__(4526);
    const _routeinfo = __webpack_require__(4926);
    const _userpreferences = __webpack_require__(4257);
    const _fader = __webpack_require__(3289);
    function _templateObject() {
      const data = _tagged_template_literal_loose._([
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n        ',
        '\n      ',
      ]);
      _templateObject = function () {
        return data;
      };
      return data;
    }
    function ComponentStyles() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('style', {
        children: (0, _css.css)(
          _templateObject(),
          _copybutton.COPY_BUTTON_STYLES,
          _callstackframe.CALL_STACK_FRAME_STYLES,
          _environmentnamelabel.ENVIRONMENT_NAME_LABEL_STYLES,
          _styles.styles,
          _toast.styles,
          _dialog.styles,
          _erroroverlaylayout.styles,
          _erroroverlayfooter.styles,
          _erroroverlaybottomstack.styles,
          _erroroverlaypagination.styles,
          _codeframe.CODE_FRAME_STYLES,
          _terminal.TERMINAL_STYLES,
          _editorlink.EDITOR_LINK_STYLES,
          _builderror.styles,
          _errors.styles,
          _runtimeerror.styles,
          _versionstalenessinfo.styles,
          _devtoolsindicator.DEV_TOOLS_INDICATOR_STYLES,
          _devtoolsinfo.DEV_TOOLS_INFO_STYLES,
          _turbopackinfo.DEV_TOOLS_INFO_TURBOPACK_INFO_STYLES,
          _routeinfo.DEV_TOOLS_INFO_ROUTE_INFO_STYLES,
          _userpreferences.DEV_TOOLS_INFO_USER_PREFERENCES_STYLES,
          _fader.FADER_STYLES
        ),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=component-styles.js.map
  },
  4345: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'CssReset', {
      enumerable: true,
      get: function () {
        return CssReset;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _tagged_template_literal_loose = __webpack_require__(1637);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _css = __webpack_require__(6216);
    function _templateObject() {
      const data = _tagged_template_literal_loose._([
        "\n        :host {\n          all: initial;\n\n          /* the direction property is not reset by 'all' */\n          direction: ltr;\n        }\n\n        /*!\n         * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n         * Copyright 2011-2019 The Bootstrap Authors\n         * Copyright 2011-2019 Twitter, Inc.\n         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n         * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n         */\n        *,\n        *::before,\n        *::after {\n          box-sizing: border-box;\n        }\n\n        :host {\n          font-family: sans-serif;\n          line-height: 1.15;\n          -webkit-text-size-adjust: 100%;\n          -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n        }\n\n        article,\n        aside,\n        figcaption,\n        figure,\n        footer,\n        header,\n        hgroup,\n        main,\n        nav,\n        section {\n          display: block;\n        }\n\n        :host {\n          margin: 0;\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n            'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n            'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n            'Noto Color Emoji';\n          font-size: 16px;\n          font-weight: 400;\n          line-height: 1.5;\n          color: var(--color-font);\n          text-align: left;\n        }\n\n        :host:not(button) {\n          background-color: #fff;\n        }\n\n        [tabindex='-1']:focus:not(:focus-visible) {\n          outline: 0 !important;\n        }\n\n        hr {\n          box-sizing: content-box;\n          height: 0;\n          overflow: visible;\n        }\n\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6 {\n          margin-top: 0;\n          margin-bottom: 8px;\n        }\n\n        p {\n          margin-top: 0;\n          margin-bottom: 16px;\n        }\n\n        abbr[title],\n        abbr[data-original-title] {\n          text-decoration: underline;\n          -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n          cursor: help;\n          border-bottom: 0;\n          -webkit-text-decoration-skip-ink: none;\n          text-decoration-skip-ink: none;\n        }\n\n        address {\n          margin-bottom: 16px;\n          font-style: normal;\n          line-height: inherit;\n        }\n\n        ol,\n        ul,\n        dl {\n          margin-top: 0;\n          margin-bottom: 16px;\n        }\n\n        ol ol,\n        ul ul,\n        ol ul,\n        ul ol {\n          margin-bottom: 0;\n        }\n\n        dt {\n          font-weight: 700;\n        }\n\n        dd {\n          margin-bottom: 8px;\n          margin-left: 0;\n        }\n\n        blockquote {\n          margin: 0 0 16px;\n        }\n\n        b,\n        strong {\n          font-weight: bolder;\n        }\n\n        small {\n          font-size: 80%;\n        }\n\n        sub,\n        sup {\n          position: relative;\n          font-size: 75%;\n          line-height: 0;\n          vertical-align: baseline;\n        }\n\n        sub {\n          bottom: -0.25em;\n        }\n\n        sup {\n          top: -0.5em;\n        }\n\n        a {\n          color: #007bff;\n          text-decoration: none;\n          background-color: transparent;\n        }\n\n        a:hover {\n          color: #0056b3;\n          text-decoration: underline;\n        }\n\n        a:not([href]) {\n          color: inherit;\n          text-decoration: none;\n        }\n\n        a:not([href]):hover {\n          color: inherit;\n          text-decoration: none;\n        }\n\n        pre,\n        code,\n        kbd,\n        samp {\n          font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n            'Liberation Mono', 'Courier New', monospace;\n          font-size: 1em;\n        }\n\n        pre {\n          margin-top: 0;\n          margin-bottom: 16px;\n          overflow: auto;\n        }\n\n        figure {\n          margin: 0 0 16px;\n        }\n\n        img {\n          vertical-align: middle;\n          border-style: none;\n        }\n\n        svg {\n          overflow: hidden;\n          vertical-align: middle;\n        }\n\n        table {\n          border-collapse: collapse;\n        }\n\n        caption {\n          padding-top: 12px;\n          padding-bottom: 12px;\n          color: #6c757d;\n          text-align: left;\n          caption-side: bottom;\n        }\n\n        th {\n          text-align: inherit;\n        }\n\n        label {\n          display: inline-block;\n          margin-bottom: 8px;\n        }\n\n        button {\n          border-radius: 0;\n          border: 0;\n          padding: 0;\n          margin: 0;\n          background: none;\n          appearance: none;\n          -webkit-appearance: none;\n        }\n\n        button:focus {\n          outline: 1px dotted;\n          outline: 5px auto -webkit-focus-ring-color;\n        }\n\n        button:focus:not(:focus-visible) {\n          outline: none;\n        }\n\n        input,\n        button,\n        select,\n        optgroup,\n        textarea {\n          margin: 0;\n          font-family: inherit;\n          font-size: inherit;\n          line-height: inherit;\n        }\n\n        button,\n        input {\n          overflow: visible;\n        }\n\n        button,\n        select {\n          text-transform: none;\n        }\n\n        select {\n          word-wrap: normal;\n        }\n\n        button,\n        [type='button'],\n        [type='reset'],\n        [type='submit'] {\n          -webkit-appearance: button;\n        }\n\n        button:not(:disabled),\n        [type='button']:not(:disabled),\n        [type='reset']:not(:disabled),\n        [type='submit']:not(:disabled) {\n          cursor: pointer;\n        }\n\n        button::-moz-focus-inner,\n        [type='button']::-moz-focus-inner,\n        [type='reset']::-moz-focus-inner,\n        [type='submit']::-moz-focus-inner {\n          padding: 0;\n          border-style: none;\n        }\n\n        input[type='radio'],\n        input[type='checkbox'] {\n          box-sizing: border-box;\n          padding: 0;\n        }\n\n        input[type='date'],\n        input[type='time'],\n        input[type='datetime-local'],\n        input[type='month'] {\n          -webkit-appearance: listbox;\n        }\n\n        textarea {\n          overflow: auto;\n          resize: vertical;\n        }\n\n        fieldset {\n          min-width: 0;\n          padding: 0;\n          margin: 0;\n          border: 0;\n        }\n\n        legend {\n          display: block;\n          width: 100%;\n          max-width: 100%;\n          padding: 0;\n          margin-bottom: 8px;\n          font-size: 24px;\n          line-height: inherit;\n          color: inherit;\n          white-space: normal;\n        }\n\n        progress {\n          vertical-align: baseline;\n        }\n\n        [type='number']::-webkit-inner-spin-button,\n        [type='number']::-webkit-outer-spin-button {\n          height: auto;\n        }\n\n        [type='search'] {\n          outline-offset: -2px;\n          -webkit-appearance: none;\n        }\n\n        [type='search']::-webkit-search-decoration {\n          -webkit-appearance: none;\n        }\n\n        ::-webkit-file-upload-button {\n          font: inherit;\n          -webkit-appearance: button;\n        }\n\n        output {\n          display: inline-block;\n        }\n\n        summary {\n          display: list-item;\n          cursor: pointer;\n        }\n\n        template {\n          display: none;\n        }\n\n        [hidden] {\n          display: none !important;\n        }\n      ",
      ]);
      _templateObject = function () {
        return data;
      };
      return data;
    }
    function CssReset() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('style', {
        children: (0, _css.css)(_templateObject()),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=css-reset.js.map
  },
  231: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'DarkTheme', {
      enumerable: true,
      get: function () {
        return DarkTheme;
      },
    });
    const _tagged_template_literal_loose = __webpack_require__(1637);
    const _jsxruntime = __webpack_require__(3263);
    const _css = __webpack_require__(6216);
    function _templateObject() {
      const data = _tagged_template_literal_loose._([
        '\n      :host(.dark) {\n        ',
        '\n        ',
        '\n      }\n\n      @media (prefers-color-scheme: dark) {\n        :host(:not(.light)) {\n          ',
        '\n          ',
        '\n        }\n      }\n    ',
      ]);
      _templateObject = function () {
        return data;
      };
      return data;
    }
    const colors =
      '\n  /* Background Dark */\n  --color-background-100: #0a0a0a;\n  --color-background-200: #000000;\n\n  /* Syntax Dark */\n  --color-syntax-comment: #a0a0a0;\n  --color-syntax-constant: #ededed;\n  --color-syntax-function: #52a9ff;\n  --color-syntax-keyword: #f76e99;\n  --color-syntax-link: #0ac5b2;\n  --color-syntax-parameter: #f1a10d;\n  --color-syntax-punctuation: #ededed;\n  --color-syntax-string: #0ac5b2;\n  --color-syntax-string-expression: #0ac5b2;\n\n  /* Gray Scale Dark */\n  --color-gray-100: #1a1a1a;\n  --color-gray-200: #1f1f1f;\n  --color-gray-300: #292929;\n  --color-gray-400: #2e2e2e;\n  --color-gray-500: #454545;\n  --color-gray-600: #878787;\n  --color-gray-700: #8f8f8f;\n  --color-gray-800: #7d7d7d;\n  --color-gray-900: #a0a0a0;\n  --color-gray-1000: #ededed;\n\n  /* Gray Alpha Scale Dark */\n  --color-gray-alpha-100: rgba(255, 255, 255, 0.066);\n  --color-gray-alpha-200: rgba(255, 255, 255, 0.087);\n  --color-gray-alpha-300: rgba(255, 255, 255, 0.125);\n  --color-gray-alpha-400: rgba(255, 255, 255, 0.145);\n  --color-gray-alpha-500: rgba(255, 255, 255, 0.239);\n  --color-gray-alpha-600: rgba(255, 255, 255, 0.506);\n  --color-gray-alpha-700: rgba(255, 255, 255, 0.54);\n  --color-gray-alpha-800: rgba(255, 255, 255, 0.47);\n  --color-gray-alpha-900: rgba(255, 255, 255, 0.61);\n  --color-gray-alpha-1000: rgba(255, 255, 255, 0.923);\n\n  /* Blue Scale Dark */\n  --color-blue-100: #0f1b2d;\n  --color-blue-200: #10243e;\n  --color-blue-300: #0f3058;\n  --color-blue-400: #0d3868;\n  --color-blue-500: #0a4481;\n  --color-blue-600: #0091ff;\n  --color-blue-700: #0070f3;\n  --color-blue-800: #0060d1;\n  --color-blue-900: #52a9ff;\n  --color-blue-1000: #eaf6ff;\n\n  /* Red Scale Dark */\n  --color-red-100: #2a1314;\n  --color-red-200: #3d1719;\n  --color-red-300: #551a1e;\n  --color-red-400: #671e22;\n  --color-red-500: #822025;\n  --color-red-600: #e5484d;\n  --color-red-700: #e5484d;\n  --color-red-800: #da3036;\n  --color-red-900: #ff6369;\n  --color-red-1000: #ffecee;\n\n  /* Amber Scale Dark */\n  --color-amber-100: #271700;\n  --color-amber-200: #341c00;\n  --color-amber-300: #4a2900;\n  --color-amber-400: #573300;\n  --color-amber-500: #693f05;\n  --color-amber-600: #e79c13;\n  --color-amber-700: #ffb224;\n  --color-amber-800: #ff990a;\n  --color-amber-900: #f1a10d;\n  --color-amber-1000: #fef3dd;\n\n  /* Green Scale Dark */\n  --color-green-100: #0b2211;\n  --color-green-200: #0f2c17;\n  --color-green-300: #11351b;\n  --color-green-400: #0c461b;\n  --color-green-500: #126427;\n  --color-green-600: #1a9338;\n  --color-green-700: #46a758;\n  --color-green-800: #388e4a;\n  --color-green-900: #63c174;\n  --color-green-1000: #e5fbeb;\n\n  /* Turbopack Dark - Temporary */\n  --color-turbopack-text-red: #ff6d92;\n  --color-turbopack-text-blue: #45b2ff;\n  --color-turbopack-border-red: #6e293b;\n  --color-turbopack-border-blue: #284f80;\n  --color-turbopack-background-red: #250d12;\n  --color-turbopack-background-blue: #0a1723;\n';
    const base =
      '\n  --color-font: white;\n  --color-backdrop: rgba(0, 0, 0, 0.8);\n  --color-border-shadow: rgba(255, 255, 255, 0.145);\n\n  --color-title-color: #fafafa;\n  --color-stack-notes: #a9a9a9;\n';
    function DarkTheme() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('style', {
        children: (0, _css.css)(_templateObject(), base, colors, base, colors),
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dark-theme.js.map
  },
  6160: function (module, exports) {
    'use strict';
    /**
     * Merge multiple args to a single string with spaces. Useful for merging class names.
     *
     * @example
     *   cx('foo', 'bar'); // 'foo bar'
     *   cx('foo', null, 'bar', undefined, 'baz', false); // 'foo bar baz'
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'cx', {
      enumerable: true,
      get: function () {
        return cx;
      },
    });
    function cx() {
      for (
        var _len = arguments.length, args = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        args[_key] = arguments[_key];
      }
      return args.filter(Boolean).join(' ');
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=cx.js.map
  },
  5573: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return mergeRefs;
      },
    });
    function mergeRefs() {
      for (
        var _len = arguments.length, inputRefs = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        inputRefs[_key] = arguments[_key];
      }
      const filteredInputRefs = inputRefs.filter(Boolean);
      if (filteredInputRefs.length <= 1) {
        const firstRef = filteredInputRefs[0];
        return firstRef || null;
      }
      return function mergedRefs(ref) {
        for (const inputRef of filteredInputRefs) {
          if (typeof inputRef === 'function') {
            inputRef(ref);
          } else if (inputRef) {
            inputRef.current = ref;
          }
        }
      };
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=merge-refs.js.map
  },
  6903: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'parseUrlFromText', {
      enumerable: true,
      get: function () {
        return parseUrlFromText;
      },
    });
    function parseUrlFromText(text, matcherFunc) {
      const linkRegex = /https?:\/\/[^\s/$.?#].[^\s)'"]*/gi;
      const links = Array.from(text.matchAll(linkRegex), (match) => match[0]);
      if (matcherFunc) {
        return links.filter((link) => matcherFunc(link));
      }
      return links;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=parse-url-from-text.js.map
  },
  9051: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'useOpenInEditor', {
      enumerable: true,
      get: function () {
        return useOpenInEditor;
      },
    });
    const _react = __webpack_require__(863);
    function useOpenInEditor(param) {
      let { file, lineNumber, column } = param === void 0 ? {} : param;
      const openInEditor = (0, _react.useCallback)(() => {
        if (file == null || lineNumber == null || column == null) return;
        const params = new URLSearchParams();
        params.append('file', file);
        params.append('lineNumber', String(lineNumber));
        params.append('column', String(column));
        self.fetch((false || '') + '/__nextjs_launch-editor?' + params.toString()).then(
          () => {},
          (cause) => {
            console.error(
              'Failed to open file "' +
                file +
                ' (' +
                lineNumber +
                ':' +
                column +
                ')" in your editor. Cause:',
              cause
            );
          }
        );
      }, [file, lineNumber, column]);
      return openInEditor;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=use-open-in-editor.js.map
  },
  6216: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'css', {
      enumerable: true,
      get: function () {
        return css;
      },
    });
    function css(strings) {
      for (
        var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
        _key < _len;
        _key++
      ) {
        keys[_key - 1] = arguments[_key];
      }
      const lastIndex = strings.length - 1;
      const str =
        strings.slice(0, lastIndex).reduce((p, s, i) => p + s + keys[i], '') +
        strings[lastIndex];
      return str // Remove comments
        .replace(/\/\*[\s\S]*?\*\//g, '') // Remove whitespace, tabs, and newlines
        .replace(/\s+/g, ' ') // Remove spaces before and after semicolons, and spaces after commas
        .replace(/\s*([:;,{}])\s*/g, '$1') // Remove extra semicolons
        .replace(/;+}/g, '}') // Trim leading and trailing whitespaces
        .trim();
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=css.js.map
  },
  9383: function (module, exports, __webpack_require__) {
    'use strict';
    /*
     * Singleton store to track whether the app is currently being rendered
     * Used by the dev tools indicator to show render status
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      devRenderIndicator: function () {
        return devRenderIndicator;
      },
      useIsDevRendering: function () {
        return useIsDevRendering;
      },
    });
    const _react = __webpack_require__(863);
    let isVisible = false;
    let listeners = [];
    const subscribe = (listener) => {
      listeners.push(listener);
      return () => {
        listeners = listeners.filter((l) => l !== listener);
      };
    };
    const getSnapshot = () => isVisible;
    const show = () => {
      isVisible = true;
      listeners.forEach((listener) => listener());
    };
    const hide = () => {
      isVisible = false;
      listeners.forEach((listener) => listener());
    };
    function useIsDevRendering() {
      return (0, _react.useSyncExternalStore)(subscribe, getSnapshot);
    }
    const devRenderIndicator = {
      show,
      hide,
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dev-render-indicator.js.map
  },
  117: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'useSyncDevRenderIndicator', {
      enumerable: true,
      get: function () {
        return useSyncDevRenderIndicator;
      },
    });
    const _react = __webpack_require__(863);
    const _devrenderindicator = __webpack_require__(9383);
    const useSyncDevRenderIndicator = () => {
      const [isPending, startTransition] = (0, _react.useTransition)();
      (0, _react.useEffect)(() => {
        if (isPending) {
          _devrenderindicator.devRenderIndicator.show();
        } else {
          _devrenderindicator.devRenderIndicator.hide();
        }
      }, [isPending]);
      return startTransition;
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=use-sync-dev-render-indicator.js.map
  },
  34: function (module, exports, __webpack_require__) {
    'use strict';
    /**
     * MIT License
     *
     * Copyright (c) 2015-present, Facebook, Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this
     * software and associated documentation files (the "Software"), to deal in the Software
     * without restriction, including without limitation the rights to use, copy, modify,
     * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject to the following
     * conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies
     * or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
     * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
     * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
     * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
     * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
     * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return formatWebpackMessages;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _stripansi = /*#__PURE__*/ _interop_require_default._(
      __webpack_require__(7976)
    );
    // This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
    // It's been edited to remove chalk and CRA-specific logic
    const friendlySyntaxErrorLabel = 'Syntax error:';
    const WEBPACK_BREAKING_CHANGE_POLYFILLS =
      '\n\nBREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.';
    function isLikelyASyntaxError(message) {
      return (0, _stripansi.default)(message).includes(friendlySyntaxErrorLabel);
    }
    let hadMissingSassError = false;
    // Cleans up webpack error messages.
    function formatMessage(message, verbose, importTraceNote) {
      // TODO: Replace this once webpack 5 is stable
      if (typeof message === 'object' && message.message) {
        const filteredModuleTrace =
          message.moduleTrace &&
          message.moduleTrace.filter(
            (trace) =>
              !/next-(middleware|client-pages|route|edge-function)-loader\.js/.test(
                trace.originName
              )
          );
        let body = message.message;
        const breakingChangeIndex = body.indexOf(WEBPACK_BREAKING_CHANGE_POLYFILLS);
        if (breakingChangeIndex >= 0) {
          body = body.slice(0, breakingChangeIndex);
        }
        message =
          (message.moduleName ? (0, _stripansi.default)(message.moduleName) + '\n' : '') +
          (message.file ? (0, _stripansi.default)(message.file) + '\n' : '') +
          body +
          (message.details && verbose ? '\n' + message.details : '') +
          (filteredModuleTrace && filteredModuleTrace.length
            ? (importTraceNote || '\n\nImport trace for requested module:') +
              filteredModuleTrace.map((trace) => '\n' + trace.moduleName).join('')
            : '') +
          (message.stack && verbose ? '\n' + message.stack : '');
      }
      let lines = message.split('\n');
      // Strip Webpack-added headers off errors/warnings
      // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js
      lines = lines.filter((line) => !/Module [A-z ]+\(from/.test(line));
      // Transform parsing error into syntax error
      // TODO: move this to our ESLint formatter?
      lines = lines.map((line) => {
        const parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);
        if (!parsingError) {
          return line;
        }
        const [, errorLine, errorColumn, errorMessage] = parsingError;
        return (
          friendlySyntaxErrorLabel +
          ' ' +
          errorMessage +
          ' (' +
          errorLine +
          ':' +
          errorColumn +
          ')'
        );
      });
      message = lines.join('\n');
      // Smoosh syntax errors (commonly found in CSS)
      message = message.replace(
        /SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g,
        '' + friendlySyntaxErrorLabel + ' $3 ($1:$2)\n'
      );
      // Clean up export errors
      message = message.replace(
        /^.*export '(.+?)' was not found in '(.+?)'.*$/gm,
        "Attempted import error: '$1' is not exported from '$2'."
      );
      message = message.replace(
        /^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm,
        "Attempted import error: '$2' does not contain a default export (imported as '$1')."
      );
      message = message.replace(
        /^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm,
        "Attempted import error: '$1' is not exported from '$3' (imported as '$2')."
      );
      lines = message.split('\n');
      // Remove leading newline
      if (lines.length > 2 && lines[1].trim() === '') {
        lines.splice(1, 1);
      }
      // Cleans up verbose "module not found" messages for files and packages.
      if (lines[1] && lines[1].startsWith('Module not found: ')) {
        lines = [
          lines[0],
          lines[1]
            .replace('Error: ', '')
            .replace('Module not found: Cannot find file:', 'Cannot find file:'),
          ...lines.slice(2),
        ];
      }
      // Add helpful message for users trying to use Sass for the first time
      if (lines[1] && lines[1].match(/Cannot find module.+sass/)) {
        // ./file.module.scss (<<loader info>>) => ./file.module.scss
        const firstLine = lines[0].split('!');
        lines[0] = firstLine[firstLine.length - 1];
        lines[1] =
          "To use Next.js' built-in Sass support, you first need to install `sass`.\n";
        lines[1] += 'Run `npm i sass` or `yarn add sass` inside your workspace.\n';
        lines[1] += '\nLearn more: https://nextjs.org/docs/messages/install-sass';
        // dispose of unhelpful stack trace
        lines = lines.slice(0, 2);
        hadMissingSassError = true;
      } else if (
        hadMissingSassError &&
        message.match(/(sass-loader|resolve-url-loader: CSS error)/)
      ) {
        // dispose of unhelpful stack trace following missing sass module
        lines = [];
      }
      if (!verbose) {
        message = lines.join('\n');
        // Internal stacks are generally useless so we strip them... with the
        // exception of stacks containing `webpack:` because they're normally
        // from user code generated by Webpack. For more information see
        // https://github.com/facebook/create-react-app/pull/1050
        message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, ''); // at ... ...:x:y
        message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, ''); // at <anonymous>
        message = message.replace(
          /File was processed with these loaders:\n(.+[\\/](next[\\/]dist[\\/].+|@next[\\/]react-refresh-utils[\\/]loader)\.js\n)*You may need an additional loader to handle the result of these loaders.\n/g,
          ''
        );
        lines = message.split('\n');
      }
      // Remove duplicated newlines
      lines = lines.filter(
        (line, index, arr) =>
          index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim()
      );
      // Reassemble the message
      message = lines.join('\n');
      return message.trim();
    }
    function formatWebpackMessages(json, verbose) {
      const formattedErrors = json.errors.map((message) => {
        const isUnknownNextFontError = message.message.includes(
          'An error occurred in `next/font`.'
        );
        return formatMessage(message, isUnknownNextFontError || verbose);
      });
      const formattedWarnings = json.warnings.map((message) => {
        return formatMessage(message, verbose);
      });
      // Reorder errors to put the most relevant ones first.
      let reactServerComponentsError = -1;
      for (let i = 0; i < formattedErrors.length; i++) {
        const error = formattedErrors[i];
        if (error.includes('ReactServerComponentsError')) {
          reactServerComponentsError = i;
          break;
        }
      }
      // Move the reactServerComponentsError to the top if it exists
      if (reactServerComponentsError !== -1) {
        const error = formattedErrors.splice(reactServerComponentsError, 1);
        formattedErrors.unshift(error[0]);
      }
      const result = {
        ...json,
        errors: formattedErrors,
        warnings: formattedWarnings,
      };
      if (!verbose && result.errors.some(isLikelyASyntaxError)) {
        // If there are any syntax errors, show just them.
        result.errors = result.errors.filter(isLikelyASyntaxError);
        result.warnings = [];
      }
      return result;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=format-webpack-messages.js.map
  },
  8597: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getErrorByType: function () {
        return getErrorByType;
      },
      useFrames: function () {
        return useFrames;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _shared = __webpack_require__(6172);
    const _stackframe = __webpack_require__(9667);
    const _errorsource = __webpack_require__(4557);
    const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(863));
    const useFrames = (error) => {
      if ('use' in _react.default) {
        const frames = error.frames;
        if (typeof frames !== 'function') {
          throw Object.defineProperty(
            new Error(
              'Invariant: frames must be a function when the React version has React.use. This is a bug in Next.js.'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E636',
              enumerable: false,
              configurable: true,
            }
          );
        }
        return _react.default.use(frames());
      } else {
        if (!Array.isArray(error.frames)) {
          throw Object.defineProperty(
            new Error(
              'Invariant: frames must be an array when the React version does not have React.use. This is a bug in Next.js.'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E637',
              enumerable: false,
              configurable: true,
            }
          );
        }
        return error.frames;
      }
    };
    async function getErrorByType(ev, isAppDir) {
      const { id, event } = ev;
      switch (event.type) {
        case _shared.ACTION_UNHANDLED_ERROR:
        case _shared.ACTION_UNHANDLED_REJECTION: {
          const baseError = {
            id,
            runtime: true,
            error: event.reason,
          };
          if ('use' in _react.default) {
            const readyRuntimeError = {
              ...baseError,
              // createMemoizedPromise dedups calls to getOriginalStackFrames
              frames: createMemoizedPromise(async () => {
                return await (0, _stackframe.getOriginalStackFrames)(
                  event.frames,
                  (0, _errorsource.getErrorSource)(event.reason),
                  isAppDir
                );
              }),
            };
            if (event.type === _shared.ACTION_UNHANDLED_ERROR) {
              readyRuntimeError.componentStackFrames = event.componentStackFrames;
            }
            return readyRuntimeError;
          } else {
            const readyRuntimeError = {
              ...baseError,
              // createMemoizedPromise dedups calls to getOriginalStackFrames
              frames: await (0, _stackframe.getOriginalStackFrames)(
                event.frames,
                (0, _errorsource.getErrorSource)(event.reason),
                isAppDir
              ),
            };
            if (event.type === _shared.ACTION_UNHANDLED_ERROR) {
              readyRuntimeError.componentStackFrames = event.componentStackFrames;
            }
            return readyRuntimeError;
          }
        }
        default: {
          break;
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const _ = event;
      throw Object.defineProperty(
        new Error('type system invariant violation'),
        '__NEXT_ERROR_CODE',
        {
          value: 'E335',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function createMemoizedPromise(promiseFactory) {
      const cachedPromise = promiseFactory();
      return function () {
        return cachedPromise;
      };
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=get-error-by-type.js.map
  },
  7569: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'getSocketUrl', {
      enumerable: true,
      get: function () {
        return getSocketUrl;
      },
    });
    const _normalizedassetprefix = __webpack_require__(6737);
    function getSocketProtocol(assetPrefix) {
      let protocol = window.location.protocol;
      try {
        // assetPrefix is a url
        protocol = new URL(assetPrefix).protocol;
      } catch (e) {}
      return protocol === 'http:' ? 'ws:' : 'wss:';
    }
    function getSocketUrl(assetPrefix) {
      const prefix = (0, _normalizedassetprefix.normalizedAssetPrefix)(assetPrefix);
      const protocol = getSocketProtocol(assetPrefix || '');
      if (URL.canParse(prefix)) {
        // since normalized asset prefix is ensured to be a URL format,
        // we can safely replace the protocol
        return prefix.replace(/^http/, 'ws');
      }
      const { hostname, port } = window.location;
      return protocol + '//' + hostname + (port ? ':' + port : '') + prefix;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=get-socket-url.js.map
  },
  4698: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'parseComponentStack', {
      enumerable: true,
      get: function () {
        return parseComponentStack;
      },
    });
    var LocationType =
      /*#__PURE__*/ /* unused pure expression or super */ null &&
      (function (LocationType) {
        LocationType['FILE'] = 'file';
        LocationType['WEBPACK_INTERNAL'] = 'webpack-internal';
        LocationType['HTTP'] = 'http';
        LocationType['PROTOCOL_RELATIVE'] = 'protocol-relative';
        LocationType['UNKNOWN'] = 'unknown';
        return LocationType;
      })(LocationType || {});
    /** Get the type of frame line based on the location */ function getLocationType(
      location
    ) {
      if (location.startsWith('file://')) {
        return 'file';
      }
      if (location.includes('webpack-internal://')) {
        return 'webpack-internal';
      }
      if (location.startsWith('http://') || location.startsWith('https://')) {
        return 'http';
      }
      if (location.startsWith('//')) {
        return 'protocol-relative';
      }
      return 'unknown';
    }
    function parseStackFrameLocation(location) {
      const locationType = getLocationType(location);
      const modulePath =
        location == null
          ? void 0
          : location.replace(/^(webpack-internal:\/\/\/|file:\/\/)(\(.*\)\/)?/, '');
      var _modulePath_match;
      const [, file, lineNumber, column] =
        (_modulePath_match =
          modulePath == null ? void 0 : modulePath.match(/^(.+):(\d+):(\d+)/)) != null
          ? _modulePath_match
          : [];
      switch (locationType) {
        case 'file':
        case 'webpack-internal':
          return {
            canOpenInEditor: true,
            file,
            lineNumber: lineNumber ? Number(lineNumber) : undefined,
            column: column ? Number(column) : undefined,
          };
        // When the location is a URL we only show the file
        // TODO: Resolve http(s) URLs through sourcemaps
        case 'http':
        case 'protocol-relative':
        case 'unknown':
        default: {
          return {
            canOpenInEditor: false,
          };
        }
      }
    }
    function parseComponentStack(componentStack) {
      const componentStackFrames = [];
      for (const line of componentStack.trim().split('\n')) {
        // TODO: support safari stack trace
        // Get component and file from the component stack line
        const match = /at ([^ ]+)( \((.*)\))?/.exec(line);
        if (match == null ? void 0 : match[1]) {
          const component = match[1];
          const location = match[3];
          if (!location) {
            componentStackFrames.push({
              canOpenInEditor: false,
              component,
            });
            continue;
          }
          // Stop parsing the component stack if we reach a Next.js component
          if (location == null ? void 0 : location.includes('next/dist')) {
            break;
          }
          const frameLocation = parseStackFrameLocation(location);
          componentStackFrames.push({
            component,
            ...frameLocation,
          });
        }
      }
      return componentStackFrames;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=parse-component-stack.js.map
  },
  765: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'parseStack', {
      enumerable: true,
      get: function () {
        return parseStack;
      },
    });
    const _stacktraceparser = __webpack_require__(8027);
    const _ishydrationerror = __webpack_require__(4291);
    const regexNextStatic = /\/_next(\/static\/.+)/;
    function parseStack(stack) {
      if (!stack) return [];
      const messageAndStack = stack.replace(/^Error: /, '');
      if ((0, _ishydrationerror.isReactHydrationErrorMessage)(messageAndStack)) {
        const { stack: parsedStack } = (0, _ishydrationerror.getHydrationErrorStackInfo)(
          messageAndStack
        );
        if (parsedStack) {
          stack = parsedStack;
        }
      }
      // throw away eval information that stacktrace-parser doesn't support
      // adapted from https://github.com/stacktracejs/error-stack-parser/blob/9f33c224b5d7b607755eb277f9d51fcdb7287e24/error-stack-parser.js#L59C33-L59C62
      stack = stack
        .split('\n')
        .map((line) => {
          if (line.includes('(eval ')) {
            line = line
              .replace(/eval code/g, 'eval')
              .replace(/\(eval at [^()]* \(/, '(file://')
              .replace(/\),.*$/g, ')');
          }
          return line;
        })
        .join('\n');
      const frames = (0, _stacktraceparser.parse)(stack);
      return frames.map((frame) => {
        try {
          const url = new URL(frame.file);
          const res = regexNextStatic.exec(url.pathname);
          if (res) {
            var _process_env___NEXT_DIST_DIR_replace, _process_env___NEXT_DIST_DIR;
            const distDir =
              (_process_env___NEXT_DIST_DIR = process.env.__NEXT_DIST_DIR) == null
                ? void 0
                : (_process_env___NEXT_DIST_DIR_replace =
                      _process_env___NEXT_DIST_DIR.replace(/\\/g, '/')) == null
                  ? void 0
                  : _process_env___NEXT_DIST_DIR_replace.replace(/\/$/, '');
            if (distDir) {
              frame.file = 'file://' + distDir.concat(res.pop()) + url.search;
            }
          }
        } catch (e) {}
        return frame;
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=parse-stack.js.map
  },
  1397: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return reportHmrLatency;
      },
    });
    function reportHmrLatency(
      sendMessage,
      updatedModules,
      startMsSinceEpoch,
      endMsSinceEpoch,
      hasUpdate
    ) {
      if (hasUpdate === void 0) hasUpdate = true;
      const latencyMs = endMsSinceEpoch - startMsSinceEpoch;
      console.log('[Fast Refresh] done in ' + latencyMs + 'ms');
      if (!hasUpdate) {
        return;
      }
      sendMessage(
        JSON.stringify({
          event: 'client-hmr-latency',
          id: window.__nextDevClientId,
          startTime: startMsSinceEpoch,
          endTime: endMsSinceEpoch,
          page: window.location.pathname,
          updatedModules,
          // Whether the page (tab) was hidden at the time the event occurred.
          // This can impact the accuracy of the event's timing.
          isPageHidden: document.visibilityState === 'hidden',
        })
      );
      if (self.__NEXT_HMR_LATENCY_CB) {
        self.__NEXT_HMR_LATENCY_CB(latencyMs);
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=report-hmr-latency.js.map
  },
  9667: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getFrameSource: function () {
        return getFrameSource;
      },
      getOriginalStackFrames: function () {
        return getOriginalStackFrames;
      },
    });
    const _webpackmodulepath = __webpack_require__(6091);
    function getOriginalStackFrame(source, response) {
      var _source_file;
      async function _getOriginalStackFrame() {
        var _body_originalStackFrame;
        if (response.status === 'rejected') {
          throw Object.defineProperty(new Error(response.reason), '__NEXT_ERROR_CODE', {
            value: 'E394',
            enumerable: false,
            configurable: true,
          });
        }
        const body = response.value;
        return {
          error: false,
          reason: null,
          external: false,
          sourceStackFrame: source,
          originalStackFrame: body.originalStackFrame,
          originalCodeFrame: body.originalCodeFrame || null,
          ignored:
            ((_body_originalStackFrame = body.originalStackFrame) == null
              ? void 0
              : _body_originalStackFrame.ignored) || false,
        };
      }
      // TODO: merge this section into ignoredList handling
      if (
        source.file === 'file://' ||
        ((_source_file = source.file) == null
          ? void 0
          : _source_file.match(/https?:\/\//))
      ) {
        return Promise.resolve({
          error: false,
          reason: null,
          external: true,
          sourceStackFrame: source,
          originalStackFrame: null,
          originalCodeFrame: null,
          ignored: true,
        });
      }
      return _getOriginalStackFrame().catch((err) => {
        var _err_message, _ref;
        return {
          error: true,
          reason:
            (_ref =
              (_err_message = err == null ? void 0 : err.message) != null
                ? _err_message
                : err == null
                  ? void 0
                  : err.toString()) != null
              ? _ref
              : 'Unknown Error',
          external: false,
          sourceStackFrame: source,
          originalStackFrame: null,
          originalCodeFrame: null,
          ignored: false,
        };
      });
    }
    async function getOriginalStackFrames(frames, type, isAppDir) {
      const req = {
        frames,
        isServer: type === 'server',
        isEdgeServer: type === 'edge-server',
        isAppDirectory: isAppDir,
      };
      let res = undefined;
      let reason = undefined;
      try {
        res = await fetch('/__nextjs_original-stack-frames', {
          method: 'POST',
          body: JSON.stringify(req),
        });
      } catch (e) {
        reason = e + '';
      }
      // When fails to fetch the original stack frames, we reject here to be
      // caught at `_getOriginalStackFrame()` and return the stack frames so
      // that the error overlay can render.
      if (res && res.ok && res.status !== 204) {
        const data = await res.json();
        return Promise.all(
          frames.map((frame, index) => getOriginalStackFrame(frame, data[index]))
        );
      } else {
        if (res) {
          reason = await res.text();
        }
      }
      return Promise.all(
        frames.map((frame) =>
          getOriginalStackFrame(frame, {
            status: 'rejected',
            reason:
              'Failed to fetch the original stack frames ' +
              (reason ? ': ' + reason : ''),
          })
        )
      );
    }
    function getFrameSource(frame) {
      if (!frame.file) return '';
      const isWebpackFrame = (0, _webpackmodulepath.isWebpackInternalResource)(
        frame.file
      );
      let str = '';
      // Skip URL parsing for webpack internal file paths.
      if (isWebpackFrame) {
        str = (0, _webpackmodulepath.formatFrameSourceFile)(frame.file);
      } else {
        try {
          var _globalThis_location;
          const u = new URL(frame.file);
          let parsedPath = '';
          // Strip the origin for same-origin scripts.
          if (
            ((_globalThis_location = globalThis.location) == null
              ? void 0
              : _globalThis_location.origin) !== u.origin
          ) {
            // URLs can be valid without an `origin`, so long as they have a
            // `protocol`. However, `origin` is preferred.
            if (u.origin === 'null') {
              parsedPath += u.protocol;
            } else {
              parsedPath += u.origin;
            }
          }
          // Strip query string information as it's typically too verbose to be
          // meaningful.
          parsedPath += u.pathname;
          str = (0, _webpackmodulepath.formatFrameSourceFile)(parsedPath);
        } catch (e) {
          str = (0, _webpackmodulepath.formatFrameSourceFile)(frame.file);
        }
      }
      if (
        !(0, _webpackmodulepath.isWebpackInternalResource)(frame.file) &&
        frame.lineNumber != null
      ) {
        if (str) {
          if (frame.column != null) {
            str += ' (' + frame.lineNumber + ':' + frame.column + ')';
          } else {
            str += ' (' + frame.lineNumber + ')';
          }
        }
      }
      return str;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=stack-frame.js.map
  },
  4233: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'TurbopackHmr', {
      enumerable: true,
      get: function () {
        return TurbopackHmr;
      },
    });
    const _class_private_field_loose_base = __webpack_require__(3728);
    const _class_private_field_loose_key = __webpack_require__(3234);
    // How long to wait before reporting the HMR start, used to suppress irrelevant
    // `BUILDING` events. Does not impact reported latency.
    const TURBOPACK_HMR_START_DELAY_MS = 100;
    var _updatedModules =
        /*#__PURE__*/ _class_private_field_loose_key._('_updatedModules'),
      _startMsSinceEpoch =
        /*#__PURE__*/ _class_private_field_loose_key._('_startMsSinceEpoch'),
      _lastUpdateMsSinceEpoch = /*#__PURE__*/ _class_private_field_loose_key._(
        '_lastUpdateMsSinceEpoch'
      ),
      _deferredReportHmrStartId = /*#__PURE__*/ _class_private_field_loose_key._(
        '_deferredReportHmrStartId'
      ), // as it reports *any* compilation, including fully no-op/cached compilations
      // and those unrelated to HMR. Fixing this would require significant
      // architectural changes.
      //
      // Work around this by deferring any "rebuilding" message by 100ms. If we get
      // a BUILT event within that threshold and nothing has changed, just suppress
      // the message entirely.
      _runDeferredReportHmrStart = /*#__PURE__*/ _class_private_field_loose_key._(
        '_runDeferredReportHmrStart'
      ),
      _cancelDeferredReportHmrStart = /*#__PURE__*/ _class_private_field_loose_key._(
        '_cancelDeferredReportHmrStart'
      ),
      /** Helper for other `onEvent` methods. */ _onUpdate =
        /*#__PURE__*/ _class_private_field_loose_key._('_onUpdate');
    class TurbopackHmr {
      onBuilding() {
        _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[
          _lastUpdateMsSinceEpoch
        ] = undefined;
        _class_private_field_loose_base
          ._(this, _cancelDeferredReportHmrStart)
          [_cancelDeferredReportHmrStart]();
        _class_private_field_loose_base._(this, _startMsSinceEpoch)[_startMsSinceEpoch] =
          Date.now();
        // report the HMR start after a short delay
        _class_private_field_loose_base._(this, _deferredReportHmrStartId)[
          _deferredReportHmrStartId
        ] = setTimeout(
          () =>
            _class_private_field_loose_base
              ._(this, _runDeferredReportHmrStart)
              [_runDeferredReportHmrStart](),
          self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS
            ? 0
            : TURBOPACK_HMR_START_DELAY_MS
        );
      }
      onTurbopackMessage(msg) {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
        const updatedModules = extractModulesFromTurbopackMessage(msg.data);
        for (const module1 of updatedModules) {
          _class_private_field_loose_base
            ._(this, _updatedModules)
            [_updatedModules].add(module1);
        }
      }
      onServerComponentChanges() {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
      }
      onReloadPage() {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
      }
      onPageAddRemove() {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
      }
      /**
       * @returns `null` if the caller should ignore the update entirely. Returns an object
       *   with `hasUpdates: false` if the caller should report the end of the HMR in the
       *   browser console, but the HMR was a no-op.
       */ onBuilt() {
        // Check that we got *any* `TurbopackMessageAction`, even if
        // `updatedModules` is empty (not everything gets recorded there).
        //
        // There's also a case where `onBuilt` gets called before `onBuilding`,
        // which can happen during initial page load. Ignore that too!
        const hasUpdates =
          _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[
            _lastUpdateMsSinceEpoch
          ] != null &&
          _class_private_field_loose_base._(this, _startMsSinceEpoch)[
            _startMsSinceEpoch
          ] != null;
        if (
          !hasUpdates &&
          _class_private_field_loose_base._(this, _deferredReportHmrStartId)[
            _deferredReportHmrStartId
          ] != null
        ) {
          // suppress the update entirely
          _class_private_field_loose_base
            ._(this, _cancelDeferredReportHmrStart)
            [_cancelDeferredReportHmrStart]();
          return null;
        }
        _class_private_field_loose_base
          ._(this, _runDeferredReportHmrStart)
          [_runDeferredReportHmrStart]();
        var _class_private_field_loose_base__lastUpdateMsSinceEpoch;
        const result = {
          hasUpdates,
          updatedModules: _class_private_field_loose_base._(this, _updatedModules)[
            _updatedModules
          ],
          startMsSinceEpoch: _class_private_field_loose_base._(this, _startMsSinceEpoch)[
            _startMsSinceEpoch
          ],
          endMsSinceEpoch:
            (_class_private_field_loose_base__lastUpdateMsSinceEpoch =
              _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[
                _lastUpdateMsSinceEpoch
              ]) != null
              ? _class_private_field_loose_base__lastUpdateMsSinceEpoch
              : Date.now(),
        };
        _class_private_field_loose_base._(this, _updatedModules)[_updatedModules] =
          new Set();
        return result;
      }
      constructor() {
        Object.defineProperty(this, _runDeferredReportHmrStart, {
          value: runDeferredReportHmrStart,
        });
        Object.defineProperty(this, _cancelDeferredReportHmrStart, {
          value: cancelDeferredReportHmrStart,
        });
        Object.defineProperty(this, _onUpdate, {
          value: onUpdate,
        });
        Object.defineProperty(this, _updatedModules, {
          writable: true,
          value: void 0,
        });
        Object.defineProperty(this, _startMsSinceEpoch, {
          writable: true,
          value: void 0,
        });
        Object.defineProperty(this, _lastUpdateMsSinceEpoch, {
          writable: true,
          value: void 0,
        });
        Object.defineProperty(this, _deferredReportHmrStartId, {
          writable: true,
          value: void 0,
        });
        _class_private_field_loose_base._(this, _updatedModules)[_updatedModules] =
          new Set();
      }
    }
    function runDeferredReportHmrStart() {
      if (
        _class_private_field_loose_base._(this, _deferredReportHmrStartId)[
          _deferredReportHmrStartId
        ] != null
      ) {
        console.log('[Fast Refresh] rebuilding');
        _class_private_field_loose_base
          ._(this, _cancelDeferredReportHmrStart)
          [_cancelDeferredReportHmrStart]();
      }
    }
    function cancelDeferredReportHmrStart() {
      clearTimeout(
        _class_private_field_loose_base._(this, _deferredReportHmrStartId)[
          _deferredReportHmrStartId
        ]
      );
      _class_private_field_loose_base._(this, _deferredReportHmrStartId)[
        _deferredReportHmrStartId
      ] = undefined;
    }
    function onUpdate() {
      _class_private_field_loose_base
        ._(this, _runDeferredReportHmrStart)
        [_runDeferredReportHmrStart]();
      _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[
        _lastUpdateMsSinceEpoch
      ] = Date.now();
    }
    function extractModulesFromTurbopackMessage(data) {
      const updatedModules = new Set();
      const updates = Array.isArray(data) ? data : [data];
      for (const update of updates) {
        // TODO this won't capture changes to CSS since they don't result in a "merged" update
        if (
          update.type !== 'partial' ||
          update.instruction.type !== 'ChunkListUpdate' ||
          update.instruction.merged === undefined
        ) {
          continue;
        }
        for (const mergedUpdate of update.instruction.merged) {
          for (const name of Object.keys(mergedUpdate.entries)) {
            const res = /(.*)\s+\[.*/.exec(name);
            if (res === null) {
              console.error('[Turbopack HMR] Expected module to match pattern: ' + name);
              continue;
            }
            updatedModules.add(res[1]);
          }
        }
      }
      return updatedModules;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=turbopack-hot-reloader-common.js.map
  },
  3881: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    const _interop_require_wildcard = __webpack_require__(315);
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      useSendMessage: function () {
        return useSendMessage;
      },
      useTurbopack: function () {
        return useTurbopack;
      },
      useWebsocket: function () {
        return useWebsocket;
      },
      useWebsocketPing: function () {
        return useWebsocketPing;
      },
    });
    const _react = __webpack_require__(863);
    const _approutercontextsharedruntime = __webpack_require__(1727);
    const _getsocketurl = __webpack_require__(7569);
    function useWebsocket(assetPrefix) {
      const webSocketRef = (0, _react.useRef)(undefined);
      (0, _react.useEffect)(() => {
        if (webSocketRef.current) {
          return;
        }
        const url = (0, _getsocketurl.getSocketUrl)(assetPrefix);
        webSocketRef.current = new window.WebSocket('' + url + '/_next/webpack-hmr');
      }, [assetPrefix]);
      return webSocketRef;
    }
    function useSendMessage(webSocketRef) {
      const sendMessage = (0, _react.useCallback)(
        (data) => {
          const socket = webSocketRef.current;
          if (!socket || socket.readyState !== socket.OPEN) {
            return;
          }
          return socket.send(data);
        },
        [webSocketRef]
      );
      return sendMessage;
    }
    function useTurbopack(sendMessage, onUpdateError) {
      const turbopackState = (0, _react.useRef)({
        init: false,
        // Until the dynamic import resolves, queue any turbopack messages which will be replayed.
        queue: [],
        callback: undefined,
      });
      const processTurbopackMessage = (0, _react.useCallback)((msg) => {
        const { callback, queue } = turbopackState.current;
        if (callback) {
          callback(msg);
        } else {
          queue.push(msg);
        }
      }, []);
      (0, _react.useEffect)(() => {
        const { current: initCurrent } = turbopackState;
        // TODO(WEB-1589): only install if `process.turbopack` set.
        if (initCurrent.init) {
          return;
        }
        initCurrent.init = true;
        Promise.resolve()
          .then(() =>
            /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(9913))
          )
          .then((param) => {
            let { connect } = param;
            const { current } = turbopackState;
            connect({
              addMessageListener(cb) {
                current.callback = cb;
                // Replay all Turbopack messages before we were able to establish the HMR client.
                for (const msg of current.queue) {
                  cb(msg);
                }
                current.queue = undefined;
              },
              sendMessage,
              onUpdateError,
            });
          });
      }, [sendMessage, onUpdateError]);
      return processTurbopackMessage;
    }
    function useWebsocketPing(websocketRef) {
      const sendMessage = useSendMessage(websocketRef);
      const { tree } = (0, _react.useContext)(
        _approutercontextsharedruntime.GlobalLayoutRouterContext
      );
      (0, _react.useEffect)(() => {
        // Never send pings when using Turbopack as it's not used.
        // Pings were originally used to keep track of active routes in on-demand-entries with webpack.
        if (false) {
        }
        // Taken from on-demand-entries-client.js
        const interval = setInterval(() => {
          sendMessage(
            JSON.stringify({
              event: 'ping',
              tree,
              appDirRoute: true,
            })
          );
        }, 2500);
        return () => clearInterval(interval);
      }, [tree, sendMessage]);
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=use-websocket.js.map
  },
  6091: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      formatFrameSourceFile: function () {
        return formatFrameSourceFile;
      },
      isWebpackInternalResource: function () {
        return isWebpackInternalResource;
      },
    });
    const replacementRegExes = [
      /^webpack-internal:\/\/\/(\([\w-]+\)\/)?/,
      /^(webpack:\/\/\/|webpack:\/\/(_N_E\/)?)(\([\w-]+\)\/)?/,
    ];
    function isWebpackInternalResource(file) {
      for (const regex of replacementRegExes) {
        if (regex.test(file)) return true;
        file = file.replace(regex, '');
      }
      return false;
    }
    function formatFrameSourceFile(file) {
      for (const regex of replacementRegExes) {
        file = file.replace(regex, '');
      }
      return file;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=webpack-module-path.js.map
  },
  7575: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      RedirectBoundary: function () {
        return RedirectBoundary;
      },
      RedirectErrorBoundary: function () {
        return RedirectErrorBoundary;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _navigation = __webpack_require__(2947);
    const _redirect = __webpack_require__(3142);
    const _redirecterror = __webpack_require__(6521);
    function HandleRedirect(param) {
      let { redirect, reset, redirectType } = param;
      const router = (0, _navigation.useRouter)();
      (0, _react.useEffect)(() => {
        _react.default.startTransition(() => {
          if (redirectType === _redirecterror.RedirectType.push) {
            router.push(redirect, {});
          } else {
            router.replace(redirect, {});
          }
          reset();
        });
      }, [redirect, redirectType, reset, router]);
      return null;
    }
    class RedirectErrorBoundary extends _react.default.Component {
      static getDerivedStateFromError(error) {
        if ((0, _redirecterror.isRedirectError)(error)) {
          const url = (0, _redirect.getURLFromRedirectError)(error);
          const redirectType = (0, _redirect.getRedirectTypeFromError)(error);
          return {
            redirect: url,
            redirectType,
          };
        }
        // Re-throw if error is not for redirect
        throw error;
      }
      // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.
      render() {
        const { redirect, redirectType } = this.state;
        if (redirect !== null && redirectType !== null) {
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(HandleRedirect, {
            redirect: redirect,
            redirectType: redirectType,
            reset: () =>
              this.setState({
                redirect: null,
              }),
          });
        }
        return this.props.children;
      }
      constructor(props) {
        super(props);
        this.state = {
          redirect: null,
          redirectType: null,
        };
      }
    }
    function RedirectBoundary(param) {
      let { children } = param;
      const router = (0, _navigation.useRouter)();
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(RedirectErrorBoundary, {
        router: router,
        children: children,
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=redirect-boundary.js.map
  },
  6521: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      REDIRECT_ERROR_CODE: function () {
        return REDIRECT_ERROR_CODE;
      },
      RedirectType: function () {
        return RedirectType;
      },
      isRedirectError: function () {
        return isRedirectError;
      },
    });
    const _redirectstatuscode = __webpack_require__(4088);
    const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';
    var RedirectType = /*#__PURE__*/ (function (RedirectType) {
      RedirectType['push'] = 'push';
      RedirectType['replace'] = 'replace';
      return RedirectType;
    })({});
    function isRedirectError(error) {
      if (
        typeof error !== 'object' ||
        error === null ||
        !('digest' in error) ||
        typeof error.digest !== 'string'
      ) {
        return false;
      }
      const digest = error.digest.split(';');
      const [errorCode, type] = digest;
      const destination = digest.slice(2, -2).join(';');
      const status = digest.at(-2);
      const statusCode = Number(status);
      return (
        errorCode === REDIRECT_ERROR_CODE &&
        (type === 'replace' || type === 'push') &&
        typeof destination === 'string' &&
        !isNaN(statusCode) &&
        statusCode in _redirectstatuscode.RedirectStatusCode
      );
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=redirect-error.js.map
  },
  4088: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'RedirectStatusCode', {
      enumerable: true,
      get: function () {
        return RedirectStatusCode;
      },
    });
    var RedirectStatusCode = /*#__PURE__*/ (function (RedirectStatusCode) {
      RedirectStatusCode[(RedirectStatusCode['SeeOther'] = 303)] = 'SeeOther';
      RedirectStatusCode[(RedirectStatusCode['TemporaryRedirect'] = 307)] =
        'TemporaryRedirect';
      RedirectStatusCode[(RedirectStatusCode['PermanentRedirect'] = 308)] =
        'PermanentRedirect';
      return RedirectStatusCode;
    })({});
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=redirect-status-code.js.map
  },
  3142: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getRedirectError: function () {
        return getRedirectError;
      },
      getRedirectStatusCodeFromError: function () {
        return getRedirectStatusCodeFromError;
      },
      getRedirectTypeFromError: function () {
        return getRedirectTypeFromError;
      },
      getURLFromRedirectError: function () {
        return getURLFromRedirectError;
      },
      permanentRedirect: function () {
        return permanentRedirect;
      },
      redirect: function () {
        return redirect;
      },
    });
    const _redirectstatuscode = __webpack_require__(4088);
    const _redirecterror = __webpack_require__(6521);
    const actionAsyncStorage = true
      ? __webpack_require__(209) /* .actionAsyncStorage */.actionAsyncStorage
      : 0;
    function getRedirectError(url, type, statusCode) {
      if (statusCode === void 0)
        statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect;
      const error = Object.defineProperty(
        new Error(_redirecterror.REDIRECT_ERROR_CODE),
        '__NEXT_ERROR_CODE',
        {
          value: 'E394',
          enumerable: false,
          configurable: true,
        }
      );
      error.digest =
        _redirecterror.REDIRECT_ERROR_CODE +
        ';' +
        type +
        ';' +
        url +
        ';' +
        statusCode +
        ';';
      return error;
    }
    function redirect(/** The URL to redirect to */ url, type) {
      var _actionAsyncStorage_getStore;
      type != null
        ? type
        : (type = (
            actionAsyncStorage == null
              ? void 0
              : (_actionAsyncStorage_getStore = actionAsyncStorage.getStore()) == null
                ? void 0
                : _actionAsyncStorage_getStore.isAction
          )
            ? _redirecterror.RedirectType.push
            : _redirecterror.RedirectType.replace);
      throw getRedirectError(
        url,
        type,
        _redirectstatuscode.RedirectStatusCode.TemporaryRedirect
      );
    }
    function permanentRedirect(/** The URL to redirect to */ url, type) {
      if (type === void 0) type = _redirecterror.RedirectType.replace;
      throw getRedirectError(
        url,
        type,
        _redirectstatuscode.RedirectStatusCode.PermanentRedirect
      );
    }
    function getURLFromRedirectError(error) {
      if (!(0, _redirecterror.isRedirectError)(error)) return null;
      // Slices off the beginning of the digest that contains the code and the
      // separating ';'.
      return error.digest.split(';').slice(2, -2).join(';');
    }
    function getRedirectTypeFromError(error) {
      if (!(0, _redirecterror.isRedirectError)(error)) {
        throw Object.defineProperty(
          new Error('Not a redirect error'),
          '__NEXT_ERROR_CODE',
          {
            value: 'E260',
            enumerable: false,
            configurable: true,
          }
        );
      }
      return error.digest.split(';', 2)[1];
    }
    function getRedirectStatusCodeFromError(error) {
      if (!(0, _redirecterror.isRedirectError)(error)) {
        throw Object.defineProperty(
          new Error('Not a redirect error'),
          '__NEXT_ERROR_CODE',
          {
            value: 'E260',
            enumerable: false,
            configurable: true,
          }
        );
      }
      return Number(error.digest.split(';').at(-2));
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=redirect.js.map
  },
  5783: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return RenderFromTemplateContext;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _jsxruntime = __webpack_require__(3263);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _approutercontextsharedruntime = __webpack_require__(1727);
    function RenderFromTemplateContext() {
      const children = (0, _react.useContext)(
        _approutercontextsharedruntime.TemplateContext
      );
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children,
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=render-from-template-context.js.map
  },
  4363: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'createHrefFromUrl', {
      enumerable: true,
      get: function () {
        return createHrefFromUrl;
      },
    });
    function createHrefFromUrl(url, includeHash) {
      if (includeHash === void 0) includeHash = true;
      return url.pathname + url.search + (includeHash ? url.hash : '');
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=create-href-from-url.js.map
  },
  3953: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'createRouterCacheKey', {
      enumerable: true,
      get: function () {
        return createRouterCacheKey;
      },
    });
    const _segment = __webpack_require__(5418);
    function createRouterCacheKey(segment, withoutSearchParameters) {
      if (withoutSearchParameters === void 0) withoutSearchParameters = false;
      // if the segment is an array, it means it's a dynamic segment
      // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.
      if (Array.isArray(segment)) {
        return segment[0] + '|' + segment[1] + '|' + segment[2];
      }
      // Page segments might have search parameters, ie __PAGE__?foo=bar
      // When `withoutSearchParameters` is true, we only want to return the page segment
      if (withoutSearchParameters && segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {
        return _segment.PAGE_SEGMENT_KEY;
      }
      return segment;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=create-router-cache-key.js.map
  },
  8556: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      createFetch: function () {
        return createFetch;
      },
      createFromNextReadableStream: function () {
        return createFromNextReadableStream;
      },
      fetchServerResponse: function () {
        return fetchServerResponse;
      },
      urlToUrlWithoutFlightMarker: function () {
        return urlToUrlWithoutFlightMarker;
      },
    });
    const _approuterheaders = __webpack_require__(7079);
    const _appcallserver = __webpack_require__(9292);
    const _appfindsourcemapurl = __webpack_require__(160);
    const _routerreducertypes = __webpack_require__(77);
    const _flightdatahelpers = __webpack_require__(7343);
    const _appbuildid = __webpack_require__(7014);
    const _setcachebustingsearchparam = __webpack_require__(5567);
    // @ts-ignore
    // eslint-disable-next-line import/no-extraneous-dependencies
    // import { createFromReadableStream } from 'react-server-dom-webpack/client'
    const { createFromReadableStream } = true ? __webpack_require__(3232) : 0;
    function urlToUrlWithoutFlightMarker(url) {
      const urlWithoutFlightParameters = new URL(url, location.origin);
      urlWithoutFlightParameters.searchParams.delete(
        _approuterheaders.NEXT_RSC_UNION_QUERY
      );
      if (false) {
      }
      return urlWithoutFlightParameters;
    }
    function doMpaNavigation(url) {
      return {
        flightData: urlToUrlWithoutFlightMarker(url).toString(),
        canonicalUrl: undefined,
        couldBeIntercepted: false,
        prerendered: false,
        postponed: false,
        staleTime: -1,
      };
    }
    let abortController = new AbortController();
    if (false) {
    }
    async function fetchServerResponse(url, options) {
      const { flightRouterState, nextUrl, prefetchKind } = options;
      const headers = {
        // Enable flight response
        [_approuterheaders.RSC_HEADER]: '1',
        // Provide the current router state
        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(
          JSON.stringify(flightRouterState)
        ),
      };
      /**
       * Three cases:
       *
       * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to
       *   prefetch the page data fully
       * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above
       * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data
       *   partially, if static prefetch the page data fully
       */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {
        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';
      }
      if (true && options.isHmrRefresh) {
        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';
      }
      if (nextUrl) {
        headers[_approuterheaders.NEXT_URL] = nextUrl;
      }
      try {
        var _res_headers_get;
        // When creating a "temporary" prefetch (the "on-demand" prefetch that gets created on navigation, if one doesn't exist)
        // we send the request with a "high" priority as it's in response to a user interaction that could be blocking a transition.
        // Otherwise, all other prefetches are sent with a "low" priority.
        // We use "auto" for in all other cases to match the existing default, as this function is shared outside of prefetching.
        const fetchPriority = prefetchKind
          ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY
            ? 'high'
            : 'low'
          : 'auto';
        if (false) {
        }
        const res = await createFetch(
          url,
          headers,
          fetchPriority,
          abortController.signal
        );
        const responseUrl = urlToUrlWithoutFlightMarker(res.url);
        const canonicalUrl = res.redirected ? responseUrl : undefined;
        const contentType = res.headers.get('content-type') || '';
        const interception = !!((_res_headers_get = res.headers.get('vary')) == null
          ? void 0
          : _res_headers_get.includes(_approuterheaders.NEXT_URL));
        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);
        const staleTimeHeaderSeconds = res.headers.get(
          _approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER
        );
        const staleTime =
          staleTimeHeaderSeconds !== null
            ? parseInt(staleTimeHeaderSeconds, 10) * 1000
            : -1;
        let isFlightResponse = contentType.startsWith(
          _approuterheaders.RSC_CONTENT_TYPE_HEADER
        );
        if (false) {
        }
        // If fetch returns something different than flight response handle it like a mpa navigation
        // If the fetch was not 200, we also handle it like a mpa navigation
        if (!isFlightResponse || !res.ok || !res.body) {
          // in case the original URL came with a hash, preserve it before redirecting to the new URL
          if (url.hash) {
            responseUrl.hash = url.hash;
          }
          return doMpaNavigation(responseUrl.toString());
        }
        // We may navigate to a page that requires a different Webpack runtime.
        // In prod, every page will have the same Webpack runtime.
        // In dev, the Webpack runtime is minimal for each page.
        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.
        if (true) {
          await __webpack_require__(7839) /* .waitForWebpackRuntimeHotUpdate */
            .waitForWebpackRuntimeHotUpdate();
        }
        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.
        const flightStream = postponed
          ? createUnclosingPrefetchStream(res.body)
          : res.body;
        const response = await createFromNextReadableStream(flightStream);
        if ((0, _appbuildid.getAppBuildId)() !== response.b) {
          return doMpaNavigation(res.url);
        }
        return {
          flightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),
          canonicalUrl: canonicalUrl,
          couldBeIntercepted: interception,
          prerendered: response.S,
          postponed,
          staleTime,
        };
      } catch (err) {
        if (!abortController.signal.aborted) {
          console.error(
            'Failed to fetch RSC payload for ' +
              url +
              '. Falling back to browser navigation.',
            err
          );
        }
        // If fetch fails handle it like a mpa navigation
        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.
        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.
        return {
          flightData: url.toString(),
          canonicalUrl: undefined,
          couldBeIntercepted: false,
          prerendered: false,
          postponed: false,
          staleTime: -1,
        };
      }
    }
    function createFetch(url, headers, fetchPriority, signal) {
      const fetchUrl = new URL(url);
      // TODO: In output: "export" mode, the headers do nothing. Omit them (and the
      // cache busting search param) from the request so they're
      // maximally cacheable.
      (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);
      if (false) {
      }
      if (false) {
      }
      return fetch(fetchUrl, {
        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.
        credentials: 'same-origin',
        headers,
        priority: fetchPriority || undefined,
        signal,
      });
    }
    function createFromNextReadableStream(flightStream) {
      return createFromReadableStream(flightStream, {
        callServer: _appcallserver.callServer,
        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,
      });
    }
    function createUnclosingPrefetchStream(originalFlightStream) {
      // When PPR is enabled, prefetch streams may contain references that never
      // resolve, because that's how we encode dynamic data access. In the decoded
      // object returned by the Flight client, these are reified into hanging
      // promises that suspend during render, which is effectively what we want.
      // The UI resolves when it switches to the dynamic data stream
      // (via useDeferredValue(dynamic, static)).
      //
      // However, the Flight implementation currently errors if the server closes
      // the response before all the references are resolved. As a cheat to work
      // around this, we wrap the original stream in a new stream that never closes,
      // and therefore doesn't error.
      const reader = originalFlightStream.getReader();
      return new ReadableStream({
        async pull(controller) {
          while (true) {
            const { done, value } = await reader.read();
            if (!done) {
              // Pass to the target stream and keep consuming the Flight response
              // from the server.
              controller.enqueue(value);
              continue;
            }
            // The server stream has closed. Exit, but intentionally do not close
            // the target stream.
            return;
          }
        },
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=fetch-server-response.js.map
  },
  1258: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'getSegmentValue', {
      enumerable: true,
      get: function () {
        return getSegmentValue;
      },
    });
    function getSegmentValue(segment) {
      return Array.isArray(segment) ? segment[1] : segment;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=get-segment-value.js.map
  },
  9418: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'hasInterceptionRouteInCurrentTree', {
      enumerable: true,
      get: function () {
        return hasInterceptionRouteInCurrentTree;
      },
    });
    const _interceptionroutes = __webpack_require__(1412);
    function hasInterceptionRouteInCurrentTree(param) {
      let [segment, parallelRoutes] = param;
      // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.
      if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {
        return true;
      }
      // If segment is not an array, apply the existing string-based check
      if (
        typeof segment === 'string' &&
        (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)
      ) {
        return true;
      }
      // Iterate through parallelRoutes if they exist
      if (parallelRoutes) {
        for (const key in parallelRoutes) {
          if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {
            return true;
          }
        }
      }
      return false;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=has-interception-route-in-current-tree.js.map
  },
  77: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ACTION_HMR_REFRESH: function () {
        return ACTION_HMR_REFRESH;
      },
      ACTION_NAVIGATE: function () {
        return ACTION_NAVIGATE;
      },
      ACTION_PREFETCH: function () {
        return ACTION_PREFETCH;
      },
      ACTION_REFRESH: function () {
        return ACTION_REFRESH;
      },
      ACTION_RESTORE: function () {
        return ACTION_RESTORE;
      },
      ACTION_SERVER_ACTION: function () {
        return ACTION_SERVER_ACTION;
      },
      ACTION_SERVER_PATCH: function () {
        return ACTION_SERVER_PATCH;
      },
      PrefetchCacheEntryStatus: function () {
        return PrefetchCacheEntryStatus;
      },
      PrefetchKind: function () {
        return PrefetchKind;
      },
    });
    const ACTION_REFRESH = 'refresh';
    const ACTION_NAVIGATE = 'navigate';
    const ACTION_RESTORE = 'restore';
    const ACTION_SERVER_PATCH = 'server-patch';
    const ACTION_PREFETCH = 'prefetch';
    const ACTION_HMR_REFRESH = 'hmr-refresh';
    const ACTION_SERVER_ACTION = 'server-action';
    var PrefetchKind = /*#__PURE__*/ (function (PrefetchKind) {
      PrefetchKind['AUTO'] = 'auto';
      PrefetchKind['FULL'] = 'full';
      PrefetchKind['TEMPORARY'] = 'temporary';
      return PrefetchKind;
    })({});
    var PrefetchCacheEntryStatus = /*#__PURE__*/ (function (PrefetchCacheEntryStatus) {
      PrefetchCacheEntryStatus['fresh'] = 'fresh';
      PrefetchCacheEntryStatus['reusable'] = 'reusable';
      PrefetchCacheEntryStatus['expired'] = 'expired';
      PrefetchCacheEntryStatus['stale'] = 'stale';
      return PrefetchCacheEntryStatus;
    })({});
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=router-reducer-types.js.map
  },
  5567: function (module, exports, __webpack_require__) {
    'use strict';
    /* __next_internal_client_entry_do_not_use__  cjs */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'setCacheBustingSearchParam', {
      enumerable: true,
      get: function () {
        return setCacheBustingSearchParam;
      },
    });
    const _hash = __webpack_require__(1180);
    const _approuterheaders = __webpack_require__(7079);
    const setCacheBustingSearchParam = (url, headers) => {
      const uniqueCacheKey = (0, _hash.hexHash)(
        [
          headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] || '0',
          headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] || '0',
          headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER],
          headers[_approuterheaders.NEXT_URL],
        ].join(',')
      );
      /**
       * Note that we intentionally do not use `url.searchParams.set` here:
       *
       * Const url = new URL('https://example.com/search?q=custom%20spacing');
       * url.searchParams.set('_rsc', 'abc123'); console.log(url.toString()); // Outputs:
       * https://example.com/search?q=custom+spacing&_rsc=abc123 ^ <--- this is causing
       * confusion This is in fact intended based on
       * https://url.spec.whatwg.org/#interface-urlsearchparams, but we want to preserve the
       * %20 as %20 if that's what the user passed in, hence the custom logic below.
       */ const existingSearch = url.search;
      const rawQuery = existingSearch.startsWith('?')
        ? existingSearch.slice(1)
        : existingSearch;
      const pairs = rawQuery.split('&').filter(Boolean);
      pairs.push(_approuterheaders.NEXT_RSC_UNION_QUERY + '=' + uniqueCacheKey);
      url.search = pairs.length ? '?' + pairs.join('&') : '';
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=set-cache-busting-search-param.js.map
  },
  2661: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      StaticGenBailoutError: function () {
        return StaticGenBailoutError;
      },
      isStaticGenBailoutError: function () {
        return isStaticGenBailoutError;
      },
    });
    const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';
    class StaticGenBailoutError extends Error {
      constructor(...args) {
        super(...args), (this.code = NEXT_STATIC_GEN_BAILOUT);
      }
    }
    function isStaticGenBailoutError(error) {
      if (typeof error !== 'object' || error === null || !('code' in error)) {
        return false;
      }
      return error.code === NEXT_STATIC_GEN_BAILOUT;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=static-generation-bailout.js.map
  },
  208: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'unauthorized', {
      enumerable: true,
      get: function () {
        return unauthorized;
      },
    });
    const _httpaccessfallback = __webpack_require__(4114);
    // TODO: Add `unauthorized` docs
    /**
     * @experimental
     * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)
     * within a route segment as well as inject a tag.
     *
     * `unauthorized()` can be used in
     * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
     * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
     * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
     *
     *
     * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)
     */ const DIGEST = '' + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ';401';
    function unauthorized() {
      if (true) {
        throw Object.defineProperty(
          new Error(
            '`unauthorized()` is experimental and only allowed to be used when `experimental.authInterrupts` is enabled.'
          ),
          '__NEXT_ERROR_CODE',
          {
            value: 'E411',
            enumerable: false,
            configurable: true,
          }
        );
      }
      // eslint-disable-next-line no-throw-literal
      const error = Object.defineProperty(new Error(DIGEST), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: false,
        configurable: true,
      });
      error.digest = DIGEST;
      throw error;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=unauthorized.js.map
  },
  1470: function (module, exports) {
    'use strict';
    /**
     * Create a "Thenable" that does not resolve. This is used to suspend indefinitely when
     * data is not available yet.
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'unresolvedThenable', {
      enumerable: true,
      get: function () {
        return unresolvedThenable;
      },
    });
    const unresolvedThenable = {
      then: () => {},
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=unresolved-thenable.js.map
  },
  8319: function (module, exports, __webpack_require__) {
    'use strict';
    /**
     * This function should be used to rethrow internal Next.js errors so that they can be
     * handled by the framework. When wrapping an API that uses errors to interrupt control
     * flow, you should use this function before you do any error handling. This function will
     * rethrow the error if it is a Next.js error so it can be handled, otherwise it will do
     * nothing.
     *
     * Read more: [Next.js Docs:
     * `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'unstable_rethrow', {
      enumerable: true,
      get: function () {
        return unstable_rethrow;
      },
    });
    const unstable_rethrow = true
      ? __webpack_require__(367) /* .unstable_rethrow */.unstable_rethrow
      : 0;
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=unstable-rethrow.js.map
  },
  367: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'unstable_rethrow', {
      enumerable: true,
      get: function () {
        return unstable_rethrow;
      },
    });
    const _dynamicrenderingutils = __webpack_require__(7354);
    const _ispostpone = __webpack_require__(6797);
    const _bailouttocsr = __webpack_require__(2926);
    const _isnextroutererror = __webpack_require__(9603);
    const _dynamicrendering = __webpack_require__(9948);
    const _hooksservercontext = __webpack_require__(2129);
    function unstable_rethrow(error) {
      if (
        (0, _isnextroutererror.isNextRouterError)(error) ||
        (0, _bailouttocsr.isBailoutToCSRError)(error) ||
        (0, _hooksservercontext.isDynamicServerError)(error) ||
        (0, _dynamicrendering.isDynamicPostpone)(error) ||
        (0, _ispostpone.isPostpone)(error) ||
        (0, _dynamicrenderingutils.isHangingPromiseRejectionError)(error)
      ) {
        throw error;
      }
      if (error instanceof Error && 'cause' in error) {
        unstable_rethrow(error.cause);
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=unstable-rethrow.server.js.map
  },
  4297: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      dispatchAppRouterAction: function () {
        return dispatchAppRouterAction;
      },
      useActionQueue: function () {
        return useActionQueue;
      },
    });
    const _interop_require_wildcard = __webpack_require__(315);
    const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(863));
    const _isthenable = __webpack_require__(6066);
    // The app router state lives outside of React, so we can import the dispatch
    // method directly wherever we need it, rather than passing it around via props
    // or context.
    let dispatch = null;
    function dispatchAppRouterAction(action) {
      if (dispatch === null) {
        throw Object.defineProperty(
          new Error(
            'Internal Next.js error: Router action dispatched before initialization.'
          ),
          '__NEXT_ERROR_CODE',
          {
            value: 'E668',
            enumerable: false,
            configurable: true,
          }
        );
      }
      dispatch(action);
    }
    function useActionQueue(actionQueue) {
      const [state, setState] = _react.default.useState(actionQueue.state);
      // Because of a known issue that requires to decode Flight streams inside the
      // render phase, we have to be a bit clever and assign the dispatch method to
      // a module-level variable upon initialization. The useState hook in this
      // module only exists to synchronize state that lives outside of React.
      // Ideally, what we'd do instead is pass the state as a prop to root.render;
      // this is conceptually how we're modeling the app router state, despite the
      // weird implementation details.
      if (true) {
        const useSyncDevRenderIndicator =
          __webpack_require__(
            117
          ) /* .useSyncDevRenderIndicator */.useSyncDevRenderIndicator;
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const syncDevRenderIndicator = useSyncDevRenderIndicator();
        dispatch = (action) => {
          syncDevRenderIndicator(() => {
            actionQueue.dispatch(action, setState);
          });
        };
      } else {
      }
      return (0, _isthenable.isThenable)(state) ? (0, _react.use)(state) : state;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=use-action-queue.js.map
  },
  6133: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'devBuildIndicator', {
      enumerable: true,
      get: function () {
        return devBuildIndicator;
      },
    });
    const _initialize = __webpack_require__(3125);
    const NOOP = () => {};
    const devBuildIndicator = {
      /** Shows build indicator when Next.js is compiling. Requires initialize() first. */ show: NOOP,
      /** Hides build indicator when Next.js finishes compiling. Requires initialize() first. */ hide: NOOP,
      /** Sets up the build indicator UI component. Call this before using show/hide. */ initialize:
        _initialize.initialize,
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=dev-build-indicator.js.map
  },
  8297: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'handleDevBuildIndicatorHmrEvents', {
      enumerable: true,
      get: function () {
        return handleDevBuildIndicatorHmrEvents;
      },
    });
    const _hotreloadertypes = __webpack_require__(6758);
    const _devbuildindicator = __webpack_require__(6133);
    const handleDevBuildIndicatorHmrEvents = (obj) => {
      try {
        if (!('action' in obj)) {
          return;
        }
        // eslint-disable-next-line default-case
        switch (obj.action) {
          case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING:
            _devbuildindicator.devBuildIndicator.show();
            break;
          case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT:
          case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SYNC:
            _devbuildindicator.devBuildIndicator.hide();
            break;
        }
      } catch (e) {}
    };
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=handle-dev-build-indicator-hmr-events.js.map
  },
  3125: function (module, exports, __webpack_require__) {
    'use strict';
    /*
     * Singleton store to track whether the app is currently being built
     * Used by the dev tools indicator of the new overlay to show build status
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      initialize: function () {
        return initialize;
      },
      useIsDevBuilding: function () {
        return useIsDevBuilding;
      },
    });
    const _devbuildindicator = __webpack_require__(6133);
    const _react = __webpack_require__(863);
    let isVisible = false;
    let listeners = [];
    const subscribe = (listener) => {
      listeners.push(listener);
      return () => {
        listeners = listeners.filter((l) => l !== listener);
      };
    };
    const getSnapshot = () => isVisible;
    function useIsDevBuilding() {
      return (0, _react.useSyncExternalStore)(subscribe, getSnapshot);
    }
    function initialize() {
      _devbuildindicator.devBuildIndicator.show = () => {
        isVisible = true;
        listeners.forEach((listener) => listener());
      };
      _devbuildindicator.devBuildIndicator.hide = () => {
        isVisible = false;
        listeners.forEach((listener) => listener());
      };
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=initialize.js.map
  },
  9913: function (module, exports) {
    'use strict';
    // The Turbopack HMR client can't be properly omitted at the moment (WEB-1589),
    // so instead we remap its import to this file in webpack builds.

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'connect', {
      enumerable: true,
      get: function () {
        return connect;
      },
    });
    function connect() {}
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=noop-turbopack-hmr.js.map
  },
  7343: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getFlightDataPartsFromPath: function () {
        return getFlightDataPartsFromPath;
      },
      getNextFlightSegmentPath: function () {
        return getNextFlightSegmentPath;
      },
      normalizeFlightData: function () {
        return normalizeFlightData;
      },
    });
    function getFlightDataPartsFromPath(flightDataPath) {
      // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].
      const flightDataPathLength = 4;
      // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.
      const [tree, seedData, head, isHeadPartial] =
        flightDataPath.slice(-flightDataPathLength);
      // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.
      const segmentPath = flightDataPath.slice(0, -flightDataPathLength);
      var _segmentPath_;
      return {
        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment ("")
        // to the start of the segment path in some places which makes it hard to use solely the segment path.
        // Look for "// TODO-APP: remove ''" in the codebase.
        pathToSegment: segmentPath.slice(0, -1),
        segmentPath,
        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,
        // in which case we default to ''.
        segment:
          (_segmentPath_ = segmentPath[segmentPath.length - 1]) != null
            ? _segmentPath_
            : '',
        tree,
        seedData,
        head,
        isHeadPartial,
        isRootRender: flightDataPath.length === flightDataPathLength,
      };
    }
    function getNextFlightSegmentPath(flightSegmentPath) {
      // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items
      // to get the next segment path.
      return flightSegmentPath.slice(2);
    }
    function normalizeFlightData(flightData) {
      // FlightData can be a string when the server didn't respond with a proper flight response,
      // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.
      if (typeof flightData === 'string') {
        return flightData;
      }
      return flightData.map(getFlightDataPartsFromPath);
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=flight-data-helpers.js.map
  },
  4866: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      formatConsoleArgs: function () {
        return formatConsoleArgs;
      },
      parseConsoleArgs: function () {
        return parseConsoleArgs;
      },
    });
    const _interop_require_default = __webpack_require__(3899);
    const _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(5336));
    function formatObject(arg, depth) {
      switch (typeof arg) {
        case 'object':
          if (arg === null) {
            return 'null';
          } else if (Array.isArray(arg)) {
            let result = '[';
            if (depth < 1) {
              for (let i = 0; i < arg.length; i++) {
                if (result !== '[') {
                  result += ',';
                }
                if (Object.prototype.hasOwnProperty.call(arg, i)) {
                  result += formatObject(arg[i], depth + 1);
                }
              }
            } else {
              result += arg.length > 0 ? '...' : '';
            }
            result += ']';
            return result;
          } else if (arg instanceof Error) {
            return arg + '';
          } else {
            const keys = Object.keys(arg);
            let result = '{';
            if (depth < 1) {
              for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const desc = Object.getOwnPropertyDescriptor(arg, 'key');
                if (desc && !desc.get && !desc.set) {
                  const jsonKey = JSON.stringify(key);
                  if (jsonKey !== '"' + key + '"') {
                    result += jsonKey + ': ';
                  } else {
                    result += key + ': ';
                  }
                  result += formatObject(desc.value, depth + 1);
                }
              }
            } else {
              result += keys.length > 0 ? '...' : '';
            }
            result += '}';
            return result;
          }
        case 'string':
          return JSON.stringify(arg);
        default:
          return String(arg);
      }
    }
    function formatConsoleArgs(args) {
      let message;
      let idx;
      if (typeof args[0] === 'string') {
        message = args[0];
        idx = 1;
      } else {
        message = '';
        idx = 0;
      }
      let result = '';
      let startQuote = false;
      for (let i = 0; i < message.length; ++i) {
        const char = message[i];
        if (char !== '%' || i === message.length - 1 || idx >= args.length) {
          result += char;
          continue;
        }
        const code = message[++i];
        switch (code) {
          case 'c': {
            // TODO: We should colorize with HTML instead of turning into a string.
            // Ignore for now.
            result = startQuote ? '' + result + ']' : '[' + result;
            startQuote = !startQuote;
            idx++;
            break;
          }
          case 'O':
          case 'o': {
            result += formatObject(args[idx++], 0);
            break;
          }
          case 'd':
          case 'i': {
            result += parseInt(args[idx++], 10);
            break;
          }
          case 'f': {
            result += parseFloat(args[idx++]);
            break;
          }
          case 's': {
            result += String(args[idx++]);
            break;
          }
          default:
            result += '%' + code;
        }
      }
      for (; idx < args.length; idx++) {
        result += (idx > 0 ? ' ' : '') + formatObject(args[idx], 0);
      }
      return result;
    }
    function parseConsoleArgs(args) {
      // See
      // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93
      //
      // Logs replayed from the server look like this:
      // [
      //   "%c%s%c %o\n\n%s\n\n%s\n",
      //   "background: #e6e6e6; ...",
      //   " Server ", // can also be e.g. " Prerender "
      //   "",
      //   Error,
      //   "The above error occurred in the <Page> component.",
      //   ...
      // ]
      if (
        args.length > 3 &&
        typeof args[0] === 'string' &&
        args[0].startsWith('%c%s%c ') &&
        typeof args[1] === 'string' &&
        typeof args[2] === 'string' &&
        typeof args[3] === 'string'
      ) {
        const environmentName = args[2];
        const maybeError = args[4];
        return {
          environmentName: environmentName.trim(),
          error: (0, _iserror.default)(maybeError) ? maybeError : null,
        };
      }
      return {
        environmentName: null,
        error: null,
      };
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=console.js.map
  },
  1238: function (module) {
    (() => {
      'use strict';
      var e = {
        211: (e) => {
          var r = (function () {
            function defineProperties(e, r) {
              for (var n = 0; n < r.length; n++) {
                var s = r[n];
                s.enumerable = s.enumerable || false;
                s.configurable = true;
                if ('value' in s) s.writable = true;
                Object.defineProperty(e, s.key, s);
              }
            }
            return function (e, r, n) {
              if (r) defineProperties(e.prototype, r);
              if (n) defineProperties(e, n);
              return e;
            };
          })();
          function _classCallCheck(e, r) {
            if (!(e instanceof r)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var n = [
            [
              { color: '0, 0, 0', class: 'ansi-black' },
              { color: '187, 0, 0', class: 'ansi-red' },
              { color: '0, 187, 0', class: 'ansi-green' },
              { color: '187, 187, 0', class: 'ansi-yellow' },
              { color: '0, 0, 187', class: 'ansi-blue' },
              { color: '187, 0, 187', class: 'ansi-magenta' },
              { color: '0, 187, 187', class: 'ansi-cyan' },
              { color: '255,255,255', class: 'ansi-white' },
            ],
            [
              { color: '85, 85, 85', class: 'ansi-bright-black' },
              { color: '255, 85, 85', class: 'ansi-bright-red' },
              { color: '0, 255, 0', class: 'ansi-bright-green' },
              { color: '255, 255, 85', class: 'ansi-bright-yellow' },
              { color: '85, 85, 255', class: 'ansi-bright-blue' },
              { color: '255, 85, 255', class: 'ansi-bright-magenta' },
              { color: '85, 255, 255', class: 'ansi-bright-cyan' },
              { color: '255, 255, 255', class: 'ansi-bright-white' },
            ],
          ];
          var s = (function () {
            r(Anser, null, [
              {
                key: 'escapeForHtml',
                value: function escapeForHtml(e) {
                  return new Anser().escapeForHtml(e);
                },
              },
              {
                key: 'linkify',
                value: function linkify(e) {
                  return new Anser().linkify(e);
                },
              },
              {
                key: 'ansiToHtml',
                value: function ansiToHtml(e, r) {
                  return new Anser().ansiToHtml(e, r);
                },
              },
              {
                key: 'ansiToJson',
                value: function ansiToJson(e, r) {
                  return new Anser().ansiToJson(e, r);
                },
              },
              {
                key: 'ansiToText',
                value: function ansiToText(e) {
                  return new Anser().ansiToText(e);
                },
              },
            ]);
            function Anser() {
              _classCallCheck(this, Anser);
              this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
              this.bright = 0;
            }
            r(Anser, [
              {
                key: 'setupPalette',
                value: function setupPalette() {
                  this.PALETTE_COLORS = [];
                  for (var e = 0; e < 2; ++e) {
                    for (var r = 0; r < 8; ++r) {
                      this.PALETTE_COLORS.push(n[e][r].color);
                    }
                  }
                  var s = [0, 95, 135, 175, 215, 255];
                  var i = function format(e, r, n) {
                    return s[e] + ', ' + s[r] + ', ' + s[n];
                  };
                  var t = void 0,
                    o = void 0,
                    a = void 0;
                  for (var l = 0; l < 6; ++l) {
                    for (var c = 0; c < 6; ++c) {
                      for (var u = 0; u < 6; ++u) {
                        this.PALETTE_COLORS.push(i(l, c, u));
                      }
                    }
                  }
                  var f = 8;
                  for (var h = 0; h < 24; ++h, f += 10) {
                    this.PALETTE_COLORS.push(i(f, f, f));
                  }
                },
              },
              {
                key: 'escapeForHtml',
                value: function escapeForHtml(e) {
                  return e.replace(/[&<>]/gm, function (e) {
                    return e == '&'
                      ? '&amp;'
                      : e == '<'
                        ? '&lt;'
                        : e == '>'
                          ? '&gt;'
                          : '';
                  });
                },
              },
              {
                key: 'linkify',
                value: function linkify(e) {
                  return e.replace(/(https?:\/\/[^\s]+)/gm, function (e) {
                    return '<a href="' + e + '">' + e + '</a>';
                  });
                },
              },
              {
                key: 'ansiToHtml',
                value: function ansiToHtml(e, r) {
                  return this.process(e, r, true);
                },
              },
              {
                key: 'ansiToJson',
                value: function ansiToJson(e, r) {
                  r = r || {};
                  r.json = true;
                  r.clearLine = false;
                  return this.process(e, r, true);
                },
              },
              {
                key: 'ansiToText',
                value: function ansiToText(e) {
                  return this.process(e, {}, false);
                },
              },
              {
                key: 'process',
                value: function process(e, r, n) {
                  var s = this;
                  var i = this;
                  var t = e.split(/\033\[/);
                  var o = t.shift();
                  if (r === undefined || r === null) {
                    r = {};
                  }
                  r.clearLine = /\r/.test(e);
                  var a = t.map(function (e) {
                    return s.processChunk(e, r, n);
                  });
                  if (r && r.json) {
                    var l = i.processChunkJson('');
                    l.content = o;
                    l.clearLine = r.clearLine;
                    a.unshift(l);
                    if (r.remove_empty) {
                      a = a.filter(function (e) {
                        return !e.isEmpty();
                      });
                    }
                    return a;
                  } else {
                    a.unshift(o);
                  }
                  return a.join('');
                },
              },
              {
                key: 'processChunkJson',
                value: function processChunkJson(e, r, s) {
                  r = typeof r == 'undefined' ? {} : r;
                  var i = (r.use_classes =
                    typeof r.use_classes != 'undefined' && r.use_classes);
                  var t = (r.key = i ? 'class' : 'color');
                  var o = {
                    content: e,
                    fg: null,
                    bg: null,
                    fg_truecolor: null,
                    bg_truecolor: null,
                    clearLine: r.clearLine,
                    decoration: null,
                    was_processed: false,
                    isEmpty: function isEmpty() {
                      return !o.content;
                    },
                  };
                  var a = e.match(
                    /^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m
                  );
                  if (!a) return o;
                  var l = (o.content = a[4]);
                  var c = a[2].split(';');
                  if (a[1] !== '' || a[3] !== 'm') {
                    return o;
                  }
                  if (!s) {
                    return o;
                  }
                  var u = this;
                  u.decoration = null;
                  while (c.length > 0) {
                    var f = c.shift();
                    var h = parseInt(f);
                    if (isNaN(h) || h === 0) {
                      u.fg = u.bg = u.decoration = null;
                    } else if (h === 1) {
                      u.decoration = 'bold';
                    } else if (h === 2) {
                      u.decoration = 'dim';
                    } else if (h == 3) {
                      u.decoration = 'italic';
                    } else if (h == 4) {
                      u.decoration = 'underline';
                    } else if (h == 5) {
                      u.decoration = 'blink';
                    } else if (h === 7) {
                      u.decoration = 'reverse';
                    } else if (h === 8) {
                      u.decoration = 'hidden';
                    } else if (h === 9) {
                      u.decoration = 'strikethrough';
                    } else if (h == 39) {
                      u.fg = null;
                    } else if (h == 49) {
                      u.bg = null;
                    } else if (h >= 30 && h < 38) {
                      u.fg = n[0][h % 10][t];
                    } else if (h >= 90 && h < 98) {
                      u.fg = n[1][h % 10][t];
                    } else if (h >= 40 && h < 48) {
                      u.bg = n[0][h % 10][t];
                    } else if (h >= 100 && h < 108) {
                      u.bg = n[1][h % 10][t];
                    } else if (h === 38 || h === 48) {
                      var p = h === 38;
                      if (c.length >= 1) {
                        var g = c.shift();
                        if (g === '5' && c.length >= 1) {
                          var v = parseInt(c.shift());
                          if (v >= 0 && v <= 255) {
                            if (!i) {
                              if (!this.PALETTE_COLORS) {
                                u.setupPalette();
                              }
                              if (p) {
                                u.fg = this.PALETTE_COLORS[v];
                              } else {
                                u.bg = this.PALETTE_COLORS[v];
                              }
                            } else {
                              var d =
                                v >= 16
                                  ? 'ansi-palette-' + v
                                  : n[v > 7 ? 1 : 0][v % 8]['class'];
                              if (p) {
                                u.fg = d;
                              } else {
                                u.bg = d;
                              }
                            }
                          }
                        } else if (g === '2' && c.length >= 3) {
                          var _ = parseInt(c.shift());
                          var b = parseInt(c.shift());
                          var y = parseInt(c.shift());
                          if (
                            _ >= 0 &&
                            _ <= 255 &&
                            b >= 0 &&
                            b <= 255 &&
                            y >= 0 &&
                            y <= 255
                          ) {
                            var k = _ + ', ' + b + ', ' + y;
                            if (!i) {
                              if (p) {
                                u.fg = k;
                              } else {
                                u.bg = k;
                              }
                            } else {
                              if (p) {
                                u.fg = 'ansi-truecolor';
                                u.fg_truecolor = k;
                              } else {
                                u.bg = 'ansi-truecolor';
                                u.bg_truecolor = k;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (u.fg === null && u.bg === null && u.decoration === null) {
                    return o;
                  } else {
                    var T = [];
                    var m = [];
                    var w = {};
                    o.fg = u.fg;
                    o.bg = u.bg;
                    o.fg_truecolor = u.fg_truecolor;
                    o.bg_truecolor = u.bg_truecolor;
                    o.decoration = u.decoration;
                    o.was_processed = true;
                    return o;
                  }
                },
              },
              {
                key: 'processChunk',
                value: function processChunk(e, r, n) {
                  var s = this;
                  var i = this;
                  r = r || {};
                  var t = this.processChunkJson(e, r, n);
                  if (r.json) {
                    return t;
                  }
                  if (t.isEmpty()) {
                    return '';
                  }
                  if (!t.was_processed) {
                    return t.content;
                  }
                  var o = r.use_classes;
                  var a = [];
                  var l = [];
                  var c = {};
                  var u = function render_data(e) {
                    var r = [];
                    var n = void 0;
                    for (n in e) {
                      if (e.hasOwnProperty(n)) {
                        r.push('data-' + n + '="' + s.escapeForHtml(e[n]) + '"');
                      }
                    }
                    return r.length > 0 ? ' ' + r.join(' ') : '';
                  };
                  if (t.fg) {
                    if (o) {
                      l.push(t.fg + '-fg');
                      if (t.fg_truecolor !== null) {
                        c['ansi-truecolor-fg'] = t.fg_truecolor;
                        t.fg_truecolor = null;
                      }
                    } else {
                      a.push('color:rgb(' + t.fg + ')');
                    }
                  }
                  if (t.bg) {
                    if (o) {
                      l.push(t.bg + '-bg');
                      if (t.bg_truecolor !== null) {
                        c['ansi-truecolor-bg'] = t.bg_truecolor;
                        t.bg_truecolor = null;
                      }
                    } else {
                      a.push('background-color:rgb(' + t.bg + ')');
                    }
                  }
                  if (t.decoration) {
                    if (o) {
                      l.push('ansi-' + t.decoration);
                    } else if (t.decoration === 'bold') {
                      a.push('font-weight:bold');
                    } else if (t.decoration === 'dim') {
                      a.push('opacity:0.5');
                    } else if (t.decoration === 'italic') {
                      a.push('font-style:italic');
                    } else if (t.decoration === 'reverse') {
                      a.push('filter:invert(100%)');
                    } else if (t.decoration === 'hidden') {
                      a.push('visibility:hidden');
                    } else if (t.decoration === 'strikethrough') {
                      a.push('text-decoration:line-through');
                    } else {
                      a.push('text-decoration:' + t.decoration);
                    }
                  }
                  if (o) {
                    return (
                      '<span class="' +
                      l.join(' ') +
                      '"' +
                      u(c) +
                      '>' +
                      t.content +
                      '</span>'
                    );
                  } else {
                    return (
                      '<span style="' +
                      a.join(';') +
                      '"' +
                      u(c) +
                      '>' +
                      t.content +
                      '</span>'
                    );
                  }
                },
              },
            ]);
            return Anser;
          })();
          e.exports = s;
        },
      };
      var r = {};
      function __nccwpck_require__(n) {
        var s = r[n];
        if (s !== undefined) {
          return s.exports;
        }
        var i = (r[n] = { exports: {} });
        var t = true;
        try {
          e[n](i, i.exports, __nccwpck_require__);
          t = false;
        } finally {
          if (t) delete r[n];
        }
        return i.exports;
      }
      if (typeof __nccwpck_require__ !== 'undefined')
        __nccwpck_require__.ab = __dirname + '/';
      var n = __nccwpck_require__(211);
      module.exports = n;
    })();
  },
  8027: function (module) {
    (() => {
      'use strict';
      if (typeof __nccwpck_require__ !== 'undefined')
        __nccwpck_require__.ab = __dirname + '/';
      var e = {};
      (() => {
        var r = e;
        Object.defineProperty(r, '__esModule', { value: true });
        var n = '<unknown>';
        function parse(e) {
          var r = e.split('\n');
          return r.reduce(function (e, r) {
            var n =
              parseChrome(r) ||
              parseWinjs(r) ||
              parseGecko(r) ||
              parseNode(r) ||
              parseJSC(r);
            if (n) {
              e.push(n);
            }
            return e;
          }, []);
        }
        var a =
          /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|webpack-internal|rsc|turbopack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
        var l = /\((\S*)(?::(\d+))(?::(\d+))\)/;
        function parseChrome(e) {
          var r = a.exec(e);
          if (!r) {
            return null;
          }
          var u = r[2] && r[2].indexOf('native') === 0;
          var t = r[2] && r[2].indexOf('eval') === 0;
          var i = l.exec(r[2]);
          if (t && i != null) {
            r[2] = i[1];
            r[3] = i[2];
            r[4] = i[3];
          }
          return {
            file: !u ? r[2] : null,
            methodName: r[1] || n,
            arguments: u ? [r[2]] : [],
            lineNumber: r[3] ? +r[3] : null,
            column: r[4] ? +r[4] : null,
          };
        }
        var u =
          /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|webpack-internal|rsc|turbopack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
        function parseWinjs(e) {
          var r = u.exec(e);
          if (!r) {
            return null;
          }
          return {
            file: r[2],
            methodName: r[1] || n,
            arguments: [],
            lineNumber: +r[3],
            column: r[4] ? +r[4] : null,
          };
        }
        var t =
          /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|webpack-internal|rsc|turbopack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
        var i = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
        function parseGecko(e) {
          var r = t.exec(e);
          if (!r) {
            return null;
          }
          var a = r[3] && r[3].indexOf(' > eval') > -1;
          var l = i.exec(r[3]);
          if (a && l != null) {
            r[3] = l[1];
            r[4] = l[2];
            r[5] = null;
          }
          return {
            file: r[3],
            methodName: r[1] || n,
            arguments: r[2] ? r[2].split(',') : [],
            lineNumber: r[4] ? +r[4] : null,
            column: r[5] ? +r[5] : null,
          };
        }
        var s = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
        function parseJSC(e) {
          var r = s.exec(e);
          if (!r) {
            return null;
          }
          return {
            file: r[3],
            methodName: r[1] || n,
            arguments: [],
            lineNumber: +r[4],
            column: r[5] ? +r[5] : null,
          };
        }
        var c =
          /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
        function parseNode(e) {
          var r = c.exec(e);
          if (!r) {
            return null;
          }
          return {
            file: r[2],
            methodName: r[1] || n,
            arguments: [],
            lineNumber: +r[3],
            column: r[4] ? +r[4] : null,
          };
        }
        r.parse = parse;
      })();
      module.exports = e;
    })();
  },
  7976: function (module) {
    'use strict';

    (() => {
      'use strict';
      var e = {
        511: (e) => {
          e.exports = ({ onlyFirst: e = false } = {}) => {
            const r = [
              '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
              '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))',
            ].join('|');
            return new RegExp(r, e ? undefined : 'g');
          };
        },
        532: (e, r, _) => {
          const t = _(511);
          e.exports = (e) => (typeof e === 'string' ? e.replace(t(), '') : e);
        },
      };
      var r = {};
      function __nccwpck_require__(_) {
        var t = r[_];
        if (t !== undefined) {
          return t.exports;
        }
        var a = (r[_] = {
          exports: {},
        });
        var n = true;
        try {
          e[_](a, a.exports, __nccwpck_require__);
          n = false;
        } finally {
          if (n) delete r[_];
        }
        return a.exports;
      }
      if (typeof __nccwpck_require__ !== 'undefined')
        __nccwpck_require__.ab = __dirname + '/';
      var _ = __nccwpck_require__(532);
      module.exports = _;
    })();
  },
  8053: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      copyNextErrorCode: function () {
        return copyNextErrorCode;
      },
      createDigestWithErrorCode: function () {
        return createDigestWithErrorCode;
      },
      extractNextErrorCode: function () {
        return extractNextErrorCode;
      },
    });
    const ERROR_CODE_DELIMITER = '@';
    const createDigestWithErrorCode = (thrownValue, originalDigest) => {
      if (
        typeof thrownValue === 'object' &&
        thrownValue !== null &&
        '__NEXT_ERROR_CODE' in thrownValue
      ) {
        return `${originalDigest}${ERROR_CODE_DELIMITER}${thrownValue.__NEXT_ERROR_CODE}`;
      }
      return originalDigest;
    };
    const copyNextErrorCode = (source, target) => {
      const errorCode = extractNextErrorCode(source);
      if (errorCode && typeof target === 'object' && target !== null) {
        Object.defineProperty(target, '__NEXT_ERROR_CODE', {
          value: errorCode,
          enumerable: false,
          configurable: true,
        });
      }
    };
    const extractNextErrorCode = (error) => {
      if (
        typeof error === 'object' &&
        error !== null &&
        '__NEXT_ERROR_CODE' in error &&
        typeof error.__NEXT_ERROR_CODE === 'string'
      ) {
        return error.__NEXT_ERROR_CODE;
      }
      if (
        typeof error === 'object' &&
        error !== null &&
        'digest' in error &&
        typeof error.digest === 'string'
      ) {
        const segments = error.digest.split(ERROR_CODE_DELIMITER);
        const errorCode = segments.find((segment) => segment.startsWith('E'));
        return errorCode;
      }
      return undefined;
    };

    //# sourceMappingURL=error-telemetry-utils.js.map
  },
  5336: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      /**
       * Checks whether the given value is a NextError. This can be used to print a more
       * detailed error message with properties like `code` & `digest`.
       */ default: function () {
        return isError;
      },
      getProperError: function () {
        return getProperError;
      },
    });
    const _isplainobject = __webpack_require__(4144);
    function isError(err) {
      return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;
    }
    function safeStringify(obj) {
      const seen = new WeakSet();
      return JSON.stringify(obj, (_key, value) => {
        // If value is an object and already seen, replace with "[Circular]"
        if (typeof value === 'object' && value !== null) {
          if (seen.has(value)) {
            return '[Circular]';
          }
          seen.add(value);
        }
        return value;
      });
    }
    function getProperError(err) {
      if (isError(err)) {
        return err;
      }
      if (true) {
        // provide better error for case where `throw undefined`
        // is called in development
        if (typeof err === 'undefined') {
          return Object.defineProperty(
            new Error(
              'An undefined error was thrown, ' +
                'see here for more info: https://nextjs.org/docs/messages/threw-undefined'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E98',
              enumerable: false,
              configurable: true,
            }
          );
        }
        if (err === null) {
          return Object.defineProperty(
            new Error(
              'A null error was thrown, ' +
                'see here for more info: https://nextjs.org/docs/messages/threw-undefined'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E336',
              enumerable: false,
              configurable: true,
            }
          );
        }
      }
      return Object.defineProperty(
        new Error((0, _isplainobject.isPlainObject)(err) ? safeStringify(err) : err + ''),
        '__NEXT_ERROR_CODE',
        {
          value: 'E394',
          enumerable: false,
          configurable: true,
        }
      );
    }

    //# sourceMappingURL=is-error.js.map
  },
  6859: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      METADATA_BOUNDARY_NAME: function () {
        return METADATA_BOUNDARY_NAME;
      },
      OUTLET_BOUNDARY_NAME: function () {
        return OUTLET_BOUNDARY_NAME;
      },
      VIEWPORT_BOUNDARY_NAME: function () {
        return VIEWPORT_BOUNDARY_NAME;
      },
    });
    const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';
    const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';
    const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__';

    //# sourceMappingURL=metadata-constants.js.map
  },
  6057: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      atLeastOneTask: function () {
        return atLeastOneTask;
      },
      scheduleImmediate: function () {
        return scheduleImmediate;
      },
      scheduleOnNextTick: function () {
        return scheduleOnNextTick;
      },
      waitAtLeastOneReactRenderTask: function () {
        return waitAtLeastOneReactRenderTask;
      },
    });
    const scheduleOnNextTick = (cb) => {
      // We use Promise.resolve().then() here so that the operation is scheduled at
      // the end of the promise job queue, we then add it to the next process tick
      // to ensure it's evaluated afterwards.
      //
      // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255
      //
      Promise.resolve().then(() => {
        if (false) {
        } else {
          process.nextTick(cb);
        }
      });
    };
    const scheduleImmediate = (cb) => {
      if (false) {
      } else {
        setImmediate(cb);
      }
    };
    function atLeastOneTask() {
      return new Promise((resolve) => scheduleImmediate(resolve));
    }
    function waitAtLeastOneReactRenderTask() {
      if (false) {
      } else {
        return new Promise((r) => setImmediate(r));
      }
    }

    //# sourceMappingURL=scheduler.js.map
  },
  9948: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';
    /**
     * The functions provided by this module are used to communicate certain properties about
     * the currently running code so that Next.js can make decisions on how to handle the
     * current execution in different rendering modes such as pre-rendering, resuming, and
     * SSR.
     *
     * Today Next.js treats all code as potentially static. Certain APIs may only make sense
     * when dynamically rendering. Traditionally this meant deopting the entire render to
     * dynamic however with PPR we can now deopt parts of a React tree as dynamic while still
     * keeping other parts static. There are really two different kinds of Dynamic
     * indications.
     *
     * The first is simply an intention to be dynamic. unstable_noStore is an example of this
     * where the currently executing code simply declares that the current scope is dynamic
     * but if you use it inside unstable_cache it can still be cached. This type of indication
     * can be removed if we ever make the default dynamic to begin with because the only way
     * you would ever be static is inside a cache scope which this indication does not
     * affect.
     *
     * The second is an indication that a dynamic data source was read. This is a stronger
     * form of dynamic because it means that it is inappropriate to cache this at all. using a
     * dynamic data source inside unstable_cache should error. If you want to use some dynamic
     * data inside unstable_cache you should read that data outside the cache and pass it in
     * as an argument to the cached function.
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      Postpone: function () {
        return Postpone;
      },
      abortAndThrowOnSynchronousRequestDataAccess: function () {
        return abortAndThrowOnSynchronousRequestDataAccess;
      },
      abortOnSynchronousPlatformIOAccess: function () {
        return abortOnSynchronousPlatformIOAccess;
      },
      accessedDynamicData: function () {
        return accessedDynamicData;
      },
      annotateDynamicAccess: function () {
        return annotateDynamicAccess;
      },
      consumeDynamicAccess: function () {
        return consumeDynamicAccess;
      },
      createDynamicTrackingState: function () {
        return createDynamicTrackingState;
      },
      createDynamicValidationState: function () {
        return createDynamicValidationState;
      },
      createHangingInputAbortSignal: function () {
        return createHangingInputAbortSignal;
      },
      createPostponedAbortSignal: function () {
        return createPostponedAbortSignal;
      },
      formatDynamicAPIAccesses: function () {
        return formatDynamicAPIAccesses;
      },
      getFirstDynamicReason: function () {
        return getFirstDynamicReason;
      },
      isDynamicPostpone: function () {
        return isDynamicPostpone;
      },
      isPrerenderInterruptedError: function () {
        return isPrerenderInterruptedError;
      },
      markCurrentScopeAsDynamic: function () {
        return markCurrentScopeAsDynamic;
      },
      postponeWithTracking: function () {
        return postponeWithTracking;
      },
      throwIfDisallowedDynamic: function () {
        return throwIfDisallowedDynamic;
      },
      throwToInterruptStaticGeneration: function () {
        return throwToInterruptStaticGeneration;
      },
      trackAllowedDynamicAccess: function () {
        return trackAllowedDynamicAccess;
      },
      trackDynamicDataInDynamicRender: function () {
        return trackDynamicDataInDynamicRender;
      },
      trackFallbackParamAccessed: function () {
        return trackFallbackParamAccessed;
      },
      trackSynchronousPlatformIOAccessInDev: function () {
        return trackSynchronousPlatformIOAccessInDev;
      },
      trackSynchronousRequestDataAccessInDev: function () {
        return trackSynchronousRequestDataAccessInDev;
      },
      useDynamicRouteParams: function () {
        return useDynamicRouteParams;
      },
    });
    const _react = /*#__PURE__*/ _interop_require_default(__webpack_require__(863));
    const _hooksservercontext = __webpack_require__(2129);
    const _staticgenerationbailout = __webpack_require__(2661);
    const _workunitasyncstorageexternal = __webpack_require__(412);
    const _workasyncstorageexternal = __webpack_require__(9348);
    const _dynamicrenderingutils = __webpack_require__(7354);
    const _metadataconstants = __webpack_require__(6859);
    const _scheduler = __webpack_require__(6057);
    function _interop_require_default(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }
    const hasPostpone = typeof _react.default.unstable_postpone === 'function';
    function createDynamicTrackingState(isDebugDynamicAccesses) {
      return {
        isDebugDynamicAccesses,
        dynamicAccesses: [],
        syncDynamicExpression: undefined,
        syncDynamicErrorWithStack: null,
      };
    }
    function createDynamicValidationState() {
      return {
        hasSuspendedDynamic: false,
        hasDynamicMetadata: false,
        hasDynamicViewport: false,
        hasSyncDynamicErrors: false,
        dynamicErrors: [],
      };
    }
    function getFirstDynamicReason(trackingState) {
      var _trackingState_dynamicAccesses_;
      return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null
        ? void 0
        : _trackingState_dynamicAccesses_.expression;
    }
    function markCurrentScopeAsDynamic(store, workUnitStore, expression) {
      if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
          // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
          // creates a cache boundary. This is subtly different from reading a dynamic data source which is
          // forbidden inside a cache scope.
          return;
        }
      }
      // If we're forcing dynamic rendering or we're forcing static rendering, we
      // don't need to do anything here because the entire page is already dynamic
      // or it's static and it should not throw or postpone here.
      if (store.forceDynamic || store.forceStatic) return;
      if (store.dynamicShouldError) {
        throw Object.defineProperty(
          new _staticgenerationbailout.StaticGenBailoutError(
            `Route ${store.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
          ),
          '__NEXT_ERROR_CODE',
          {
            value: 'E553',
            enumerable: false,
            configurable: true,
          }
        );
      }
      if (workUnitStore) {
        if (workUnitStore.type === 'prerender-ppr') {
          postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);
        } else if (workUnitStore.type === 'prerender-legacy') {
          workUnitStore.revalidate = 0;
          // We aren't prerendering but we are generating a static page. We need to bail out of static generation
          const err = Object.defineProperty(
            new _hooksservercontext.DynamicServerError(
              `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E550',
              enumerable: false,
              configurable: true,
            }
          );
          store.dynamicUsageDescription = expression;
          store.dynamicUsageStack = err.stack;
          throw err;
        } else if (true && workUnitStore && workUnitStore.type === 'request') {
          workUnitStore.usedDynamic = true;
        }
      }
    }
    function trackFallbackParamAccessed(store, expression) {
      const prerenderStore =
        _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return;
      postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking);
    }
    function throwToInterruptStaticGeneration(expression, store, prerenderStore) {
      // We aren't prerendering but we are generating a static page. We need to bail out of static generation
      const err = Object.defineProperty(
        new _hooksservercontext.DynamicServerError(
          `Route ${store.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E558',
          enumerable: false,
          configurable: true,
        }
      );
      prerenderStore.revalidate = 0;
      store.dynamicUsageDescription = expression;
      store.dynamicUsageStack = err.stack;
      throw err;
    }
    function trackDynamicDataInDynamicRender(_store, workUnitStore) {
      if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
          // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
          // creates a cache boundary. This is subtly different from reading a dynamic data source which is
          // forbidden inside a cache scope.
          return;
        }
        if (
          workUnitStore.type === 'prerender' ||
          workUnitStore.type === 'prerender-legacy'
        ) {
          workUnitStore.revalidate = 0;
        }
        if (true && workUnitStore.type === 'request') {
          workUnitStore.usedDynamic = true;
        }
      }
    }
    // Despite it's name we don't actually abort unless we have a controller to call abort on
    // There are times when we let a prerender run long to discover caches where we want the semantics
    // of tracking dynamic access without terminating the prerender early
    function abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {
      const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;
      const error = createPrerenderInterruptedError(reason);
      prerenderStore.controller.abort(error);
      const dynamicTracking = prerenderStore.dynamicTracking;
      if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
          // When we aren't debugging, we don't need to create another error for the
          // stack trace.
          stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
          expression,
        });
      }
    }
    function abortOnSynchronousPlatformIOAccess(
      route,
      expression,
      errorWithStack,
      prerenderStore
    ) {
      const dynamicTracking = prerenderStore.dynamicTracking;
      if (dynamicTracking) {
        if (dynamicTracking.syncDynamicErrorWithStack === null) {
          dynamicTracking.syncDynamicExpression = expression;
          dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
        }
      }
      abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
    }
    function trackSynchronousPlatformIOAccessInDev(requestStore) {
      // We don't actually have a controller to abort but we do the semantic equivalent by
      // advancing the request store out of prerender mode
      requestStore.prerenderPhase = false;
    }
    function abortAndThrowOnSynchronousRequestDataAccess(
      route,
      expression,
      errorWithStack,
      prerenderStore
    ) {
      const prerenderSignal = prerenderStore.controller.signal;
      if (prerenderSignal.aborted === false) {
        // TODO it would be better to move this aborted check into the callsite so we can avoid making
        // the error object when it isn't relevant to the aborting of the prerender however
        // since we need the throw semantics regardless of whether we abort it is easier to land
        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer
        // to ideal implementation
        const dynamicTracking = prerenderStore.dynamicTracking;
        if (dynamicTracking) {
          if (dynamicTracking.syncDynamicErrorWithStack === null) {
            dynamicTracking.syncDynamicExpression = expression;
            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
            if (prerenderStore.validating === true) {
              // We always log Request Access in dev at the point of calling the function
              // So we mark the dynamic validation as not requiring it to be printed
              dynamicTracking.syncDynamicLogged = true;
            }
          }
        }
        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
      }
      throw createPrerenderInterruptedError(
        `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`
      );
    }
    const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;
    function Postpone({ reason, route }) {
      const prerenderStore =
        _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      const dynamicTracking =
        prerenderStore && prerenderStore.type === 'prerender-ppr'
          ? prerenderStore.dynamicTracking
          : null;
      postponeWithTracking(route, reason, dynamicTracking);
    }
    function postponeWithTracking(route, expression, dynamicTracking) {
      assertPostpone();
      if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
          // When we aren't debugging, we don't need to create another error for the
          // stack trace.
          stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
          expression,
        });
      }
      _react.default.unstable_postpone(createPostponeReason(route, expression));
    }
    function createPostponeReason(route, expression) {
      return (
        `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +
        `React throws this special object to indicate where. It should not be caught by ` +
        `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`
      );
    }
    function isDynamicPostpone(err) {
      if (typeof err === 'object' && err !== null && typeof err.message === 'string') {
        return isDynamicPostponeReason(err.message);
      }
      return false;
    }
    function isDynamicPostponeReason(reason) {
      return (
        reason.includes(
          'needs to bail out of prerendering at this point because it used'
        ) &&
        reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error')
      );
    }
    if (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {
      throw Object.defineProperty(
        new Error(
          'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E296',
          enumerable: false,
          configurable: true,
        }
      );
    }
    const NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';
    function createPrerenderInterruptedError(message) {
      const error = Object.defineProperty(new Error(message), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: false,
        configurable: true,
      });
      error.digest = NEXT_PRERENDER_INTERRUPTED;
      return error;
    }
    function isPrerenderInterruptedError(error) {
      return (
        typeof error === 'object' &&
        error !== null &&
        error.digest === NEXT_PRERENDER_INTERRUPTED &&
        'name' in error &&
        'message' in error &&
        error instanceof Error
      );
    }
    function accessedDynamicData(dynamicAccesses) {
      return dynamicAccesses.length > 0;
    }
    function consumeDynamicAccess(serverDynamic, clientDynamic) {
      // We mutate because we only call this once we are no longer writing
      // to the dynamicTrackingState and it's more efficient than creating a new
      // array.
      serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);
      return serverDynamic.dynamicAccesses;
    }
    function formatDynamicAPIAccesses(dynamicAccesses) {
      return dynamicAccesses
        .filter((access) => typeof access.stack === 'string' && access.stack.length > 0)
        .map(({ expression, stack }) => {
          stack = stack
            .split('\n') // Remove the "Error: " prefix from the first line of the stack trace as
            // well as the first 4 lines of the stack trace which is the distance
            // from the user code and the `new Error().stack` call.
            .slice(4)
            .filter((line) => {
              // Exclude Next.js internals from the stack trace.
              if (line.includes('node_modules/next/')) {
                return false;
              }
              // Exclude anonymous functions from the stack trace.
              if (line.includes(' (<anonymous>)')) {
                return false;
              }
              // Exclude Node.js internals from the stack trace.
              if (line.includes(' (node:')) {
                return false;
              }
              return true;
            })
            .join('\n');
          return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
        });
    }
    function assertPostpone() {
      if (!hasPostpone) {
        throw Object.defineProperty(
          new Error(
            `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`
          ),
          '__NEXT_ERROR_CODE',
          {
            value: 'E224',
            enumerable: false,
            configurable: true,
          }
        );
      }
    }
    function createPostponedAbortSignal(reason) {
      assertPostpone();
      const controller = new AbortController();
      // We get our hands on a postpone instance by calling postpone and catching the throw
      try {
        _react.default.unstable_postpone(reason);
      } catch (x) {
        controller.abort(x);
      }
      return controller.signal;
    }
    function createHangingInputAbortSignal(workUnitStore) {
      const controller = new AbortController();
      if (workUnitStore.cacheSignal) {
        // If we have a cacheSignal it means we're in a prospective render. If the input
        // we're waiting on is coming from another cache, we do want to wait for it so that
        // we can resolve this cache entry too.
        workUnitStore.cacheSignal.inputReady().then(() => {
          controller.abort();
        });
      } else {
        // Otherwise we're in the final render and we should already have all our caches
        // filled. We might still be waiting on some microtasks so we wait one tick before
        // giving up. When we give up, we still want to render the content of this cache
        // as deeply as we can so that we can suspend as deeply as possible in the tree
        // or not at all if we don't end up waiting for the input.
        (0, _scheduler.scheduleOnNextTick)(() => controller.abort());
      }
      return controller.signal;
    }
    function annotateDynamicAccess(expression, prerenderStore) {
      const dynamicTracking = prerenderStore.dynamicTracking;
      if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
          stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
          expression,
        });
      }
    }
    function useDynamicRouteParams(expression) {
      const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
      if (
        workStore &&
        workStore.isStaticGeneration &&
        workStore.fallbackRouteParams &&
        workStore.fallbackRouteParams.size > 0
      ) {
        // There are fallback route params, we should track these as dynamic
        // accesses.
        const workUnitStore =
          _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
        if (workUnitStore) {
          // We're prerendering with dynamicIO or PPR or both
          if (workUnitStore.type === 'prerender') {
            // We are in a prerender with dynamicIO semantics
            // We are going to hang here and never resolve. This will cause the currently
            // rendering component to effectively be a dynamic hole
            _react.default.use(
              (0, _dynamicrenderingutils.makeHangingPromise)(
                workUnitStore.renderSignal,
                expression
              )
            );
          } else if (workUnitStore.type === 'prerender-ppr') {
            // We're prerendering with PPR
            postponeWithTracking(
              workStore.route,
              expression,
              workUnitStore.dynamicTracking
            );
          } else if (workUnitStore.type === 'prerender-legacy') {
            throwToInterruptStaticGeneration(expression, workStore, workUnitStore);
          }
        }
      }
    }
    const hasSuspenseRegex = /\n\s+at Suspense \(<anonymous>\)/;
    const hasMetadataRegex = new RegExp(
      `\\n\\s+at ${_metadataconstants.METADATA_BOUNDARY_NAME}[\\n\\s]`
    );
    const hasViewportRegex = new RegExp(
      `\\n\\s+at ${_metadataconstants.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`
    );
    const hasOutletRegex = new RegExp(
      `\\n\\s+at ${_metadataconstants.OUTLET_BOUNDARY_NAME}[\\n\\s]`
    );
    function trackAllowedDynamicAccess(
      route,
      componentStack,
      dynamicValidation,
      serverDynamic,
      clientDynamic
    ) {
      if (hasOutletRegex.test(componentStack)) {
        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.
        return;
      } else if (hasMetadataRegex.test(componentStack)) {
        dynamicValidation.hasDynamicMetadata = true;
        return;
      } else if (hasViewportRegex.test(componentStack)) {
        dynamicValidation.hasDynamicViewport = true;
        return;
      } else if (hasSuspenseRegex.test(componentStack)) {
        dynamicValidation.hasSuspendedDynamic = true;
        return;
      } else if (
        serverDynamic.syncDynamicErrorWithStack ||
        clientDynamic.syncDynamicErrorWithStack
      ) {
        dynamicValidation.hasSyncDynamicErrors = true;
        return;
      } else {
        const message = `Route "${route}": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;
        const error = createErrorWithComponentStack(message, componentStack);
        dynamicValidation.dynamicErrors.push(error);
        return;
      }
    }
    function createErrorWithComponentStack(message, componentStack) {
      const error = Object.defineProperty(new Error(message), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: false,
        configurable: true,
      });
      error.stack = 'Error: ' + message + componentStack;
      return error;
    }
    function throwIfDisallowedDynamic(
      route,
      dynamicValidation,
      serverDynamic,
      clientDynamic
    ) {
      let syncError;
      let syncExpression;
      let syncLogged;
      if (serverDynamic.syncDynamicErrorWithStack) {
        syncError = serverDynamic.syncDynamicErrorWithStack;
        syncExpression = serverDynamic.syncDynamicExpression;
        syncLogged = serverDynamic.syncDynamicLogged === true;
      } else if (clientDynamic.syncDynamicErrorWithStack) {
        syncError = clientDynamic.syncDynamicErrorWithStack;
        syncExpression = clientDynamic.syncDynamicExpression;
        syncLogged = clientDynamic.syncDynamicLogged === true;
      } else {
        syncError = null;
        syncExpression = undefined;
        syncLogged = false;
      }
      if (dynamicValidation.hasSyncDynamicErrors && syncError) {
        if (!syncLogged) {
          // In dev we already log errors about sync dynamic access. But during builds we need to ensure
          // the offending sync error is logged before we exit the build
          console.error(syncError);
        }
        // The actual error should have been logged when the sync access ocurred
        throw new _staticgenerationbailout.StaticGenBailoutError();
      }
      const dynamicErrors = dynamicValidation.dynamicErrors;
      if (dynamicErrors.length) {
        for (let i = 0; i < dynamicErrors.length; i++) {
          console.error(dynamicErrors[i]);
        }
        throw new _staticgenerationbailout.StaticGenBailoutError();
      }
      if (!dynamicValidation.hasSuspendedDynamic) {
        if (dynamicValidation.hasDynamicMetadata) {
          if (syncError) {
            console.error(syncError);
            throw Object.defineProperty(
              new _staticgenerationbailout.StaticGenBailoutError(
                `Route "${route}" has a \`generateMetadata\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`
              ),
              '__NEXT_ERROR_CODE',
              {
                value: 'E608',
                enumerable: false,
                configurable: true,
              }
            );
          }
          throw Object.defineProperty(
            new _staticgenerationbailout.StaticGenBailoutError(
              `Route "${route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or external data (\`fetch(...)\`, etc...) but the rest of the route was static or only used cached data (\`"use cache"\`). If you expected this route to be prerenderable update your \`generateMetadata\` to not use Request data and only use cached external data. Otherwise, add \`await connection()\` somewhere within this route to indicate explicitly it should not be prerendered.`
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E534',
              enumerable: false,
              configurable: true,
            }
          );
        } else if (dynamicValidation.hasDynamicViewport) {
          if (syncError) {
            console.error(syncError);
            throw Object.defineProperty(
              new _staticgenerationbailout.StaticGenBailoutError(
                `Route "${route}" has a \`generateViewport\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`
              ),
              '__NEXT_ERROR_CODE',
              {
                value: 'E573',
                enumerable: false,
                configurable: true,
              }
            );
          }
          throw Object.defineProperty(
            new _staticgenerationbailout.StaticGenBailoutError(
              `Route "${route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or external data (\`fetch(...)\`, etc...) but the rest of the route was static or only used cached data (\`"use cache"\`). If you expected this route to be prerenderable update your \`generateViewport\` to not use Request data and only use cached external data. Otherwise, add \`await connection()\` somewhere within this route to indicate explicitly it should not be prerendered.`
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E590',
              enumerable: false,
              configurable: true,
            }
          );
        }
      }
    }

    //# sourceMappingURL=dynamic-rendering.js.map
  },
  2088: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'createDedupedByCallsiteServerErrorLoggerDev', {
      enumerable: true,
      get: function () {
        return createDedupedByCallsiteServerErrorLoggerDev;
      },
    });
    const _react = /*#__PURE__*/ _interop_require_wildcard(__webpack_require__(863));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== 'function') return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function (nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
        return {
          default: obj,
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null,
      };
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    const errorRef = {
      current: null,
    };
    // React.cache is currently only available in canary/experimental React channels.
    const cache = typeof _react.cache === 'function' ? _react.cache : (fn) => fn;
    // When Dynamic IO is enabled, we record these as errors so that they
    // are captured by the dev overlay as it's more critical to fix these
    // when enabled.
    const logErrorOrWarn = false ? 0 : console.warn;
    // We don't want to dedupe across requests.
    // The developer might've just attempted to fix the warning so we should warn again if it still happens.
    const flushCurrentErrorIfNew = cache(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key
      (key) => {
        try {
          logErrorOrWarn(errorRef.current);
        } finally {
          errorRef.current = null;
        }
      }
    );
    function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {
      return function logDedupedError(...args) {
        const message = getMessage(...args);
        if (true) {
          var _stack;
          const callStackFrames =
            (_stack = new Error().stack) == null ? void 0 : _stack.split('\n');
          if (callStackFrames === undefined || callStackFrames.length < 4) {
            logErrorOrWarn(message);
          } else {
            // Error:
            //   logDedupedError
            //   asyncApiBeingAccessedSynchronously
            //   <userland callsite>
            // TODO: This breaks if sourcemaps with ignore lists are enabled.
            const key = callStackFrames[4];
            errorRef.current = message;
            flushCurrentErrorIfNew(key);
          }
        } else {
        }
      };
    }

    //# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map
  },
  6758: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'HMR_ACTIONS_SENT_TO_BROWSER', {
      enumerable: true,
      get: function () {
        return HMR_ACTIONS_SENT_TO_BROWSER;
      },
    });
    var HMR_ACTIONS_SENT_TO_BROWSER = /*#__PURE__*/ (function (
      HMR_ACTIONS_SENT_TO_BROWSER
    ) {
      HMR_ACTIONS_SENT_TO_BROWSER['ADDED_PAGE'] = 'addedPage';
      HMR_ACTIONS_SENT_TO_BROWSER['REMOVED_PAGE'] = 'removedPage';
      HMR_ACTIONS_SENT_TO_BROWSER['RELOAD_PAGE'] = 'reloadPage';
      HMR_ACTIONS_SENT_TO_BROWSER['SERVER_COMPONENT_CHANGES'] = 'serverComponentChanges';
      HMR_ACTIONS_SENT_TO_BROWSER['MIDDLEWARE_CHANGES'] = 'middlewareChanges';
      HMR_ACTIONS_SENT_TO_BROWSER['CLIENT_CHANGES'] = 'clientChanges';
      HMR_ACTIONS_SENT_TO_BROWSER['SERVER_ONLY_CHANGES'] = 'serverOnlyChanges';
      HMR_ACTIONS_SENT_TO_BROWSER['SYNC'] = 'sync';
      HMR_ACTIONS_SENT_TO_BROWSER['BUILT'] = 'built';
      HMR_ACTIONS_SENT_TO_BROWSER['BUILDING'] = 'building';
      HMR_ACTIONS_SENT_TO_BROWSER['DEV_PAGES_MANIFEST_UPDATE'] = 'devPagesManifestUpdate';
      HMR_ACTIONS_SENT_TO_BROWSER['TURBOPACK_MESSAGE'] = 'turbopack-message';
      HMR_ACTIONS_SENT_TO_BROWSER['SERVER_ERROR'] = 'serverError';
      HMR_ACTIONS_SENT_TO_BROWSER['TURBOPACK_CONNECTED'] = 'turbopack-connected';
      HMR_ACTIONS_SENT_TO_BROWSER['ISR_MANIFEST'] = 'isrManifest';
      HMR_ACTIONS_SENT_TO_BROWSER['DEV_INDICATOR'] = 'devIndicator';
      return HMR_ACTIONS_SENT_TO_BROWSER;
    })({});

    //# sourceMappingURL=hot-reloader-types.js.map
  },
  7354: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      isHangingPromiseRejectionError: function () {
        return isHangingPromiseRejectionError;
      },
      makeHangingPromise: function () {
        return makeHangingPromise;
      },
    });
    function isHangingPromiseRejectionError(err) {
      if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
      }
      return err.digest === HANGING_PROMISE_REJECTION;
    }
    const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';
    class HangingPromiseRejectionError extends Error {
      constructor(expression) {
        super(
          `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \`setTimeout\`, \`after\`, or similar functions you may observe this error and you should handle it in that context.`
        ),
          (this.expression = expression),
          (this.digest = HANGING_PROMISE_REJECTION);
      }
    }
    const abortListenersBySignal = new WeakMap();
    function makeHangingPromise(signal, expression) {
      if (signal.aborted) {
        return Promise.reject(new HangingPromiseRejectionError(expression));
      } else {
        const hangingPromise = new Promise((_, reject) => {
          const boundRejection = reject.bind(
            null,
            new HangingPromiseRejectionError(expression)
          );
          let currentListeners = abortListenersBySignal.get(signal);
          if (currentListeners) {
            currentListeners.push(boundRejection);
          } else {
            const listeners = [boundRejection];
            abortListenersBySignal.set(signal, listeners);
            signal.addEventListener(
              'abort',
              () => {
                for (let i = 0; i < listeners.length; i++) {
                  listeners[i]();
                }
              },
              {
                once: true,
              }
            );
          }
        });
        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so
        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct
        // your own promise out of it you'll need to ensure you handle the error when it rejects.
        hangingPromise.catch(ignoreReject);
        return hangingPromise;
      }
    }
    function ignoreReject() {}

    //# sourceMappingURL=dynamic-rendering-utils.js.map
  },
  6797: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'isPostpone', {
      enumerable: true,
      get: function () {
        return isPostpone;
      },
    });
    const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
    function isPostpone(error) {
      return (
        typeof error === 'object' &&
        error !== null &&
        error.$$typeof === REACT_POSTPONE_TYPE
      );
    }

    //# sourceMappingURL=is-postpone.js.map
  },
  4265: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      createParamsFromClient: function () {
        return createParamsFromClient;
      },
      createPrerenderParamsForClientSegment: function () {
        return createPrerenderParamsForClientSegment;
      },
      createServerParamsForMetadata: function () {
        return createServerParamsForMetadata;
      },
      createServerParamsForRoute: function () {
        return createServerParamsForRoute;
      },
      createServerParamsForServerSegment: function () {
        return createServerParamsForServerSegment;
      },
    });
    const _reflect = __webpack_require__(6792);
    const _dynamicrendering = __webpack_require__(9948);
    const _workunitasyncstorageexternal = __webpack_require__(412);
    const _invarianterror = __webpack_require__(2748);
    const _reflectutils = __webpack_require__(6367);
    const _dynamicrenderingutils = __webpack_require__(7354);
    const _creatededupedbycallsiteservererrorlogger = __webpack_require__(2088);
    const _scheduler = __webpack_require__(6057);
    function createParamsFromClient(underlyingParams, workStore) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        switch (workUnitStore.type) {
          case 'prerender':
          case 'prerender-ppr':
          case 'prerender-legacy':
            return createPrerenderParams(underlyingParams, workStore, workUnitStore);
          default:
        }
      }
      return createRenderParams(underlyingParams, workStore);
    }
    const createServerParamsForMetadata = createServerParamsForServerSegment;
    function createServerParamsForRoute(underlyingParams, workStore) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        switch (workUnitStore.type) {
          case 'prerender':
          case 'prerender-ppr':
          case 'prerender-legacy':
            return createPrerenderParams(underlyingParams, workStore, workUnitStore);
          default:
        }
      }
      return createRenderParams(underlyingParams, workStore);
    }
    function createServerParamsForServerSegment(underlyingParams, workStore) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        switch (workUnitStore.type) {
          case 'prerender':
          case 'prerender-ppr':
          case 'prerender-legacy':
            return createPrerenderParams(underlyingParams, workStore, workUnitStore);
          default:
        }
      }
      return createRenderParams(underlyingParams, workStore);
    }
    function createPrerenderParamsForClientSegment(underlyingParams, workStore) {
      const prerenderStore =
        _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (prerenderStore && prerenderStore.type === 'prerender') {
        const fallbackParams = workStore.fallbackRouteParams;
        if (fallbackParams) {
          for (let key in underlyingParams) {
            if (fallbackParams.has(key)) {
              // This params object has one of more fallback params so we need to consider
              // the awaiting of this params object "dynamic". Since we are in dynamicIO mode
              // we encode this as a promise that never resolves
              return (0, _dynamicrenderingutils.makeHangingPromise)(
                prerenderStore.renderSignal,
                '`params`'
              );
            }
          }
        }
      }
      // We're prerendering in a mode that does not abort. We resolve the promise without
      // any tracking because we're just transporting a value from server to client where the tracking
      // will be applied.
      return Promise.resolve(underlyingParams);
    }
    function createPrerenderParams(underlyingParams, workStore, prerenderStore) {
      const fallbackParams = workStore.fallbackRouteParams;
      if (fallbackParams) {
        let hasSomeFallbackParams = false;
        for (const key in underlyingParams) {
          if (fallbackParams.has(key)) {
            hasSomeFallbackParams = true;
            break;
          }
        }
        if (hasSomeFallbackParams) {
          // params need to be treated as dynamic because we have at least one fallback param
          if (prerenderStore.type === 'prerender') {
            // We are in a dynamicIO (PPR or otherwise) prerender
            return makeAbortingExoticParams(
              underlyingParams,
              workStore.route,
              prerenderStore
            );
          }
          // remaining cases are prerender-ppr and prerender-legacy
          // We aren't in a dynamicIO prerender but we do have fallback params at this
          // level so we need to make an erroring exotic params object which will postpone
          // if you access the fallback params
          return makeErroringExoticParams(
            underlyingParams,
            fallbackParams,
            workStore,
            prerenderStore
          );
        }
      }
      // We don't have any fallback params so we have an entirely static safe params object
      return makeUntrackedExoticParams(underlyingParams);
    }
    function createRenderParams(underlyingParams, workStore) {
      if (true && !workStore.isPrefetchRequest) {
        return makeDynamicallyTrackedExoticParamsWithDevWarnings(
          underlyingParams,
          workStore
        );
      } else {
        return makeUntrackedExoticParams(underlyingParams);
      }
    }
    const CachedParams = new WeakMap();
    function makeAbortingExoticParams(underlyingParams, route, prerenderStore) {
      const cachedParams = CachedParams.get(underlyingParams);
      if (cachedParams) {
        return cachedParams;
      }
      const promise = (0, _dynamicrenderingutils.makeHangingPromise)(
        prerenderStore.renderSignal,
        '`params`'
      );
      CachedParams.set(underlyingParams, promise);
      Object.keys(underlyingParams).forEach((prop) => {
        if (_reflectutils.wellKnownProperties.has(prop)) {
          // These properties cannot be shadowed because they need to be the
          // true underlying value for Promises to work correctly at runtime
        } else {
          Object.defineProperty(promise, prop, {
            get() {
              const expression = (0, _reflectutils.describeStringPropertyAccess)(
                'params',
                prop
              );
              const error = createParamsAccessError(route, expression);
              (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(
                route,
                expression,
                error,
                prerenderStore
              );
            },
            set(newValue) {
              Object.defineProperty(promise, prop, {
                value: newValue,
                writable: true,
                enumerable: true,
              });
            },
            enumerable: true,
            configurable: true,
          });
        }
      });
      return promise;
    }
    function makeErroringExoticParams(
      underlyingParams,
      fallbackParams,
      workStore,
      prerenderStore
    ) {
      const cachedParams = CachedParams.get(underlyingParams);
      if (cachedParams) {
        return cachedParams;
      }
      const augmentedUnderlying = {
        ...underlyingParams,
      };
      // We don't use makeResolvedReactPromise here because params
      // supports copying with spread and we don't want to unnecessarily
      // instrument the promise with spreadable properties of ReactPromise.
      const promise = Promise.resolve(augmentedUnderlying);
      CachedParams.set(underlyingParams, promise);
      Object.keys(underlyingParams).forEach((prop) => {
        if (_reflectutils.wellKnownProperties.has(prop)) {
          // These properties cannot be shadowed because they need to be the
          // true underlying value for Promises to work correctly at runtime
        } else {
          if (fallbackParams.has(prop)) {
            Object.defineProperty(augmentedUnderlying, prop, {
              get() {
                const expression = (0, _reflectutils.describeStringPropertyAccess)(
                  'params',
                  prop
                );
                // In most dynamic APIs we also throw if `dynamic = "error"` however
                // for params is only dynamic when we're generating a fallback shell
                // and even when `dynamic = "error"` we still support generating dynamic
                // fallback shells
                // TODO remove this comment when dynamicIO is the default since there
                // will be no `dynamic = "error"`
                if (prerenderStore.type === 'prerender-ppr') {
                  // PPR Prerender (no dynamicIO)
                  (0, _dynamicrendering.postponeWithTracking)(
                    workStore.route,
                    expression,
                    prerenderStore.dynamicTracking
                  );
                } else {
                  // Legacy Prerender
                  (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                    expression,
                    workStore,
                    prerenderStore
                  );
                }
              },
              enumerable: true,
            });
            Object.defineProperty(promise, prop, {
              get() {
                const expression = (0, _reflectutils.describeStringPropertyAccess)(
                  'params',
                  prop
                );
                // In most dynamic APIs we also throw if `dynamic = "error"` however
                // for params is only dynamic when we're generating a fallback shell
                // and even when `dynamic = "error"` we still support generating dynamic
                // fallback shells
                // TODO remove this comment when dynamicIO is the default since there
                // will be no `dynamic = "error"`
                if (prerenderStore.type === 'prerender-ppr') {
                  // PPR Prerender (no dynamicIO)
                  (0, _dynamicrendering.postponeWithTracking)(
                    workStore.route,
                    expression,
                    prerenderStore.dynamicTracking
                  );
                } else {
                  // Legacy Prerender
                  (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                    expression,
                    workStore,
                    prerenderStore
                  );
                }
              },
              set(newValue) {
                Object.defineProperty(promise, prop, {
                  value: newValue,
                  writable: true,
                  enumerable: true,
                });
              },
              enumerable: true,
              configurable: true,
            });
          } else {
            promise[prop] = underlyingParams[prop];
          }
        }
      });
      return promise;
    }
    function makeUntrackedExoticParams(underlyingParams) {
      const cachedParams = CachedParams.get(underlyingParams);
      if (cachedParams) {
        return cachedParams;
      }
      // We don't use makeResolvedReactPromise here because params
      // supports copying with spread and we don't want to unnecessarily
      // instrument the promise with spreadable properties of ReactPromise.
      const promise = Promise.resolve(underlyingParams);
      CachedParams.set(underlyingParams, promise);
      Object.keys(underlyingParams).forEach((prop) => {
        if (_reflectutils.wellKnownProperties.has(prop)) {
          // These properties cannot be shadowed because they need to be the
          // true underlying value for Promises to work correctly at runtime
        } else {
          promise[prop] = underlyingParams[prop];
        }
      });
      return promise;
    }
    function makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, store) {
      const cachedParams = CachedParams.get(underlyingParams);
      if (cachedParams) {
        return cachedParams;
      }
      // We don't use makeResolvedReactPromise here because params
      // supports copying with spread and we don't want to unnecessarily
      // instrument the promise with spreadable properties of ReactPromise.
      const promise = new Promise((resolve) =>
        (0, _scheduler.scheduleImmediate)(() => resolve(underlyingParams))
      );
      const proxiedProperties = new Set();
      const unproxiedProperties = [];
      Object.keys(underlyingParams).forEach((prop) => {
        if (_reflectutils.wellKnownProperties.has(prop)) {
          // These properties cannot be shadowed because they need to be the
          // true underlying value for Promises to work correctly at runtime
          unproxiedProperties.push(prop);
        } else {
          proxiedProperties.add(prop);
          promise[prop] = underlyingParams[prop];
        }
      });
      const proxiedPromise = new Proxy(promise, {
        get(target, prop, receiver) {
          if (typeof prop === 'string') {
            if (
              // We are accessing a property that was proxied to the promise instance
              proxiedProperties.has(prop)
            ) {
              const expression = (0, _reflectutils.describeStringPropertyAccess)(
                'params',
                prop
              );
              syncIODev(store.route, expression);
            }
          }
          return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (typeof prop === 'string') {
            proxiedProperties.delete(prop);
          }
          return _reflect.ReflectAdapter.set(target, prop, value, receiver);
        },
        ownKeys(target) {
          const expression = '`...params` or similar expression';
          syncIODev(store.route, expression, unproxiedProperties);
          return Reflect.ownKeys(target);
        },
      });
      CachedParams.set(underlyingParams, proxiedPromise);
      return proxiedPromise;
    }
    function syncIODev(route, expression, missingProperties) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (
        workUnitStore &&
        workUnitStore.type === 'request' &&
        workUnitStore.prerenderPhase === true
      ) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
      }
      // In all cases we warn normally
      if (missingProperties && missingProperties.length > 0) {
        warnForIncompleteEnumeration(route, expression, missingProperties);
      } else {
        warnForSyncAccess(route, expression);
      }
    }
    const warnForSyncAccess = (0,
    _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(
      createParamsAccessError
    );
    const warnForIncompleteEnumeration = (0,
    _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(
      createIncompleteEnumerationError
    );
    function createParamsAccessError(route, expression) {
      const prefix = route ? `Route "${route}" ` : 'This route ';
      return Object.defineProperty(
        new Error(
          `${prefix}used ${expression}. ` +
            `\`params\` should be awaited before using its properties. ` +
            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E307',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function createIncompleteEnumerationError(route, expression, missingProperties) {
      const prefix = route ? `Route "${route}" ` : 'This route ';
      return Object.defineProperty(
        new Error(
          `${prefix}used ${expression}. ` +
            `\`params\` should be awaited before using its properties. ` +
            `The following properties were not available through enumeration ` +
            `because they conflict with builtin property names: ` +
            `${describeListOfPropertyNames(missingProperties)}. ` +
            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E482',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function describeListOfPropertyNames(properties) {
      switch (properties.length) {
        case 0:
          throw Object.defineProperty(
            new _invarianterror.InvariantError(
              'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E531',
              enumerable: false,
              configurable: true,
            }
          );
        case 1:
          return `\`${properties[0]}\``;
        case 2:
          return `\`${properties[0]}\` and \`${properties[1]}\``;
        default: {
          let description = '';
          for (let i = 0; i < properties.length - 1; i++) {
            description += `\`${properties[i]}\`, `;
          }
          description += `, and \`${properties[properties.length - 1]}\``;
          return description;
        }
      }
    }

    //# sourceMappingURL=params.js.map
  },
  980: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      createPrerenderSearchParamsForClientPage: function () {
        return createPrerenderSearchParamsForClientPage;
      },
      createSearchParamsFromClient: function () {
        return createSearchParamsFromClient;
      },
      createServerSearchParamsForMetadata: function () {
        return createServerSearchParamsForMetadata;
      },
      createServerSearchParamsForServerPage: function () {
        return createServerSearchParamsForServerPage;
      },
      makeErroringExoticSearchParamsForUseCache: function () {
        return makeErroringExoticSearchParamsForUseCache;
      },
    });
    const _reflect = __webpack_require__(6792);
    const _dynamicrendering = __webpack_require__(9948);
    const _workunitasyncstorageexternal = __webpack_require__(412);
    const _invarianterror = __webpack_require__(2748);
    const _dynamicrenderingutils = __webpack_require__(7354);
    const _creatededupedbycallsiteservererrorlogger = __webpack_require__(2088);
    const _reflectutils = __webpack_require__(6367);
    const _utils = __webpack_require__(7714);
    const _scheduler = __webpack_require__(6057);
    function createSearchParamsFromClient(underlyingSearchParams, workStore) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        switch (workUnitStore.type) {
          case 'prerender':
          case 'prerender-ppr':
          case 'prerender-legacy':
            return createPrerenderSearchParams(workStore, workUnitStore);
          default:
        }
      }
      return createRenderSearchParams(underlyingSearchParams, workStore);
    }
    const createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;
    function createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        switch (workUnitStore.type) {
          case 'prerender':
          case 'prerender-ppr':
          case 'prerender-legacy':
            return createPrerenderSearchParams(workStore, workUnitStore);
          default:
        }
      }
      return createRenderSearchParams(underlyingSearchParams, workStore);
    }
    function createPrerenderSearchParamsForClientPage(workStore) {
      if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
      }
      const prerenderStore =
        _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (prerenderStore && prerenderStore.type === 'prerender') {
        // dynamicIO Prerender
        // We're prerendering in a mode that aborts (dynamicIO) and should stall
        // the promise to ensure the RSC side is considered dynamic
        return (0, _dynamicrenderingutils.makeHangingPromise)(
          prerenderStore.renderSignal,
          '`searchParams`'
        );
      }
      // We're prerendering in a mode that does not aborts. We resolve the promise without
      // any tracking because we're just transporting a value from server to client where the tracking
      // will be applied.
      return Promise.resolve({});
    }
    function createPrerenderSearchParams(workStore, prerenderStore) {
      if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
      }
      if (prerenderStore.type === 'prerender') {
        // We are in a dynamicIO (PPR or otherwise) prerender
        return makeAbortingExoticSearchParams(workStore.route, prerenderStore);
      }
      // The remaining cases are prerender-ppr and prerender-legacy
      // We are in a legacy static generation and need to interrupt the prerender
      // when search params are accessed.
      return makeErroringExoticSearchParams(workStore, prerenderStore);
    }
    function createRenderSearchParams(underlyingSearchParams, workStore) {
      if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
      } else {
        if (true && !workStore.isPrefetchRequest) {
          return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(
            underlyingSearchParams,
            workStore
          );
        } else {
          return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore);
        }
      }
    }
    const CachedSearchParams = new WeakMap();
    const CachedSearchParamsForUseCache = new WeakMap();
    function makeAbortingExoticSearchParams(route, prerenderStore) {
      const cachedSearchParams = CachedSearchParams.get(prerenderStore);
      if (cachedSearchParams) {
        return cachedSearchParams;
      }
      const promise = (0, _dynamicrenderingutils.makeHangingPromise)(
        prerenderStore.renderSignal,
        '`searchParams`'
      );
      const proxiedPromise = new Proxy(promise, {
        get(target, prop, receiver) {
          if (Object.hasOwn(promise, prop)) {
            // The promise has this property directly. we must return it.
            // We know it isn't a dynamic access because it can only be something
            // that was previously written to the promise and thus not an underlying searchParam value
            return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
          switch (prop) {
            case 'then': {
              const expression = '`await searchParams`, `searchParams.then`, or similar';
              (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);
              return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            case 'status': {
              const expression = '`use(searchParams)`, `searchParams.status`, or similar';
              (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);
              return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            default: {
              if (
                typeof prop === 'string' &&
                !_reflectutils.wellKnownProperties.has(prop)
              ) {
                const expression = (0, _reflectutils.describeStringPropertyAccess)(
                  'searchParams',
                  prop
                );
                const error = createSearchAccessError(route, expression);
                (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(
                  route,
                  expression,
                  error,
                  prerenderStore
                );
              }
              return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
          }
        },
        has(target, prop) {
          // We don't expect key checking to be used except for testing the existence of
          // searchParams so we make all has tests trigger dynamic. this means that `promise.then`
          // can resolve to the then function on the Promise prototype but 'then' in promise will assume
          // you are testing whether the searchParams has a 'then' property.
          if (typeof prop === 'string') {
            const expression = (0, _reflectutils.describeHasCheckingStringProperty)(
              'searchParams',
              prop
            );
            const error = createSearchAccessError(route, expression);
            (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(
              route,
              expression,
              error,
              prerenderStore
            );
          }
          return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys() {
          const expression =
            '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
          const error = createSearchAccessError(route, expression);
          (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(
            route,
            expression,
            error,
            prerenderStore
          );
        },
      });
      CachedSearchParams.set(prerenderStore, proxiedPromise);
      return proxiedPromise;
    }
    function makeErroringExoticSearchParams(workStore, prerenderStore) {
      const cachedSearchParams = CachedSearchParams.get(workStore);
      if (cachedSearchParams) {
        return cachedSearchParams;
      }
      const underlyingSearchParams = {};
      // For search params we don't construct a ReactPromise because we want to interrupt
      // rendering on any property access that was not set from outside and so we only want
      // to have properties like value and status if React sets them.
      const promise = Promise.resolve(underlyingSearchParams);
      const proxiedPromise = new Proxy(promise, {
        get(target, prop, receiver) {
          if (Object.hasOwn(promise, prop)) {
            // The promise has this property directly. we must return it.
            // We know it isn't a dynamic access because it can only be something
            // that was previously written to the promise and thus not an underlying searchParam value
            return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
          switch (prop) {
            case 'then': {
              const expression = '`await searchParams`, `searchParams.then`, or similar';
              if (workStore.dynamicShouldError) {
                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                  workStore.route,
                  expression
                );
              } else if (prerenderStore.type === 'prerender-ppr') {
                // PPR Prerender (no dynamicIO)
                (0, _dynamicrendering.postponeWithTracking)(
                  workStore.route,
                  expression,
                  prerenderStore.dynamicTracking
                );
              } else {
                // Legacy Prerender
                (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                  expression,
                  workStore,
                  prerenderStore
                );
              }
              return;
            }
            case 'status': {
              const expression = '`use(searchParams)`, `searchParams.status`, or similar';
              if (workStore.dynamicShouldError) {
                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                  workStore.route,
                  expression
                );
              } else if (prerenderStore.type === 'prerender-ppr') {
                // PPR Prerender (no dynamicIO)
                (0, _dynamicrendering.postponeWithTracking)(
                  workStore.route,
                  expression,
                  prerenderStore.dynamicTracking
                );
              } else {
                // Legacy Prerender
                (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                  expression,
                  workStore,
                  prerenderStore
                );
              }
              return;
            }
            default: {
              if (
                typeof prop === 'string' &&
                !_reflectutils.wellKnownProperties.has(prop)
              ) {
                const expression = (0, _reflectutils.describeStringPropertyAccess)(
                  'searchParams',
                  prop
                );
                if (workStore.dynamicShouldError) {
                  (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                    workStore.route,
                    expression
                  );
                } else if (prerenderStore.type === 'prerender-ppr') {
                  // PPR Prerender (no dynamicIO)
                  (0, _dynamicrendering.postponeWithTracking)(
                    workStore.route,
                    expression,
                    prerenderStore.dynamicTracking
                  );
                } else {
                  // Legacy Prerender
                  (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                    expression,
                    workStore,
                    prerenderStore
                  );
                }
              }
              return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
          }
        },
        has(target, prop) {
          // We don't expect key checking to be used except for testing the existence of
          // searchParams so we make all has tests trigger dynamic. this means that `promise.then`
          // can resolve to the then function on the Promise prototype but 'then' in promise will assume
          // you are testing whether the searchParams has a 'then' property.
          if (typeof prop === 'string') {
            const expression = (0, _reflectutils.describeHasCheckingStringProperty)(
              'searchParams',
              prop
            );
            if (workStore.dynamicShouldError) {
              (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                workStore.route,
                expression
              );
            } else if (prerenderStore.type === 'prerender-ppr') {
              // PPR Prerender (no dynamicIO)
              (0, _dynamicrendering.postponeWithTracking)(
                workStore.route,
                expression,
                prerenderStore.dynamicTracking
              );
            } else {
              // Legacy Prerender
              (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                expression,
                workStore,
                prerenderStore
              );
            }
            return false;
          }
          return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys() {
          const expression =
            '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
          if (workStore.dynamicShouldError) {
            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
              workStore.route,
              expression
            );
          } else if (prerenderStore.type === 'prerender-ppr') {
            // PPR Prerender (no dynamicIO)
            (0, _dynamicrendering.postponeWithTracking)(
              workStore.route,
              expression,
              prerenderStore.dynamicTracking
            );
          } else {
            // Legacy Prerender
            (0, _dynamicrendering.throwToInterruptStaticGeneration)(
              expression,
              workStore,
              prerenderStore
            );
          }
        },
      });
      CachedSearchParams.set(workStore, proxiedPromise);
      return proxiedPromise;
    }
    function makeErroringExoticSearchParamsForUseCache(workStore) {
      const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore);
      if (cachedSearchParams) {
        return cachedSearchParams;
      }
      const promise = Promise.resolve({});
      const proxiedPromise = new Proxy(promise, {
        get(target, prop, receiver) {
          if (Object.hasOwn(promise, prop)) {
            // The promise has this property directly. we must return it. We know it
            // isn't a dynamic access because it can only be something that was
            // previously written to the promise and thus not an underlying
            // searchParam value
            return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
          if (
            typeof prop === 'string' &&
            (prop === 'then' || !_reflectutils.wellKnownProperties.has(prop))
          ) {
            (0, _utils.throwForSearchParamsAccessInUseCache)(workStore);
          }
          return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        has(target, prop) {
          // We don't expect key checking to be used except for testing the existence of
          // searchParams so we make all has tests throw an error. this means that `promise.then`
          // can resolve to the then function on the Promise prototype but 'then' in promise will assume
          // you are testing whether the searchParams has a 'then' property.
          if (
            typeof prop === 'string' &&
            (prop === 'then' || !_reflectutils.wellKnownProperties.has(prop))
          ) {
            (0, _utils.throwForSearchParamsAccessInUseCache)(workStore);
          }
          return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys() {
          (0, _utils.throwForSearchParamsAccessInUseCache)(workStore);
        },
      });
      CachedSearchParamsForUseCache.set(workStore, proxiedPromise);
      return proxiedPromise;
    }
    function makeUntrackedExoticSearchParams(underlyingSearchParams, store) {
      const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
      if (cachedSearchParams) {
        return cachedSearchParams;
      }
      // We don't use makeResolvedReactPromise here because searchParams
      // supports copying with spread and we don't want to unnecessarily
      // instrument the promise with spreadable properties of ReactPromise.
      const promise = Promise.resolve(underlyingSearchParams);
      CachedSearchParams.set(underlyingSearchParams, promise);
      Object.keys(underlyingSearchParams).forEach((prop) => {
        if (!_reflectutils.wellKnownProperties.has(prop)) {
          Object.defineProperty(promise, prop, {
            get() {
              const workUnitStore =
                _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
              (0, _dynamicrendering.trackDynamicDataInDynamicRender)(
                store,
                workUnitStore
              );
              return underlyingSearchParams[prop];
            },
            set(value) {
              Object.defineProperty(promise, prop, {
                value,
                writable: true,
                enumerable: true,
              });
            },
            enumerable: true,
            configurable: true,
          });
        }
      });
      return promise;
    }
    function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(
      underlyingSearchParams,
      store
    ) {
      const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
      if (cachedSearchParams) {
        return cachedSearchParams;
      }
      const proxiedProperties = new Set();
      const unproxiedProperties = [];
      // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying
      // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender
      // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking
      // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger
      // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce
      // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.
      let promiseInitialized = false;
      const proxiedUnderlying = new Proxy(underlyingSearchParams, {
        get(target, prop, receiver) {
          if (typeof prop === 'string' && promiseInitialized) {
            if (store.dynamicShouldError) {
              const expression = (0, _reflectutils.describeStringPropertyAccess)(
                'searchParams',
                prop
              );
              (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                store.route,
                expression
              );
            }
            const workUnitStore =
              _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
            (0, _dynamicrendering.trackDynamicDataInDynamicRender)(store, workUnitStore);
          }
          return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        has(target, prop) {
          if (typeof prop === 'string') {
            if (store.dynamicShouldError) {
              const expression = (0, _reflectutils.describeHasCheckingStringProperty)(
                'searchParams',
                prop
              );
              (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                store.route,
                expression
              );
            }
          }
          return Reflect.has(target, prop);
        },
        ownKeys(target) {
          if (store.dynamicShouldError) {
            const expression =
              '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
              store.route,
              expression
            );
          }
          return Reflect.ownKeys(target);
        },
      });
      // We don't use makeResolvedReactPromise here because searchParams
      // supports copying with spread and we don't want to unnecessarily
      // instrument the promise with spreadable properties of ReactPromise.
      const promise = new Promise((resolve) =>
        (0, _scheduler.scheduleImmediate)(() => resolve(underlyingSearchParams))
      );
      promise.then(() => {
        promiseInitialized = true;
      });
      Object.keys(underlyingSearchParams).forEach((prop) => {
        if (_reflectutils.wellKnownProperties.has(prop)) {
          // These properties cannot be shadowed because they need to be the
          // true underlying value for Promises to work correctly at runtime
          unproxiedProperties.push(prop);
        } else {
          proxiedProperties.add(prop);
          Object.defineProperty(promise, prop, {
            get() {
              return proxiedUnderlying[prop];
            },
            set(newValue) {
              Object.defineProperty(promise, prop, {
                value: newValue,
                writable: true,
                enumerable: true,
              });
            },
            enumerable: true,
            configurable: true,
          });
        }
      });
      const proxiedPromise = new Proxy(promise, {
        get(target, prop, receiver) {
          if (prop === 'then' && store.dynamicShouldError) {
            const expression = '`searchParams.then`';
            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
              store.route,
              expression
            );
          }
          if (typeof prop === 'string') {
            if (
              !_reflectutils.wellKnownProperties.has(prop) &&
              (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)
            ) {
              const expression = (0, _reflectutils.describeStringPropertyAccess)(
                'searchParams',
                prop
              );
              syncIODev(store.route, expression);
            }
          }
          return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (typeof prop === 'string') {
            proxiedProperties.delete(prop);
          }
          return Reflect.set(target, prop, value, receiver);
        },
        has(target, prop) {
          if (typeof prop === 'string') {
            if (
              !_reflectutils.wellKnownProperties.has(prop) &&
              (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)
            ) {
              const expression = (0, _reflectutils.describeHasCheckingStringProperty)(
                'searchParams',
                prop
              );
              syncIODev(store.route, expression);
            }
          }
          return Reflect.has(target, prop);
        },
        ownKeys(target) {
          const expression = '`Object.keys(searchParams)` or similar';
          syncIODev(store.route, expression, unproxiedProperties);
          return Reflect.ownKeys(target);
        },
      });
      CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
      return proxiedPromise;
    }
    function syncIODev(route, expression, missingProperties) {
      // In all cases we warn normally
      if (missingProperties && missingProperties.length > 0) {
        warnForIncompleteEnumeration(route, expression, missingProperties);
      } else {
        warnForSyncAccess(route, expression);
      }
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (
        workUnitStore &&
        workUnitStore.type === 'request' &&
        workUnitStore.prerenderPhase === true
      ) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
      }
    }
    const warnForSyncAccess = (0,
    _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(
      createSearchAccessError
    );
    const warnForIncompleteEnumeration = (0,
    _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(
      createIncompleteEnumerationError
    );
    function createSearchAccessError(route, expression) {
      const prefix = route ? `Route "${route}" ` : 'This route ';
      return Object.defineProperty(
        new Error(
          `${prefix}used ${expression}. ` +
            `\`searchParams\` should be awaited before using its properties. ` +
            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E249',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function createIncompleteEnumerationError(route, expression, missingProperties) {
      const prefix = route ? `Route "${route}" ` : 'This route ';
      return Object.defineProperty(
        new Error(
          `${prefix}used ${expression}. ` +
            `\`searchParams\` should be awaited before using its properties. ` +
            `The following properties were not available through enumeration ` +
            `because they conflict with builtin or well-known property names: ` +
            `${describeListOfPropertyNames(missingProperties)}. ` +
            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E2',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function describeListOfPropertyNames(properties) {
      switch (properties.length) {
        case 0:
          throw Object.defineProperty(
            new _invarianterror.InvariantError(
              'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E531',
              enumerable: false,
              configurable: true,
            }
          );
        case 1:
          return `\`${properties[0]}\``;
        case 2:
          return `\`${properties[0]}\` and \`${properties[1]}\``;
        default: {
          let description = '';
          for (let i = 0; i < properties.length - 1; i++) {
            description += `\`${properties[i]}\`, `;
          }
          description += `, and \`${properties[properties.length - 1]}\``;
          return description;
        }
      }
    }

    //# sourceMappingURL=search-params.js.map
  },
  7714: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      isRequestAPICallableInsideAfter: function () {
        return isRequestAPICallableInsideAfter;
      },
      throwForSearchParamsAccessInUseCache: function () {
        return throwForSearchParamsAccessInUseCache;
      },
      throwWithStaticGenerationBailoutError: function () {
        return throwWithStaticGenerationBailoutError;
      },
      throwWithStaticGenerationBailoutErrorWithDynamicError: function () {
        return throwWithStaticGenerationBailoutErrorWithDynamicError;
      },
    });
    const _staticgenerationbailout = __webpack_require__(2661);
    const _aftertaskasyncstorageexternal = __webpack_require__(5673);
    function throwWithStaticGenerationBailoutError(route, expression) {
      throw Object.defineProperty(
        new _staticgenerationbailout.StaticGenBailoutError(
          `Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E576',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {
      throw Object.defineProperty(
        new _staticgenerationbailout.StaticGenBailoutError(
          `Route ${route} with \`dynamic = "error"\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E543',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function throwForSearchParamsAccessInUseCache(workStore) {
      const error = Object.defineProperty(
        new Error(
          `Route ${workStore.route} used "searchParams" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "searchParams" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E634',
          enumerable: false,
          configurable: true,
        }
      );
      workStore.invalidUsageError ??= error;
      throw error;
    }
    function isRequestAPICallableInsideAfter() {
      const afterTaskStore =
        _aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore();
      return (
        (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action'
      );
    }

    //# sourceMappingURL=utils.js.map
  },
  5057: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    if (false) {
    } else {
      if (false) {
      } else {
        if (true) {
          if (false) {
          } else {
            module.exports = __webpack_require__(6693);
          }
        } else {
        }
      }
    }

    //# sourceMappingURL=module.compiled.js.map
  },
  1727: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(
        5057
      ) /* .vendored.contexts.AppRouterContext */.vendored.contexts.AppRouterContext;

    //# sourceMappingURL=app-router-context.js.map
  },
  1493: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(
        5057
      ) /* .vendored.contexts.HooksClientContext */.vendored.contexts.HooksClientContext;

    //# sourceMappingURL=hooks-client-context.js.map
  },
  3779: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(
        5057
      ) /* .vendored.contexts.ServerInsertedHtml */.vendored.contexts.ServerInsertedHtml;

    //# sourceMappingURL=server-inserted-html.js.map
  },
  3917: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(
        5057
      ) /* .vendored.contexts.ServerInsertedMetadata */.vendored.contexts.ServerInsertedMetadata;

    //# sourceMappingURL=server-inserted-metadata.js.map
  },
  2951: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(5057) /* .vendored["react-ssr"].ReactDOM */.vendored[
        'react-ssr'
      ].ReactDOM;

    //# sourceMappingURL=react-dom.js.map
  },
  3263: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(5057) /* .vendored["react-ssr"].ReactJsxRuntime */.vendored[
        'react-ssr'
      ].ReactJsxRuntime;

    //# sourceMappingURL=react-jsx-runtime.js.map
  },
  3232: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(
        5057
      ) /* .vendored["react-ssr"].ReactServerDOMWebpackClientEdge */.vendored[
        'react-ssr'
      ].ReactServerDOMWebpackClientEdge;

    //# sourceMappingURL=react-server-dom-webpack-client-edge.js.map
  },
  863: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(5057) /* .vendored["react-ssr"].React */.vendored[
        'react-ssr'
      ].React;

    //# sourceMappingURL=react.js.map
  },
  6792: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ReflectAdapter', {
      enumerable: true,
      get: function () {
        return ReflectAdapter;
      },
    });
    class ReflectAdapter {
      static get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === 'function') {
          return value.bind(target);
        }
        return value;
      }
      static set(target, prop, value, receiver) {
        return Reflect.set(target, prop, value, receiver);
      }
      static has(target, prop) {
        return Reflect.has(target, prop);
      }
      static deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
      }
    }

    //# sourceMappingURL=reflect.js.map
  },
  4557: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      decorateServerError: function () {
        return decorateServerError;
      },
      getErrorSource: function () {
        return getErrorSource;
      },
    });
    const symbolError = Symbol.for('NextjsError');
    function getErrorSource(error) {
      return error[symbolError] || null;
    }
    function decorateServerError(error, type) {
      Object.defineProperty(error, symbolError, {
        writable: false,
        enumerable: false,
        configurable: false,
        value: type,
      });
    } //# sourceMappingURL=error-source.js.map
  },
  3694: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'MISSING_ROOT_TAGS_ERROR', {
      enumerable: true,
      get: function () {
        return MISSING_ROOT_TAGS_ERROR;
      },
    });
    const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=constants.js.map
  },
  1180: function (__unused_webpack_module, exports) {
    'use strict';
    // http://www.cse.yorku.ca/~oz/hash.html
    // More specifically, 32-bit hash via djbxor
    // (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)
    // This is due to number type differences between rust for turbopack to js number types,
    // where rust does not have easy way to repreesnt js's 53-bit float number type for the matching
    // overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation
    // as can gaurantee determinstic output from 32bit hash.

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      djb2Hash: function () {
        return djb2Hash;
      },
      hexHash: function () {
        return hexHash;
      },
    });
    function djb2Hash(str) {
      let hash = 5381;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) + hash + char) & 0xffffffff;
      }
      return hash >>> 0;
    }
    function hexHash(str) {
      return djb2Hash(str).toString(36).slice(0, 5);
    } //# sourceMappingURL=hash.js.map
  },
  2748: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'InvariantError', {
      enumerable: true,
      get: function () {
        return InvariantError;
      },
    });
    class InvariantError extends Error {
      constructor(message, options) {
        super(
          'Invariant: ' +
            (message.endsWith('.') ? message : message + '.') +
            ' This is a bug in Next.js.',
          options
        );
        this.name = 'InvariantError';
      }
    } //# sourceMappingURL=invariant-error.js.map
  },
  4144: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getObjectClassLabel: function () {
        return getObjectClassLabel;
      },
      isPlainObject: function () {
        return isPlainObject;
      },
    });
    function getObjectClassLabel(value) {
      return Object.prototype.toString.call(value);
    }
    function isPlainObject(value) {
      if (getObjectClassLabel(value) !== '[object Object]') {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      /**
       * This used to be previously:
       *
       * `return prototype === null || prototype === Object.prototype`
       *
       * But Edge Runtime expose Object from vm, being that kind of type-checking wrongly
       * fail.
       *
       * It was changed to the current implementation since it's resilient to serialization.
       */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');
    } //# sourceMappingURL=is-plain-object.js.map
  },
  6066: function (__unused_webpack_module, exports) {
    'use strict';
    /**
     * Check to see if a value is Thenable.
     *
     * @param promise The maybe-thenable value
     * @returns True if the value is thenable
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'isThenable', {
      enumerable: true,
      get: function () {
        return isThenable;
      },
    });
    function isThenable(promise) {
      return (
        promise !== null &&
        typeof promise === 'object' &&
        'then' in promise &&
        typeof promise.then === 'function'
      );
    } //# sourceMappingURL=is-thenable.js.map
  },
  2926: function (__unused_webpack_module, exports) {
    'use strict';
    // This has to be a shared module which is shared between client component error boundary and dynamic component

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      BailoutToCSRError: function () {
        return BailoutToCSRError;
      },
      isBailoutToCSRError: function () {
        return isBailoutToCSRError;
      },
    });
    const BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
    class BailoutToCSRError extends Error {
      constructor(reason) {
        super('Bail out to client-side rendering: ' + reason),
          (this.reason = reason),
          (this.digest = BAILOUT_TO_CSR);
      }
    }
    function isBailoutToCSRError(err) {
      if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
      }
      return err.digest === BAILOUT_TO_CSR;
    } //# sourceMappingURL=bailout-to-csr.js.map
  },
  5329: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      MAGIC_IDENTIFIER_REGEX: function () {
        return MAGIC_IDENTIFIER_REGEX;
      },
      decodeMagicIdentifier: function () {
        return decodeMagicIdentifier;
      },
    });
    function decodeHex(hexStr) {
      if (hexStr.trim() === '') {
        throw Object.defineProperty(
          new Error("can't decode empty hex"),
          '__NEXT_ERROR_CODE',
          {
            value: 'E19',
            enumerable: false,
            configurable: true,
          }
        );
      }
      const num = parseInt(hexStr, 16);
      if (isNaN(num)) {
        throw Object.defineProperty(
          new Error('invalid hex: `' + hexStr + '`'),
          '__NEXT_ERROR_CODE',
          {
            value: 'E293',
            enumerable: false,
            configurable: true,
          }
        );
      }
      return String.fromCodePoint(num);
    }
    const DECODE_REGEX = /^__TURBOPACK__([a-zA-Z0-9_$]+)__$/;
    function decodeMagicIdentifier(identifier) {
      const matches = identifier.match(DECODE_REGEX);
      if (!matches) {
        return identifier;
      }
      const inner = matches[1];
      let output = '';
      let mode = 0;
      let buffer = '';
      for (let i = 0; i < inner.length; i++) {
        const char = inner[i];
        if (mode === 0) {
          if (char === '_') {
            mode = 1;
          } else if (char === '$') {
            mode = 2;
          } else {
            output += char;
          }
        } else if (mode === 1) {
          if (char === '_') {
            output += ' ';
            mode = 0;
          } else if (char === '$') {
            output += '_';
            mode = 2;
          } else {
            output += char;
            mode = 0;
          }
        } else if (mode === 2) {
          if (buffer.length === 2) {
            output += decodeHex(buffer);
            buffer = '';
          }
          if (char === '_') {
            if (buffer !== '') {
              throw Object.defineProperty(
                new Error('invalid hex: `' + buffer + '`'),
                '__NEXT_ERROR_CODE',
                {
                  value: 'E293',
                  enumerable: false,
                  configurable: true,
                }
              );
            }
            mode = 3;
          } else if (char === '$') {
            if (buffer !== '') {
              throw Object.defineProperty(
                new Error('invalid hex: `' + buffer + '`'),
                '__NEXT_ERROR_CODE',
                {
                  value: 'E293',
                  enumerable: false,
                  configurable: true,
                }
              );
            }
            mode = 0;
          } else {
            buffer += char;
          }
        } else if (mode === 3) {
          if (char === '_') {
            throw Object.defineProperty(
              new Error('invalid hex: `' + (buffer + char) + '`'),
              '__NEXT_ERROR_CODE',
              {
                value: 'E244',
                enumerable: false,
                configurable: true,
              }
            );
          } else if (char === '$') {
            output += decodeHex(buffer);
            buffer = '';
            mode = 0;
          } else {
            buffer += char;
          }
        }
      }
      return output;
    }
    const MAGIC_IDENTIFIER_REGEX = /__TURBOPACK__[a-zA-Z0-9_$]+__/g; //# sourceMappingURL=magic-identifier.js.map
  },
  6737: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'normalizedAssetPrefix', {
      enumerable: true,
      get: function () {
        return normalizedAssetPrefix;
      },
    });
    function normalizedAssetPrefix(assetPrefix) {
      // remove all leading slashes and trailing slashes
      const escapedAssetPrefix =
        (assetPrefix == null ? void 0 : assetPrefix.replace(/^\/+|\/+$/g, '')) || false;
      // if an assetPrefix was '/', we return empty string
      // because it could be an unnecessary trailing slash
      if (!escapedAssetPrefix) {
        return '';
      }
      if (URL.canParse(escapedAssetPrefix)) {
        const url = new URL(escapedAssetPrefix).toString();
        return url.endsWith('/') ? url.slice(0, -1) : url;
      }
      // assuming assetPrefix here is a pathname-style,
      // restore the leading slash
      return '/' + escapedAssetPrefix;
    } //# sourceMappingURL=normalized-asset-prefix.js.map
  },
  7326: function (__unused_webpack_module, exports) {
    'use strict';
    /**
     * For a given page path, this function ensures that there is a leading slash. If there is
     * not a leading slash, one is added, otherwise it is noop.
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ensureLeadingSlash', {
      enumerable: true,
      get: function () {
        return ensureLeadingSlash;
      },
    });
    function ensureLeadingSlash(path) {
      return path.startsWith('/') ? path : '/' + path;
    } //# sourceMappingURL=ensure-leading-slash.js.map
  },
  7433: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      normalizeAppPath: function () {
        return normalizeAppPath;
      },
      normalizeRscURL: function () {
        return normalizeRscURL;
      },
    });
    const _ensureleadingslash = __webpack_require__(7326);
    const _segment = __webpack_require__(5418);
    function normalizeAppPath(route) {
      return (0, _ensureleadingslash.ensureLeadingSlash)(
        route.split('/').reduce((pathname, segment, index, segments) => {
          // Empty segments are ignored.
          if (!segment) {
            return pathname;
          }
          // Groups are ignored.
          if ((0, _segment.isGroupSegment)(segment)) {
            return pathname;
          }
          // Parallel segments are ignored.
          if (segment[0] === '@') {
            return pathname;
          }
          // The last segment (if it's a leaf) should be ignored.
          if (
            (segment === 'page' || segment === 'route') &&
            index === segments.length - 1
          ) {
            return pathname;
          }
          return pathname + '/' + segment;
        }, '')
      );
    }
    function normalizeRscURL(url) {
      return url.replace(/\.rsc($|\?)/, '$1');
    } //# sourceMappingURL=app-paths.js.map
  },
  7346: function (__unused_webpack_module, exports) {
    'use strict';
    /**
     * Run function with `scroll-behavior: auto` applied to `<html/>`. This css change will be
     * reverted after the function finishes.
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'handleSmoothScroll', {
      enumerable: true,
      get: function () {
        return handleSmoothScroll;
      },
    });
    function handleSmoothScroll(fn, options) {
      if (options === void 0) options = {};
      // if only the hash is changed, we don't need to disable smooth scrolling
      // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX
      if (options.onlyHashChange) {
        fn();
        return;
      }
      const htmlElement = document.documentElement;
      const existing = htmlElement.style.scrollBehavior;
      htmlElement.style.scrollBehavior = 'auto';
      if (!options.dontForceLayout) {
        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.
        // Otherwise it will not pickup the change in scrollBehavior
        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042
        htmlElement.getClientRects();
      }
      fn();
      htmlElement.style.scrollBehavior = existing;
    } //# sourceMappingURL=handle-smooth-scroll.js.map
  },
  1412: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      INTERCEPTION_ROUTE_MARKERS: function () {
        return INTERCEPTION_ROUTE_MARKERS;
      },
      extractInterceptionRouteInformation: function () {
        return extractInterceptionRouteInformation;
      },
      isInterceptionRouteAppPath: function () {
        return isInterceptionRouteAppPath;
      },
    });
    const _apppaths = __webpack_require__(7433);
    const INTERCEPTION_ROUTE_MARKERS = ['(..)(..)', '(.)', '(..)', '(...)'];
    function isInterceptionRouteAppPath(path) {
      // TODO-APP: add more serious validation
      return (
        path
          .split('/')
          .find((segment) =>
            INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))
          ) !== undefined
      );
    }
    function extractInterceptionRouteInformation(path) {
      let interceptingRoute, marker, interceptedRoute;
      for (const segment of path.split('/')) {
        marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m));
        if (marker) {
          [interceptingRoute, interceptedRoute] = path.split(marker, 2);
          break;
        }
      }
      if (!interceptingRoute || !marker || !interceptedRoute) {
        throw Object.defineProperty(
          new Error(
            'Invalid interception route: ' +
              path +
              '. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>'
          ),
          '__NEXT_ERROR_CODE',
          {
            value: 'E269',
            enumerable: false,
            configurable: true,
          }
        );
      }
      interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute); // normalize the path, e.g. /(blog)/feed -> /feed
      switch (marker) {
        case '(.)':
          // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route
          if (interceptingRoute === '/') {
            interceptedRoute = '/' + interceptedRoute;
          } else {
            interceptedRoute = interceptingRoute + '/' + interceptedRoute;
          }
          break;
        case '(..)':
          // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route
          if (interceptingRoute === '/') {
            throw Object.defineProperty(
              new Error(
                'Invalid interception route: ' +
                  path +
                  '. Cannot use (..) marker at the root level, use (.) instead.'
              ),
              '__NEXT_ERROR_CODE',
              {
                value: 'E207',
                enumerable: false,
                configurable: true,
              }
            );
          }
          interceptedRoute = interceptingRoute
            .split('/')
            .slice(0, -1)
            .concat(interceptedRoute)
            .join('/');
          break;
        case '(...)':
          // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route
          interceptedRoute = '/' + interceptedRoute;
          break;
        case '(..)(..)':
          // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route
          const splitInterceptingRoute = interceptingRoute.split('/');
          if (splitInterceptingRoute.length <= 2) {
            throw Object.defineProperty(
              new Error(
                'Invalid interception route: ' +
                  path +
                  '. Cannot use (..)(..) marker at the root level or one level up.'
              ),
              '__NEXT_ERROR_CODE',
              {
                value: 'E486',
                enumerable: false,
                configurable: true,
              }
            );
          }
          interceptedRoute = splitInterceptingRoute
            .slice(0, -2)
            .concat(interceptedRoute)
            .join('/');
          break;
        default:
          throw Object.defineProperty(
            new Error('Invariant: unexpected marker'),
            '__NEXT_ERROR_CODE',
            {
              value: 'E112',
              enumerable: false,
              configurable: true,
            }
          );
      }
      return {
        interceptingRoute,
        interceptedRoute,
      };
    } //# sourceMappingURL=interception-routes.js.map
  },
  5418: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DEFAULT_SEGMENT_KEY: function () {
        return DEFAULT_SEGMENT_KEY;
      },
      PAGE_SEGMENT_KEY: function () {
        return PAGE_SEGMENT_KEY;
      },
      addSearchParamsIfPageSegment: function () {
        return addSearchParamsIfPageSegment;
      },
      isGroupSegment: function () {
        return isGroupSegment;
      },
      isParallelRouteSegment: function () {
        return isParallelRouteSegment;
      },
    });
    function isGroupSegment(segment) {
      // Use array[0] for performant purpose
      return segment[0] === '(' && segment.endsWith(')');
    }
    function isParallelRouteSegment(segment) {
      return segment.startsWith('@') && segment !== '@children';
    }
    function addSearchParamsIfPageSegment(segment, searchParams) {
      const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);
      if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== '{}'
          ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery
          : PAGE_SEGMENT_KEY;
      }
      return segment;
    }
    const PAGE_SEGMENT_KEY = '__PAGE__';
    const DEFAULT_SEGMENT_KEY = '__DEFAULT__'; //# sourceMappingURL=segment.js.map
  },
  6367: function (__unused_webpack_module, exports) {
    'use strict';
    // This regex will have fast negatives meaning valid identifiers may not pass
    // this test. However this is only used during static generation to provide hints
    // about why a page bailed out of some or all prerendering and we can use bracket notation
    // for example while `ಠ_ಠ` is a valid identifier it's ok to print `searchParams['ಠ_ಠ']`
    // even if this would have been fine too `searchParams.ಠ_ಠ`

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      describeHasCheckingStringProperty: function () {
        return describeHasCheckingStringProperty;
      },
      describeStringPropertyAccess: function () {
        return describeStringPropertyAccess;
      },
      wellKnownProperties: function () {
        return wellKnownProperties;
      },
    });
    const isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
    function describeStringPropertyAccess(target, prop) {
      if (isDefinitelyAValidIdentifier.test(prop)) {
        return '`' + target + '.' + prop + '`';
      }
      return '`' + target + '[' + JSON.stringify(prop) + ']`';
    }
    function describeHasCheckingStringProperty(target, prop) {
      const stringifiedProp = JSON.stringify(prop);
      return (
        '`Reflect.has(' +
        target +
        ', ' +
        stringifiedProp +
        ')`, `' +
        stringifiedProp +
        ' in ' +
        target +
        '`, or similar'
      );
    }
    const wellKnownProperties = new Set([
      'hasOwnProperty',
      'isPrototypeOf',
      'propertyIsEnumerable',
      'toString',
      'valueOf',
      'toLocaleString',
      // Promise prototype
      // fallthrough
      'then',
      'catch',
      'finally',
      // React Promise extension
      // fallthrough
      'status',
      // React introspection
      'displayName',
      // Common tested properties
      // fallthrough
      'toJSON',
      '$$typeof',
      '__esModule',
    ]); //# sourceMappingURL=reflect-utils.js.map
  },
  1859: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'warnOnce', {
      enumerable: true,
      get: function () {
        return warnOnce;
      },
    });
    let warnOnce = (_) => {};
    if (true) {
      const warnings = new Set();
      warnOnce = (msg) => {
        if (!warnings.has(msg)) {
          console.warn(msg);
        }
        warnings.add(msg);
      };
    } //# sourceMappingURL=warn-once.js.map
  },
  2139: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      bootstrap: function () {
        return bootstrap;
      },
      error: function () {
        return error;
      },
      event: function () {
        return event;
      },
      info: function () {
        return info;
      },
      prefixes: function () {
        return prefixes;
      },
      ready: function () {
        return ready;
      },
      trace: function () {
        return trace;
      },
      wait: function () {
        return wait;
      },
      warn: function () {
        return warn;
      },
      warnOnce: function () {
        return warnOnce;
      },
    });
    const _picocolors = __webpack_require__(9018);
    const _lrucache = __webpack_require__(9);
    const prefixes = {
      wait: (0, _picocolors.white)((0, _picocolors.bold)('○')),
      error: (0, _picocolors.red)((0, _picocolors.bold)('⨯')),
      warn: (0, _picocolors.yellow)((0, _picocolors.bold)('⚠')),
      ready: '▲',
      info: (0, _picocolors.white)((0, _picocolors.bold)(' ')),
      event: (0, _picocolors.green)((0, _picocolors.bold)('✓')),
      trace: (0, _picocolors.magenta)((0, _picocolors.bold)('»')),
    };
    const LOGGING_METHOD = {
      log: 'log',
      warn: 'warn',
      error: 'error',
    };
    function prefixedLog(prefixType, ...message) {
      if ((message[0] === '' || message[0] === undefined) && message.length === 1) {
        message.shift();
      }
      const consoleMethod =
        prefixType in LOGGING_METHOD ? LOGGING_METHOD[prefixType] : 'log';
      const prefix = prefixes[prefixType];
      // If there's no message, don't print the prefix but a new line
      if (message.length === 0) {
        console[consoleMethod]('');
      } else {
        // Ensure if there's ANSI escape codes it's concatenated into one string.
        // Chrome DevTool can only handle color if it's in one string.
        if (message.length === 1 && typeof message[0] === 'string') {
          console[consoleMethod](' ' + prefix + ' ' + message[0]);
        } else {
          console[consoleMethod](' ' + prefix, ...message);
        }
      }
    }
    function bootstrap(...message) {
      // logging format: ' <prefix> <message>'
      // e.g. ' ✓ Compiled successfully'
      // Add spaces to align with the indent of other logs
      console.log('   ' + message.join(' '));
    }
    function wait(...message) {
      prefixedLog('wait', ...message);
    }
    function error(...message) {
      prefixedLog('error', ...message);
    }
    function warn(...message) {
      prefixedLog('warn', ...message);
    }
    function ready(...message) {
      prefixedLog('ready', ...message);
    }
    function info(...message) {
      prefixedLog('info', ...message);
    }
    function event(...message) {
      prefixedLog('event', ...message);
    }
    function trace(...message) {
      prefixedLog('trace', ...message);
    }
    const warnOnceCache = new _lrucache.LRUCache(10000, (value) => value.length);
    function warnOnce(...message) {
      const key = message.join(' ');
      if (!warnOnceCache.has(key)) {
        warnOnceCache.set(key, key);
        warn(...message);
      }
    }

    //# sourceMappingURL=log.js.map
  },
  5356: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';
    /* eslint-disable import/no-extraneous-dependencies */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'createProxy', {
      enumerable: true,
      get: function () {
        return createProxy;
      },
    });
    const _serveredge = __webpack_require__(7322);
    const createProxy = _serveredge.createClientModuleProxy;

    //# sourceMappingURL=module-proxy.js.map
  },
  137: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ACTION_HEADER: function () {
        return ACTION_HEADER;
      },
      FLIGHT_HEADERS: function () {
        return FLIGHT_HEADERS;
      },
      NEXT_DID_POSTPONE_HEADER: function () {
        return NEXT_DID_POSTPONE_HEADER;
      },
      NEXT_HMR_REFRESH_HASH_COOKIE: function () {
        return NEXT_HMR_REFRESH_HASH_COOKIE;
      },
      NEXT_HMR_REFRESH_HEADER: function () {
        return NEXT_HMR_REFRESH_HEADER;
      },
      NEXT_IS_PRERENDER_HEADER: function () {
        return NEXT_IS_PRERENDER_HEADER;
      },
      NEXT_REWRITTEN_PATH_HEADER: function () {
        return NEXT_REWRITTEN_PATH_HEADER;
      },
      NEXT_REWRITTEN_QUERY_HEADER: function () {
        return NEXT_REWRITTEN_QUERY_HEADER;
      },
      NEXT_ROUTER_PREFETCH_HEADER: function () {
        return NEXT_ROUTER_PREFETCH_HEADER;
      },
      NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: function () {
        return NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;
      },
      NEXT_ROUTER_STALE_TIME_HEADER: function () {
        return NEXT_ROUTER_STALE_TIME_HEADER;
      },
      NEXT_ROUTER_STATE_TREE_HEADER: function () {
        return NEXT_ROUTER_STATE_TREE_HEADER;
      },
      NEXT_RSC_UNION_QUERY: function () {
        return NEXT_RSC_UNION_QUERY;
      },
      NEXT_URL: function () {
        return NEXT_URL;
      },
      RSC_CONTENT_TYPE_HEADER: function () {
        return RSC_CONTENT_TYPE_HEADER;
      },
      RSC_HEADER: function () {
        return RSC_HEADER;
      },
    });
    const RSC_HEADER = 'RSC';
    const ACTION_HEADER = 'Next-Action';
    const NEXT_ROUTER_STATE_TREE_HEADER = 'Next-Router-State-Tree';
    const NEXT_ROUTER_PREFETCH_HEADER = 'Next-Router-Prefetch';
    const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'Next-Router-Segment-Prefetch';
    const NEXT_HMR_REFRESH_HEADER = 'Next-HMR-Refresh';
    const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';
    const NEXT_URL = 'Next-Url';
    const RSC_CONTENT_TYPE_HEADER = 'text/x-component';
    const FLIGHT_HEADERS = [
      RSC_HEADER,
      NEXT_ROUTER_STATE_TREE_HEADER,
      NEXT_ROUTER_PREFETCH_HEADER,
      NEXT_HMR_REFRESH_HEADER,
      NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,
    ];
    const NEXT_RSC_UNION_QUERY = '_rsc';
    const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';
    const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';
    const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';
    const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';
    const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=app-router-headers.js.map
  },
  5940: function (module, __unused_webpack_exports, __webpack_require__) {
    const { createProxy } = __webpack_require__(5356);

    module.exports = createProxy(
      '/Users/lois/Documents/Github/work/repos/zephyr-packages/node_modules/.pnpm/next@15.3.3_@babel+core@7.26.10_babel-plugin-macros@3.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.86.0/node_modules/next/dist/client/components/client-page.js'
    );
  },
  2326: function (module, __unused_webpack_exports, __webpack_require__) {
    const { createProxy } = __webpack_require__(5356);

    module.exports = createProxy(
      '/Users/lois/Documents/Github/work/repos/zephyr-packages/node_modules/.pnpm/next@15.3.3_@babel+core@7.26.10_babel-plugin-macros@3.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.86.0/node_modules/next/dist/client/components/client-segment.js'
    );
  },
  1985: function (module, __unused_webpack_exports, __webpack_require__) {
    const { createProxy } = __webpack_require__(5356);

    module.exports = createProxy(
      '/Users/lois/Documents/Github/work/repos/zephyr-packages/node_modules/.pnpm/next@15.3.3_@babel+core@7.26.10_babel-plugin-macros@3.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.86.0/node_modules/next/dist/client/components/error-boundary.js'
    );
  },
  6595: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return Forbidden;
      },
    });
    const _jsxruntime = __webpack_require__(9133);
    const _errorfallback = __webpack_require__(6159);
    function Forbidden() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorfallback.HTTPAccessErrorFallback, {
        status: 403,
        message: 'This page could not be accessed.',
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=forbidden-error.js.map
  },
  1696: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DynamicServerError: function () {
        return DynamicServerError;
      },
      isDynamicServerError: function () {
        return isDynamicServerError;
      },
    });
    const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';
    class DynamicServerError extends Error {
      constructor(description) {
        super('Dynamic server usage: ' + description),
          (this.description = description),
          (this.digest = DYNAMIC_ERROR_CODE);
      }
    }
    function isDynamicServerError(err) {
      if (
        typeof err !== 'object' ||
        err === null ||
        !('digest' in err) ||
        typeof err.digest !== 'string'
      ) {
        return false;
      }
      return err.digest === DYNAMIC_ERROR_CODE;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=hooks-server-context.js.map
  },
  1285: function (module, __unused_webpack_exports, __webpack_require__) {
    const { createProxy } = __webpack_require__(5356);

    module.exports = createProxy(
      '/Users/lois/Documents/Github/work/repos/zephyr-packages/node_modules/.pnpm/next@15.3.3_@babel+core@7.26.10_babel-plugin-macros@3.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.86.0/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js'
    );
  },
  6159: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'HTTPAccessErrorFallback', {
      enumerable: true,
      get: function () {
        return HTTPAccessErrorFallback;
      },
    });
    const _interop_require_default = __webpack_require__(5053);
    const _jsxruntime = __webpack_require__(9133);
    const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8516));
    const styles = {
      error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily:
          'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: '100vh',
        textAlign: 'center',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
      },
      desc: {
        display: 'inline-block',
      },
      h1: {
        display: 'inline-block',
        margin: '0 20px 0 0',
        padding: '0 23px 0 0',
        fontSize: 24,
        fontWeight: 500,
        verticalAlign: 'top',
        lineHeight: '49px',
      },
      h2: {
        fontSize: 14,
        fontWeight: 400,
        lineHeight: '49px',
        margin: 0,
      },
    };
    function HTTPAccessErrorFallback(param) {
      let { status, message } = param;
      return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
          /*#__PURE__*/ (0, _jsxruntime.jsx)('title', {
            children: status + ': ' + message,
          }),
          /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
            style: styles.error,
            children: /*#__PURE__*/ (0, _jsxruntime.jsxs)('div', {
              children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)('style', {
                  dangerouslySetInnerHTML: {
                    /* Minified CSS from
                body { margin: 0; color: #000; background: #fff; }
                .next-error-h1 {
                  border-right: 1px solid rgba(0, 0, 0, .3);
                }

                @media (prefers-color-scheme: dark) {
                  body { color: #fff; background: #000; }
                  .next-error-h1 {
                    border-right: 1px solid rgba(255, 255, 255, .3);
                  }
                }
              */ __html:
                      'body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}',
                  },
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)('h1', {
                  className: 'next-error-h1',
                  style: styles.h1,
                  children: status,
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)('div', {
                  style: styles.desc,
                  children: /*#__PURE__*/ (0, _jsxruntime.jsx)('h2', {
                    style: styles.h2,
                    children: message,
                  }),
                }),
              ],
            }),
          }),
        ],
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=error-fallback.js.map
  },
  6750: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      HTTPAccessErrorStatus: function () {
        return HTTPAccessErrorStatus;
      },
      HTTP_ERROR_FALLBACK_ERROR_CODE: function () {
        return HTTP_ERROR_FALLBACK_ERROR_CODE;
      },
      getAccessFallbackErrorTypeByStatus: function () {
        return getAccessFallbackErrorTypeByStatus;
      },
      getAccessFallbackHTTPStatus: function () {
        return getAccessFallbackHTTPStatus;
      },
      isHTTPAccessFallbackError: function () {
        return isHTTPAccessFallbackError;
      },
    });
    const HTTPAccessErrorStatus = {
      NOT_FOUND: 404,
      FORBIDDEN: 403,
      UNAUTHORIZED: 401,
    };
    const ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));
    const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';
    function isHTTPAccessFallbackError(error) {
      if (
        typeof error !== 'object' ||
        error === null ||
        !('digest' in error) ||
        typeof error.digest !== 'string'
      ) {
        return false;
      }
      const [prefix, httpStatus] = error.digest.split(';');
      return (
        prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus))
      );
    }
    function getAccessFallbackHTTPStatus(error) {
      const httpStatus = error.digest.split(';')[1];
      return Number(httpStatus);
    }
    function getAccessFallbackErrorTypeByStatus(status) {
      switch (status) {
        case 401:
          return 'unauthorized';
        case 403:
          return 'forbidden';
        case 404:
          return 'not-found';
        default:
          return;
      }
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=http-access-fallback.js.map
  },
  7394: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'isNextRouterError', {
      enumerable: true,
      get: function () {
        return isNextRouterError;
      },
    });
    const _httpaccessfallback = __webpack_require__(6750);
    const _redirecterror = __webpack_require__(9868);
    function isNextRouterError(error) {
      return (
        (0, _redirecterror.isRedirectError)(error) ||
        (0, _httpaccessfallback.isHTTPAccessFallbackError)(error)
      );
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=is-next-router-error.js.map
  },
  6662: function (module, __unused_webpack_exports, __webpack_require__) {
    const { createProxy } = __webpack_require__(5356);

    module.exports = createProxy(
      '/Users/lois/Documents/Github/work/repos/zephyr-packages/node_modules/.pnpm/next@15.3.3_@babel+core@7.26.10_babel-plugin-macros@3.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.86.0/node_modules/next/dist/client/components/layout-router.js'
    );
  },
  7158: function (module, __unused_webpack_exports, __webpack_require__) {
    const { createProxy } = __webpack_require__(5356);

    module.exports = createProxy(
      '/Users/lois/Documents/Github/work/repos/zephyr-packages/node_modules/.pnpm/next@15.3.3_@babel+core@7.26.10_babel-plugin-macros@3.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.86.0/node_modules/next/dist/client/components/metadata/async-metadata.js'
    );
  },
  9967: function (module, __unused_webpack_exports, __webpack_require__) {
    const { createProxy } = __webpack_require__(5356);

    module.exports = createProxy(
      '/Users/lois/Documents/Github/work/repos/zephyr-packages/node_modules/.pnpm/next@15.3.3_@babel+core@7.26.10_babel-plugin-macros@3.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.86.0/node_modules/next/dist/client/components/metadata/metadata-boundary.js'
    );
  },
  2435: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return NotFound;
      },
    });
    const _jsxruntime = __webpack_require__(9133);
    const _errorfallback = __webpack_require__(6159);
    function NotFound() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorfallback.HTTPAccessErrorFallback, {
        status: 404,
        message: 'This page could not be found.',
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=not-found-error.js.map
  },
  9868: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      REDIRECT_ERROR_CODE: function () {
        return REDIRECT_ERROR_CODE;
      },
      RedirectType: function () {
        return RedirectType;
      },
      isRedirectError: function () {
        return isRedirectError;
      },
    });
    const _redirectstatuscode = __webpack_require__(7993);
    const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';
    var RedirectType = /*#__PURE__*/ (function (RedirectType) {
      RedirectType['push'] = 'push';
      RedirectType['replace'] = 'replace';
      return RedirectType;
    })({});
    function isRedirectError(error) {
      if (
        typeof error !== 'object' ||
        error === null ||
        !('digest' in error) ||
        typeof error.digest !== 'string'
      ) {
        return false;
      }
      const digest = error.digest.split(';');
      const [errorCode, type] = digest;
      const destination = digest.slice(2, -2).join(';');
      const status = digest.at(-2);
      const statusCode = Number(status);
      return (
        errorCode === REDIRECT_ERROR_CODE &&
        (type === 'replace' || type === 'push') &&
        typeof destination === 'string' &&
        !isNaN(statusCode) &&
        statusCode in _redirectstatuscode.RedirectStatusCode
      );
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=redirect-error.js.map
  },
  7993: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'RedirectStatusCode', {
      enumerable: true,
      get: function () {
        return RedirectStatusCode;
      },
    });
    var RedirectStatusCode = /*#__PURE__*/ (function (RedirectStatusCode) {
      RedirectStatusCode[(RedirectStatusCode['SeeOther'] = 303)] = 'SeeOther';
      RedirectStatusCode[(RedirectStatusCode['TemporaryRedirect'] = 307)] =
        'TemporaryRedirect';
      RedirectStatusCode[(RedirectStatusCode['PermanentRedirect'] = 308)] =
        'PermanentRedirect';
      return RedirectStatusCode;
    })({});
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=redirect-status-code.js.map
  },
  147: function (module, __unused_webpack_exports, __webpack_require__) {
    const { createProxy } = __webpack_require__(5356);

    module.exports = createProxy(
      '/Users/lois/Documents/Github/work/repos/zephyr-packages/node_modules/.pnpm/next@15.3.3_@babel+core@7.26.10_babel-plugin-macros@3.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.86.0/node_modules/next/dist/client/components/render-from-template-context.js'
    );
  },
  8489: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      StaticGenBailoutError: function () {
        return StaticGenBailoutError;
      },
      isStaticGenBailoutError: function () {
        return isStaticGenBailoutError;
      },
    });
    const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';
    class StaticGenBailoutError extends Error {
      constructor(...args) {
        super(...args), (this.code = NEXT_STATIC_GEN_BAILOUT);
      }
    }
    function isStaticGenBailoutError(error) {
      if (typeof error !== 'object' || error === null || !('code' in error)) {
        return false;
      }
      return error.code === NEXT_STATIC_GEN_BAILOUT;
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=static-generation-bailout.js.map
  },
  2621: function (module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return Unauthorized;
      },
    });
    const _jsxruntime = __webpack_require__(9133);
    const _errorfallback = __webpack_require__(6159);
    function Unauthorized() {
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorfallback.HTTPAccessErrorFallback, {
        status: 401,
        message: "You're not authorized to access this page.",
      });
    }
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=unauthorized-error.js.map
  },
  7558: function (module) {
    'use strict';

    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all) __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if ((from && typeof from === 'object') || typeof from === 'function') {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, {
              get: () => from[key],
              enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
            });
      }
      return to;
    };
    var __toCommonJS = (mod) =>
      __copyProps(__defProp({}, '__esModule', { value: true }), mod);

    // src/index.ts
    var src_exports = {};
    __export(src_exports, {
      RequestCookies: () => RequestCookies,
      ResponseCookies: () => ResponseCookies,
      parseCookie: () => parseCookie,
      parseSetCookie: () => parseSetCookie,
      stringifyCookie: () => stringifyCookie,
    });
    module.exports = __toCommonJS(src_exports);

    // src/serialize.ts
    function stringifyCookie(c) {
      var _a;
      const attrs = [
        'path' in c && c.path && `Path=${c.path}`,
        'expires' in c &&
          (c.expires || c.expires === 0) &&
          `Expires=${(typeof c.expires === 'number' ? new Date(c.expires) : c.expires).toUTCString()}`,
        'maxAge' in c && typeof c.maxAge === 'number' && `Max-Age=${c.maxAge}`,
        'domain' in c && c.domain && `Domain=${c.domain}`,
        'secure' in c && c.secure && 'Secure',
        'httpOnly' in c && c.httpOnly && 'HttpOnly',
        'sameSite' in c && c.sameSite && `SameSite=${c.sameSite}`,
        'partitioned' in c && c.partitioned && 'Partitioned',
        'priority' in c && c.priority && `Priority=${c.priority}`,
      ].filter(Boolean);
      const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : '')}`;
      return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join('; ')}`;
    }
    function parseCookie(cookie) {
      const map = /* @__PURE__ */ new Map();
      for (const pair of cookie.split(/; */)) {
        if (!pair) continue;
        const splitAt = pair.indexOf('=');
        if (splitAt === -1) {
          map.set(pair, 'true');
          continue;
        }
        const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];
        try {
          map.set(key, decodeURIComponent(value != null ? value : 'true'));
        } catch {}
      }
      return map;
    }
    function parseSetCookie(setCookie) {
      if (!setCookie) {
        return void 0;
      }
      const [[name, value], ...attributes] = parseCookie(setCookie);
      const {
        domain,
        expires,
        httponly,
        maxage,
        path,
        samesite,
        secure,
        partitioned,
        priority,
      } = Object.fromEntries(
        attributes.map(([key, value2]) => [key.toLowerCase().replace(/-/g, ''), value2])
      );
      const cookie = {
        name,
        value: decodeURIComponent(value),
        domain,
        ...(expires && { expires: new Date(expires) }),
        ...(httponly && { httpOnly: true }),
        ...(typeof maxage === 'string' && { maxAge: Number(maxage) }),
        path,
        ...(samesite && { sameSite: parseSameSite(samesite) }),
        ...(secure && { secure: true }),
        ...(priority && { priority: parsePriority(priority) }),
        ...(partitioned && { partitioned: true }),
      };
      return compact(cookie);
    }
    function compact(t) {
      const newT = {};
      for (const key in t) {
        if (t[key]) {
          newT[key] = t[key];
        }
      }
      return newT;
    }
    var SAME_SITE = ['strict', 'lax', 'none'];
    function parseSameSite(string) {
      string = string.toLowerCase();
      return SAME_SITE.includes(string) ? string : void 0;
    }
    var PRIORITY = ['low', 'medium', 'high'];
    function parsePriority(string) {
      string = string.toLowerCase();
      return PRIORITY.includes(string) ? string : void 0;
    }
    function splitCookiesString(cookiesString) {
      if (!cookiesString) return [];
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== '=' && ch !== ';' && ch !== ',';
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ',') {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === '=') {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }

    // src/request-cookies.ts
    var RequestCookies = class {
      constructor(requestHeaders) {
        /** @internal */
        this._parsed = /* @__PURE__ */ new Map();
        this._headers = requestHeaders;
        const header = requestHeaders.get('cookie');
        if (header) {
          const parsed = parseCookie(header);
          for (const [name, value] of parsed) {
            this._parsed.set(name, { name, value });
          }
        }
      }
      [Symbol.iterator]() {
        return this._parsed[Symbol.iterator]();
      }
      /** The amount of cookies received from the client */
      get size() {
        return this._parsed.size;
      }
      get(...args) {
        const name = typeof args[0] === 'string' ? args[0] : args[0].name;
        return this._parsed.get(name);
      }
      getAll(...args) {
        var _a;
        const all = Array.from(this._parsed);
        if (!args.length) {
          return all.map(([_, value]) => value);
        }
        const name =
          typeof args[0] === 'string'
            ? args[0]
            : (_a = args[0]) == null
              ? void 0
              : _a.name;
        return all.filter(([n]) => n === name).map(([_, value]) => value);
      }
      has(name) {
        return this._parsed.has(name);
      }
      set(...args) {
        const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;
        const map = this._parsed;
        map.set(name, { name, value });
        this._headers.set(
          'cookie',
          Array.from(map)
            .map(([_, value2]) => stringifyCookie(value2))
            .join('; ')
        );
        return this;
      }
      /** Delete the cookies matching the passed name or names in the request. */
      delete(names) {
        const map = this._parsed;
        const result = !Array.isArray(names)
          ? map.delete(names)
          : names.map((name) => map.delete(name));
        this._headers.set(
          'cookie',
          Array.from(map)
            .map(([_, value]) => stringifyCookie(value))
            .join('; ')
        );
        return result;
      }
      /** Delete all the cookies in the cookies in the request. */
      clear() {
        this.delete(Array.from(this._parsed.keys()));
        return this;
      }
      /** Format the cookies in the request as a string for logging */
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
      }
      toString() {
        return [...this._parsed.values()]
          .map((v) => `${v.name}=${encodeURIComponent(v.value)}`)
          .join('; ');
      }
    };

    // src/response-cookies.ts
    var ResponseCookies = class {
      constructor(responseHeaders) {
        /** @internal */
        this._parsed = /* @__PURE__ */ new Map();
        var _a, _b, _c;
        this._headers = responseHeaders;
        const setCookie =
          (_c =
            (_b =
              (_a = responseHeaders.getSetCookie) == null
                ? void 0
                : _a.call(responseHeaders)) != null
              ? _b
              : responseHeaders.get('set-cookie')) != null
            ? _c
            : [];
        const cookieStrings = Array.isArray(setCookie)
          ? setCookie
          : splitCookiesString(setCookie);
        for (const cookieString of cookieStrings) {
          const parsed = parseSetCookie(cookieString);
          if (parsed) this._parsed.set(parsed.name, parsed);
        }
      }
      /**
       * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without
       * the Promise.
       */
      get(...args) {
        const key = typeof args[0] === 'string' ? args[0] : args[0].name;
        return this._parsed.get(key);
      }
      /**
       * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll}
       * without the Promise.
       */
      getAll(...args) {
        var _a;
        const all = Array.from(this._parsed.values());
        if (!args.length) {
          return all;
        }
        const key =
          typeof args[0] === 'string'
            ? args[0]
            : (_a = args[0]) == null
              ? void 0
              : _a.name;
        return all.filter((c) => c.name === key);
      }
      has(name) {
        return this._parsed.has(name);
      }
      /**
       * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without
       * the Promise.
       */
      set(...args) {
        const [name, value, cookie] =
          args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;
        const map = this._parsed;
        map.set(name, normalizeCookie({ name, value, ...cookie }));
        replace(map, this._headers);
        return this;
      }
      /**
       * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete}
       * without the Promise.
       */
      delete(...args) {
        const [name, options] =
          typeof args[0] === 'string' ? [args[0]] : [args[0].name, args[0]];
        return this.set({
          ...options,
          name,
          value: '',
          expires: /* @__PURE__ */ new Date(0),
        });
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
      }
      toString() {
        return [...this._parsed.values()].map(stringifyCookie).join('; ');
      }
    };
    function replace(bag, headers) {
      headers.delete('set-cookie');
      for (const [, value] of bag) {
        const serialized = stringifyCookie(value);
        headers.append('set-cookie', serialized);
      }
    }
    function normalizeCookie(cookie = { name: '', value: '' }) {
      if (typeof cookie.expires === 'number') {
        cookie.expires = new Date(cookie.expires);
      }
      if (cookie.maxAge) {
        cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);
      }
      if (cookie.path === null || cookie.path === void 0) {
        cookie.path = '/';
      }
      return cookie;
    }
    // Annotate the CommonJS export names for ESM import in node:
    0 && 0;
  },
  5358: function (module) {
    (() => {
      'use strict';
      var e = {
        491: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.ContextAPI = void 0;
          const n = r(223);
          const a = r(172);
          const o = r(930);
          const i = 'context';
          const c = new n.NoopContextManager();
          class ContextAPI {
            constructor() {}
            static getInstance() {
              if (!this._instance) {
                this._instance = new ContextAPI();
              }
              return this._instance;
            }
            setGlobalContextManager(e) {
              return (0, a.registerGlobal)(i, e, o.DiagAPI.instance());
            }
            active() {
              return this._getContextManager().active();
            }
            with(e, t, r, ...n) {
              return this._getContextManager().with(e, t, r, ...n);
            }
            bind(e, t) {
              return this._getContextManager().bind(e, t);
            }
            _getContextManager() {
              return (0, a.getGlobal)(i) || c;
            }
            disable() {
              this._getContextManager().disable();
              (0, a.unregisterGlobal)(i, o.DiagAPI.instance());
            }
          }
          t.ContextAPI = ContextAPI;
        },
        930: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.DiagAPI = void 0;
          const n = r(56);
          const a = r(912);
          const o = r(957);
          const i = r(172);
          const c = 'diag';
          class DiagAPI {
            constructor() {
              function _logProxy(e) {
                return function (...t) {
                  const r = (0, i.getGlobal)('diag');
                  if (!r) return;
                  return r[e](...t);
                };
              }
              const e = this;
              const setLogger = (t, r = { logLevel: o.DiagLogLevel.INFO }) => {
                var n, c, s;
                if (t === e) {
                  const t = new Error(
                    'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'
                  );
                  e.error((n = t.stack) !== null && n !== void 0 ? n : t.message);
                  return false;
                }
                if (typeof r === 'number') {
                  r = { logLevel: r };
                }
                const u = (0, i.getGlobal)('diag');
                const l = (0, a.createLogLevelDiagLogger)(
                  (c = r.logLevel) !== null && c !== void 0 ? c : o.DiagLogLevel.INFO,
                  t
                );
                if (u && !r.suppressOverrideMessage) {
                  const e =
                    (s = new Error().stack) !== null && s !== void 0
                      ? s
                      : '<failed to generate stacktrace>';
                  u.warn(`Current logger will be overwritten from ${e}`);
                  l.warn(
                    `Current logger will overwrite one already registered from ${e}`
                  );
                }
                return (0, i.registerGlobal)('diag', l, e, true);
              };
              e.setLogger = setLogger;
              e.disable = () => {
                (0, i.unregisterGlobal)(c, e);
              };
              e.createComponentLogger = (e) => new n.DiagComponentLogger(e);
              e.verbose = _logProxy('verbose');
              e.debug = _logProxy('debug');
              e.info = _logProxy('info');
              e.warn = _logProxy('warn');
              e.error = _logProxy('error');
            }
            static instance() {
              if (!this._instance) {
                this._instance = new DiagAPI();
              }
              return this._instance;
            }
          }
          t.DiagAPI = DiagAPI;
        },
        653: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.MetricsAPI = void 0;
          const n = r(660);
          const a = r(172);
          const o = r(930);
          const i = 'metrics';
          class MetricsAPI {
            constructor() {}
            static getInstance() {
              if (!this._instance) {
                this._instance = new MetricsAPI();
              }
              return this._instance;
            }
            setGlobalMeterProvider(e) {
              return (0, a.registerGlobal)(i, e, o.DiagAPI.instance());
            }
            getMeterProvider() {
              return (0, a.getGlobal)(i) || n.NOOP_METER_PROVIDER;
            }
            getMeter(e, t, r) {
              return this.getMeterProvider().getMeter(e, t, r);
            }
            disable() {
              (0, a.unregisterGlobal)(i, o.DiagAPI.instance());
            }
          }
          t.MetricsAPI = MetricsAPI;
        },
        181: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.PropagationAPI = void 0;
          const n = r(172);
          const a = r(874);
          const o = r(194);
          const i = r(277);
          const c = r(369);
          const s = r(930);
          const u = 'propagation';
          const l = new a.NoopTextMapPropagator();
          class PropagationAPI {
            constructor() {
              this.createBaggage = c.createBaggage;
              this.getBaggage = i.getBaggage;
              this.getActiveBaggage = i.getActiveBaggage;
              this.setBaggage = i.setBaggage;
              this.deleteBaggage = i.deleteBaggage;
            }
            static getInstance() {
              if (!this._instance) {
                this._instance = new PropagationAPI();
              }
              return this._instance;
            }
            setGlobalPropagator(e) {
              return (0, n.registerGlobal)(u, e, s.DiagAPI.instance());
            }
            inject(e, t, r = o.defaultTextMapSetter) {
              return this._getGlobalPropagator().inject(e, t, r);
            }
            extract(e, t, r = o.defaultTextMapGetter) {
              return this._getGlobalPropagator().extract(e, t, r);
            }
            fields() {
              return this._getGlobalPropagator().fields();
            }
            disable() {
              (0, n.unregisterGlobal)(u, s.DiagAPI.instance());
            }
            _getGlobalPropagator() {
              return (0, n.getGlobal)(u) || l;
            }
          }
          t.PropagationAPI = PropagationAPI;
        },
        997: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.TraceAPI = void 0;
          const n = r(172);
          const a = r(846);
          const o = r(139);
          const i = r(607);
          const c = r(930);
          const s = 'trace';
          class TraceAPI {
            constructor() {
              this._proxyTracerProvider = new a.ProxyTracerProvider();
              this.wrapSpanContext = o.wrapSpanContext;
              this.isSpanContextValid = o.isSpanContextValid;
              this.deleteSpan = i.deleteSpan;
              this.getSpan = i.getSpan;
              this.getActiveSpan = i.getActiveSpan;
              this.getSpanContext = i.getSpanContext;
              this.setSpan = i.setSpan;
              this.setSpanContext = i.setSpanContext;
            }
            static getInstance() {
              if (!this._instance) {
                this._instance = new TraceAPI();
              }
              return this._instance;
            }
            setGlobalTracerProvider(e) {
              const t = (0, n.registerGlobal)(
                s,
                this._proxyTracerProvider,
                c.DiagAPI.instance()
              );
              if (t) {
                this._proxyTracerProvider.setDelegate(e);
              }
              return t;
            }
            getTracerProvider() {
              return (0, n.getGlobal)(s) || this._proxyTracerProvider;
            }
            getTracer(e, t) {
              return this.getTracerProvider().getTracer(e, t);
            }
            disable() {
              (0, n.unregisterGlobal)(s, c.DiagAPI.instance());
              this._proxyTracerProvider = new a.ProxyTracerProvider();
            }
          }
          t.TraceAPI = TraceAPI;
        },
        277: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.deleteBaggage = t.setBaggage = t.getActiveBaggage = t.getBaggage = void 0;
          const n = r(491);
          const a = r(780);
          const o = (0, a.createContextKey)('OpenTelemetry Baggage Key');
          function getBaggage(e) {
            return e.getValue(o) || undefined;
          }
          t.getBaggage = getBaggage;
          function getActiveBaggage() {
            return getBaggage(n.ContextAPI.getInstance().active());
          }
          t.getActiveBaggage = getActiveBaggage;
          function setBaggage(e, t) {
            return e.setValue(o, t);
          }
          t.setBaggage = setBaggage;
          function deleteBaggage(e) {
            return e.deleteValue(o);
          }
          t.deleteBaggage = deleteBaggage;
        },
        993: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.BaggageImpl = void 0;
          class BaggageImpl {
            constructor(e) {
              this._entries = e ? new Map(e) : new Map();
            }
            getEntry(e) {
              const t = this._entries.get(e);
              if (!t) {
                return undefined;
              }
              return Object.assign({}, t);
            }
            getAllEntries() {
              return Array.from(this._entries.entries()).map(([e, t]) => [e, t]);
            }
            setEntry(e, t) {
              const r = new BaggageImpl(this._entries);
              r._entries.set(e, t);
              return r;
            }
            removeEntry(e) {
              const t = new BaggageImpl(this._entries);
              t._entries.delete(e);
              return t;
            }
            removeEntries(...e) {
              const t = new BaggageImpl(this._entries);
              for (const r of e) {
                t._entries.delete(r);
              }
              return t;
            }
            clear() {
              return new BaggageImpl();
            }
          }
          t.BaggageImpl = BaggageImpl;
        },
        830: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.baggageEntryMetadataSymbol = void 0;
          t.baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');
        },
        369: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.baggageEntryMetadataFromString = t.createBaggage = void 0;
          const n = r(930);
          const a = r(993);
          const o = r(830);
          const i = n.DiagAPI.instance();
          function createBaggage(e = {}) {
            return new a.BaggageImpl(new Map(Object.entries(e)));
          }
          t.createBaggage = createBaggage;
          function baggageEntryMetadataFromString(e) {
            if (typeof e !== 'string') {
              i.error(`Cannot create baggage metadata from unknown type: ${typeof e}`);
              e = '';
            }
            return {
              __TYPE__: o.baggageEntryMetadataSymbol,
              toString() {
                return e;
              },
            };
          }
          t.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
        },
        67: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.context = void 0;
          const n = r(491);
          t.context = n.ContextAPI.getInstance();
        },
        223: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.NoopContextManager = void 0;
          const n = r(780);
          class NoopContextManager {
            active() {
              return n.ROOT_CONTEXT;
            }
            with(e, t, r, ...n) {
              return t.call(r, ...n);
            }
            bind(e, t) {
              return t;
            }
            enable() {
              return this;
            }
            disable() {
              return this;
            }
          }
          t.NoopContextManager = NoopContextManager;
        },
        780: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.ROOT_CONTEXT = t.createContextKey = void 0;
          function createContextKey(e) {
            return Symbol.for(e);
          }
          t.createContextKey = createContextKey;
          class BaseContext {
            constructor(e) {
              const t = this;
              t._currentContext = e ? new Map(e) : new Map();
              t.getValue = (e) => t._currentContext.get(e);
              t.setValue = (e, r) => {
                const n = new BaseContext(t._currentContext);
                n._currentContext.set(e, r);
                return n;
              };
              t.deleteValue = (e) => {
                const r = new BaseContext(t._currentContext);
                r._currentContext.delete(e);
                return r;
              };
            }
          }
          t.ROOT_CONTEXT = new BaseContext();
        },
        506: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.diag = void 0;
          const n = r(930);
          t.diag = n.DiagAPI.instance();
        },
        56: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.DiagComponentLogger = void 0;
          const n = r(172);
          class DiagComponentLogger {
            constructor(e) {
              this._namespace = e.namespace || 'DiagComponentLogger';
            }
            debug(...e) {
              return logProxy('debug', this._namespace, e);
            }
            error(...e) {
              return logProxy('error', this._namespace, e);
            }
            info(...e) {
              return logProxy('info', this._namespace, e);
            }
            warn(...e) {
              return logProxy('warn', this._namespace, e);
            }
            verbose(...e) {
              return logProxy('verbose', this._namespace, e);
            }
          }
          t.DiagComponentLogger = DiagComponentLogger;
          function logProxy(e, t, r) {
            const a = (0, n.getGlobal)('diag');
            if (!a) {
              return;
            }
            r.unshift(t);
            return a[e](...r);
          }
        },
        972: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.DiagConsoleLogger = void 0;
          const r = [
            { n: 'error', c: 'error' },
            { n: 'warn', c: 'warn' },
            { n: 'info', c: 'info' },
            { n: 'debug', c: 'debug' },
            { n: 'verbose', c: 'trace' },
          ];
          class DiagConsoleLogger {
            constructor() {
              function _consoleFunc(e) {
                return function (...t) {
                  if (console) {
                    let r = console[e];
                    if (typeof r !== 'function') {
                      r = console.log;
                    }
                    if (typeof r === 'function') {
                      return r.apply(console, t);
                    }
                  }
                };
              }
              for (let e = 0; e < r.length; e++) {
                this[r[e].n] = _consoleFunc(r[e].c);
              }
            }
          }
          t.DiagConsoleLogger = DiagConsoleLogger;
        },
        912: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.createLogLevelDiagLogger = void 0;
          const n = r(957);
          function createLogLevelDiagLogger(e, t) {
            if (e < n.DiagLogLevel.NONE) {
              e = n.DiagLogLevel.NONE;
            } else if (e > n.DiagLogLevel.ALL) {
              e = n.DiagLogLevel.ALL;
            }
            t = t || {};
            function _filterFunc(r, n) {
              const a = t[r];
              if (typeof a === 'function' && e >= n) {
                return a.bind(t);
              }
              return function () {};
            }
            return {
              error: _filterFunc('error', n.DiagLogLevel.ERROR),
              warn: _filterFunc('warn', n.DiagLogLevel.WARN),
              info: _filterFunc('info', n.DiagLogLevel.INFO),
              debug: _filterFunc('debug', n.DiagLogLevel.DEBUG),
              verbose: _filterFunc('verbose', n.DiagLogLevel.VERBOSE),
            };
          }
          t.createLogLevelDiagLogger = createLogLevelDiagLogger;
        },
        957: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.DiagLogLevel = void 0;
          var r;
          (function (e) {
            e[(e['NONE'] = 0)] = 'NONE';
            e[(e['ERROR'] = 30)] = 'ERROR';
            e[(e['WARN'] = 50)] = 'WARN';
            e[(e['INFO'] = 60)] = 'INFO';
            e[(e['DEBUG'] = 70)] = 'DEBUG';
            e[(e['VERBOSE'] = 80)] = 'VERBOSE';
            e[(e['ALL'] = 9999)] = 'ALL';
          })((r = t.DiagLogLevel || (t.DiagLogLevel = {})));
        },
        172: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.unregisterGlobal = t.getGlobal = t.registerGlobal = void 0;
          const n = r(200);
          const a = r(521);
          const o = r(130);
          const i = a.VERSION.split('.')[0];
          const c = Symbol.for(`opentelemetry.js.api.${i}`);
          const s = n._globalThis;
          function registerGlobal(e, t, r, n = false) {
            var o;
            const i = (s[c] =
              (o = s[c]) !== null && o !== void 0 ? o : { version: a.VERSION });
            if (!n && i[e]) {
              const t = new Error(
                `@opentelemetry/api: Attempted duplicate registration of API: ${e}`
              );
              r.error(t.stack || t.message);
              return false;
            }
            if (i.version !== a.VERSION) {
              const t = new Error(
                `@opentelemetry/api: Registration of version v${i.version} for ${e} does not match previously registered API v${a.VERSION}`
              );
              r.error(t.stack || t.message);
              return false;
            }
            i[e] = t;
            r.debug(`@opentelemetry/api: Registered a global for ${e} v${a.VERSION}.`);
            return true;
          }
          t.registerGlobal = registerGlobal;
          function getGlobal(e) {
            var t, r;
            const n = (t = s[c]) === null || t === void 0 ? void 0 : t.version;
            if (!n || !(0, o.isCompatible)(n)) {
              return;
            }
            return (r = s[c]) === null || r === void 0 ? void 0 : r[e];
          }
          t.getGlobal = getGlobal;
          function unregisterGlobal(e, t) {
            t.debug(`@opentelemetry/api: Unregistering a global for ${e} v${a.VERSION}.`);
            const r = s[c];
            if (r) {
              delete r[e];
            }
          }
          t.unregisterGlobal = unregisterGlobal;
        },
        130: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.isCompatible = t._makeCompatibilityCheck = void 0;
          const n = r(521);
          const a = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
          function _makeCompatibilityCheck(e) {
            const t = new Set([e]);
            const r = new Set();
            const n = e.match(a);
            if (!n) {
              return () => false;
            }
            const o = { major: +n[1], minor: +n[2], patch: +n[3], prerelease: n[4] };
            if (o.prerelease != null) {
              return function isExactmatch(t) {
                return t === e;
              };
            }
            function _reject(e) {
              r.add(e);
              return false;
            }
            function _accept(e) {
              t.add(e);
              return true;
            }
            return function isCompatible(e) {
              if (t.has(e)) {
                return true;
              }
              if (r.has(e)) {
                return false;
              }
              const n = e.match(a);
              if (!n) {
                return _reject(e);
              }
              const i = { major: +n[1], minor: +n[2], patch: +n[3], prerelease: n[4] };
              if (i.prerelease != null) {
                return _reject(e);
              }
              if (o.major !== i.major) {
                return _reject(e);
              }
              if (o.major === 0) {
                if (o.minor === i.minor && o.patch <= i.patch) {
                  return _accept(e);
                }
                return _reject(e);
              }
              if (o.minor <= i.minor) {
                return _accept(e);
              }
              return _reject(e);
            };
          }
          t._makeCompatibilityCheck = _makeCompatibilityCheck;
          t.isCompatible = _makeCompatibilityCheck(n.VERSION);
        },
        886: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.metrics = void 0;
          const n = r(653);
          t.metrics = n.MetricsAPI.getInstance();
        },
        901: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.ValueType = void 0;
          var r;
          (function (e) {
            e[(e['INT'] = 0)] = 'INT';
            e[(e['DOUBLE'] = 1)] = 'DOUBLE';
          })((r = t.ValueType || (t.ValueType = {})));
        },
        102: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.createNoopMeter =
            t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =
            t.NOOP_OBSERVABLE_GAUGE_METRIC =
            t.NOOP_OBSERVABLE_COUNTER_METRIC =
            t.NOOP_UP_DOWN_COUNTER_METRIC =
            t.NOOP_HISTOGRAM_METRIC =
            t.NOOP_COUNTER_METRIC =
            t.NOOP_METER =
            t.NoopObservableUpDownCounterMetric =
            t.NoopObservableGaugeMetric =
            t.NoopObservableCounterMetric =
            t.NoopObservableMetric =
            t.NoopHistogramMetric =
            t.NoopUpDownCounterMetric =
            t.NoopCounterMetric =
            t.NoopMetric =
            t.NoopMeter =
              void 0;
          class NoopMeter {
            constructor() {}
            createHistogram(e, r) {
              return t.NOOP_HISTOGRAM_METRIC;
            }
            createCounter(e, r) {
              return t.NOOP_COUNTER_METRIC;
            }
            createUpDownCounter(e, r) {
              return t.NOOP_UP_DOWN_COUNTER_METRIC;
            }
            createObservableGauge(e, r) {
              return t.NOOP_OBSERVABLE_GAUGE_METRIC;
            }
            createObservableCounter(e, r) {
              return t.NOOP_OBSERVABLE_COUNTER_METRIC;
            }
            createObservableUpDownCounter(e, r) {
              return t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
            }
            addBatchObservableCallback(e, t) {}
            removeBatchObservableCallback(e) {}
          }
          t.NoopMeter = NoopMeter;
          class NoopMetric {}
          t.NoopMetric = NoopMetric;
          class NoopCounterMetric extends NoopMetric {
            add(e, t) {}
          }
          t.NoopCounterMetric = NoopCounterMetric;
          class NoopUpDownCounterMetric extends NoopMetric {
            add(e, t) {}
          }
          t.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
          class NoopHistogramMetric extends NoopMetric {
            record(e, t) {}
          }
          t.NoopHistogramMetric = NoopHistogramMetric;
          class NoopObservableMetric {
            addCallback(e) {}
            removeCallback(e) {}
          }
          t.NoopObservableMetric = NoopObservableMetric;
          class NoopObservableCounterMetric extends NoopObservableMetric {}
          t.NoopObservableCounterMetric = NoopObservableCounterMetric;
          class NoopObservableGaugeMetric extends NoopObservableMetric {}
          t.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
          class NoopObservableUpDownCounterMetric extends NoopObservableMetric {}
          t.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
          t.NOOP_METER = new NoopMeter();
          t.NOOP_COUNTER_METRIC = new NoopCounterMetric();
          t.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
          t.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
          t.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
          t.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
          t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =
            new NoopObservableUpDownCounterMetric();
          function createNoopMeter() {
            return t.NOOP_METER;
          }
          t.createNoopMeter = createNoopMeter;
        },
        660: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.NOOP_METER_PROVIDER = t.NoopMeterProvider = void 0;
          const n = r(102);
          class NoopMeterProvider {
            getMeter(e, t, r) {
              return n.NOOP_METER;
            }
          }
          t.NoopMeterProvider = NoopMeterProvider;
          t.NOOP_METER_PROVIDER = new NoopMeterProvider();
        },
        200: function (e, t, r) {
          var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  if (n === undefined) n = r;
                  Object.defineProperty(e, n, {
                    enumerable: true,
                    get: function () {
                      return t[r];
                    },
                  });
                }
              : function (e, t, r, n) {
                  if (n === undefined) n = r;
                  e[n] = t[r];
                });
          var a =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                if (r !== 'default' && !Object.prototype.hasOwnProperty.call(t, r))
                  n(t, e, r);
            };
          Object.defineProperty(t, '__esModule', { value: true });
          a(r(46), t);
        },
        651: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t._globalThis = void 0;
          t._globalThis = typeof globalThis === 'object' ? globalThis : global;
        },
        46: function (e, t, r) {
          var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  if (n === undefined) n = r;
                  Object.defineProperty(e, n, {
                    enumerable: true,
                    get: function () {
                      return t[r];
                    },
                  });
                }
              : function (e, t, r, n) {
                  if (n === undefined) n = r;
                  e[n] = t[r];
                });
          var a =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                if (r !== 'default' && !Object.prototype.hasOwnProperty.call(t, r))
                  n(t, e, r);
            };
          Object.defineProperty(t, '__esModule', { value: true });
          a(r(651), t);
        },
        939: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.propagation = void 0;
          const n = r(181);
          t.propagation = n.PropagationAPI.getInstance();
        },
        874: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.NoopTextMapPropagator = void 0;
          class NoopTextMapPropagator {
            inject(e, t) {}
            extract(e, t) {
              return e;
            }
            fields() {
              return [];
            }
          }
          t.NoopTextMapPropagator = NoopTextMapPropagator;
        },
        194: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.defaultTextMapSetter = t.defaultTextMapGetter = void 0;
          t.defaultTextMapGetter = {
            get(e, t) {
              if (e == null) {
                return undefined;
              }
              return e[t];
            },
            keys(e) {
              if (e == null) {
                return [];
              }
              return Object.keys(e);
            },
          };
          t.defaultTextMapSetter = {
            set(e, t, r) {
              if (e == null) {
                return;
              }
              e[t] = r;
            },
          };
        },
        845: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.trace = void 0;
          const n = r(997);
          t.trace = n.TraceAPI.getInstance();
        },
        403: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.NonRecordingSpan = void 0;
          const n = r(476);
          class NonRecordingSpan {
            constructor(e = n.INVALID_SPAN_CONTEXT) {
              this._spanContext = e;
            }
            spanContext() {
              return this._spanContext;
            }
            setAttribute(e, t) {
              return this;
            }
            setAttributes(e) {
              return this;
            }
            addEvent(e, t) {
              return this;
            }
            setStatus(e) {
              return this;
            }
            updateName(e) {
              return this;
            }
            end(e) {}
            isRecording() {
              return false;
            }
            recordException(e, t) {}
          }
          t.NonRecordingSpan = NonRecordingSpan;
        },
        614: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.NoopTracer = void 0;
          const n = r(491);
          const a = r(607);
          const o = r(403);
          const i = r(139);
          const c = n.ContextAPI.getInstance();
          class NoopTracer {
            startSpan(e, t, r = c.active()) {
              const n = Boolean(t === null || t === void 0 ? void 0 : t.root);
              if (n) {
                return new o.NonRecordingSpan();
              }
              const s = r && (0, a.getSpanContext)(r);
              if (isSpanContext(s) && (0, i.isSpanContextValid)(s)) {
                return new o.NonRecordingSpan(s);
              } else {
                return new o.NonRecordingSpan();
              }
            }
            startActiveSpan(e, t, r, n) {
              let o;
              let i;
              let s;
              if (arguments.length < 2) {
                return;
              } else if (arguments.length === 2) {
                s = t;
              } else if (arguments.length === 3) {
                o = t;
                s = r;
              } else {
                o = t;
                i = r;
                s = n;
              }
              const u = i !== null && i !== void 0 ? i : c.active();
              const l = this.startSpan(e, o, u);
              const g = (0, a.setSpan)(u, l);
              return c.with(g, s, undefined, l);
            }
          }
          t.NoopTracer = NoopTracer;
          function isSpanContext(e) {
            return (
              typeof e === 'object' &&
              typeof e['spanId'] === 'string' &&
              typeof e['traceId'] === 'string' &&
              typeof e['traceFlags'] === 'number'
            );
          }
        },
        124: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.NoopTracerProvider = void 0;
          const n = r(614);
          class NoopTracerProvider {
            getTracer(e, t, r) {
              return new n.NoopTracer();
            }
          }
          t.NoopTracerProvider = NoopTracerProvider;
        },
        125: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.ProxyTracer = void 0;
          const n = r(614);
          const a = new n.NoopTracer();
          class ProxyTracer {
            constructor(e, t, r, n) {
              this._provider = e;
              this.name = t;
              this.version = r;
              this.options = n;
            }
            startSpan(e, t, r) {
              return this._getTracer().startSpan(e, t, r);
            }
            startActiveSpan(e, t, r, n) {
              const a = this._getTracer();
              return Reflect.apply(a.startActiveSpan, a, arguments);
            }
            _getTracer() {
              if (this._delegate) {
                return this._delegate;
              }
              const e = this._provider.getDelegateTracer(
                this.name,
                this.version,
                this.options
              );
              if (!e) {
                return a;
              }
              this._delegate = e;
              return this._delegate;
            }
          }
          t.ProxyTracer = ProxyTracer;
        },
        846: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.ProxyTracerProvider = void 0;
          const n = r(125);
          const a = r(124);
          const o = new a.NoopTracerProvider();
          class ProxyTracerProvider {
            getTracer(e, t, r) {
              var a;
              return (a = this.getDelegateTracer(e, t, r)) !== null && a !== void 0
                ? a
                : new n.ProxyTracer(this, e, t, r);
            }
            getDelegate() {
              var e;
              return (e = this._delegate) !== null && e !== void 0 ? e : o;
            }
            setDelegate(e) {
              this._delegate = e;
            }
            getDelegateTracer(e, t, r) {
              var n;
              return (n = this._delegate) === null || n === void 0
                ? void 0
                : n.getTracer(e, t, r);
            }
          }
          t.ProxyTracerProvider = ProxyTracerProvider;
        },
        996: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.SamplingDecision = void 0;
          var r;
          (function (e) {
            e[(e['NOT_RECORD'] = 0)] = 'NOT_RECORD';
            e[(e['RECORD'] = 1)] = 'RECORD';
            e[(e['RECORD_AND_SAMPLED'] = 2)] = 'RECORD_AND_SAMPLED';
          })((r = t.SamplingDecision || (t.SamplingDecision = {})));
        },
        607: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.getSpanContext =
            t.setSpanContext =
            t.deleteSpan =
            t.setSpan =
            t.getActiveSpan =
            t.getSpan =
              void 0;
          const n = r(780);
          const a = r(403);
          const o = r(491);
          const i = (0, n.createContextKey)('OpenTelemetry Context Key SPAN');
          function getSpan(e) {
            return e.getValue(i) || undefined;
          }
          t.getSpan = getSpan;
          function getActiveSpan() {
            return getSpan(o.ContextAPI.getInstance().active());
          }
          t.getActiveSpan = getActiveSpan;
          function setSpan(e, t) {
            return e.setValue(i, t);
          }
          t.setSpan = setSpan;
          function deleteSpan(e) {
            return e.deleteValue(i);
          }
          t.deleteSpan = deleteSpan;
          function setSpanContext(e, t) {
            return setSpan(e, new a.NonRecordingSpan(t));
          }
          t.setSpanContext = setSpanContext;
          function getSpanContext(e) {
            var t;
            return (t = getSpan(e)) === null || t === void 0 ? void 0 : t.spanContext();
          }
          t.getSpanContext = getSpanContext;
        },
        325: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.TraceStateImpl = void 0;
          const n = r(564);
          const a = 32;
          const o = 512;
          const i = ',';
          const c = '=';
          class TraceStateImpl {
            constructor(e) {
              this._internalState = new Map();
              if (e) this._parse(e);
            }
            set(e, t) {
              const r = this._clone();
              if (r._internalState.has(e)) {
                r._internalState.delete(e);
              }
              r._internalState.set(e, t);
              return r;
            }
            unset(e) {
              const t = this._clone();
              t._internalState.delete(e);
              return t;
            }
            get(e) {
              return this._internalState.get(e);
            }
            serialize() {
              return this._keys()
                .reduce((e, t) => {
                  e.push(t + c + this.get(t));
                  return e;
                }, [])
                .join(i);
            }
            _parse(e) {
              if (e.length > o) return;
              this._internalState = e
                .split(i)
                .reverse()
                .reduce((e, t) => {
                  const r = t.trim();
                  const a = r.indexOf(c);
                  if (a !== -1) {
                    const o = r.slice(0, a);
                    const i = r.slice(a + 1, t.length);
                    if ((0, n.validateKey)(o) && (0, n.validateValue)(i)) {
                      e.set(o, i);
                    } else {
                    }
                  }
                  return e;
                }, new Map());
              if (this._internalState.size > a) {
                this._internalState = new Map(
                  Array.from(this._internalState.entries()).reverse().slice(0, a)
                );
              }
            }
            _keys() {
              return Array.from(this._internalState.keys()).reverse();
            }
            _clone() {
              const e = new TraceStateImpl();
              e._internalState = new Map(this._internalState);
              return e;
            }
          }
          t.TraceStateImpl = TraceStateImpl;
        },
        564: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.validateValue = t.validateKey = void 0;
          const r = '[_0-9a-z-*/]';
          const n = `[a-z]${r}{0,255}`;
          const a = `[a-z0-9]${r}{0,240}@[a-z]${r}{0,13}`;
          const o = new RegExp(`^(?:${n}|${a})$`);
          const i = /^[ -~]{0,255}[!-~]$/;
          const c = /,|=/;
          function validateKey(e) {
            return o.test(e);
          }
          t.validateKey = validateKey;
          function validateValue(e) {
            return i.test(e) && !c.test(e);
          }
          t.validateValue = validateValue;
        },
        98: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.createTraceState = void 0;
          const n = r(325);
          function createTraceState(e) {
            return new n.TraceStateImpl(e);
          }
          t.createTraceState = createTraceState;
        },
        476: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.INVALID_SPAN_CONTEXT = t.INVALID_TRACEID = t.INVALID_SPANID = void 0;
          const n = r(475);
          t.INVALID_SPANID = '0000000000000000';
          t.INVALID_TRACEID = '00000000000000000000000000000000';
          t.INVALID_SPAN_CONTEXT = {
            traceId: t.INVALID_TRACEID,
            spanId: t.INVALID_SPANID,
            traceFlags: n.TraceFlags.NONE,
          };
        },
        357: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.SpanKind = void 0;
          var r;
          (function (e) {
            e[(e['INTERNAL'] = 0)] = 'INTERNAL';
            e[(e['SERVER'] = 1)] = 'SERVER';
            e[(e['CLIENT'] = 2)] = 'CLIENT';
            e[(e['PRODUCER'] = 3)] = 'PRODUCER';
            e[(e['CONSUMER'] = 4)] = 'CONSUMER';
          })((r = t.SpanKind || (t.SpanKind = {})));
        },
        139: (e, t, r) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.wrapSpanContext =
            t.isSpanContextValid =
            t.isValidSpanId =
            t.isValidTraceId =
              void 0;
          const n = r(476);
          const a = r(403);
          const o = /^([0-9a-f]{32})$/i;
          const i = /^[0-9a-f]{16}$/i;
          function isValidTraceId(e) {
            return o.test(e) && e !== n.INVALID_TRACEID;
          }
          t.isValidTraceId = isValidTraceId;
          function isValidSpanId(e) {
            return i.test(e) && e !== n.INVALID_SPANID;
          }
          t.isValidSpanId = isValidSpanId;
          function isSpanContextValid(e) {
            return isValidTraceId(e.traceId) && isValidSpanId(e.spanId);
          }
          t.isSpanContextValid = isSpanContextValid;
          function wrapSpanContext(e) {
            return new a.NonRecordingSpan(e);
          }
          t.wrapSpanContext = wrapSpanContext;
        },
        847: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.SpanStatusCode = void 0;
          var r;
          (function (e) {
            e[(e['UNSET'] = 0)] = 'UNSET';
            e[(e['OK'] = 1)] = 'OK';
            e[(e['ERROR'] = 2)] = 'ERROR';
          })((r = t.SpanStatusCode || (t.SpanStatusCode = {})));
        },
        475: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.TraceFlags = void 0;
          var r;
          (function (e) {
            e[(e['NONE'] = 0)] = 'NONE';
            e[(e['SAMPLED'] = 1)] = 'SAMPLED';
          })((r = t.TraceFlags || (t.TraceFlags = {})));
        },
        521: (e, t) => {
          Object.defineProperty(t, '__esModule', { value: true });
          t.VERSION = void 0;
          t.VERSION = '1.6.0';
        },
      };
      var t = {};
      function __nccwpck_require__(r) {
        var n = t[r];
        if (n !== undefined) {
          return n.exports;
        }
        var a = (t[r] = { exports: {} });
        var o = true;
        try {
          e[r].call(a.exports, a, a.exports, __nccwpck_require__);
          o = false;
        } finally {
          if (o) delete t[r];
        }
        return a.exports;
      }
      if (typeof __nccwpck_require__ !== 'undefined')
        __nccwpck_require__.ab = __dirname + '/';
      var r = {};
      (() => {
        var e = r;
        Object.defineProperty(e, '__esModule', { value: true });
        e.trace =
          e.propagation =
          e.metrics =
          e.diag =
          e.context =
          e.INVALID_SPAN_CONTEXT =
          e.INVALID_TRACEID =
          e.INVALID_SPANID =
          e.isValidSpanId =
          e.isValidTraceId =
          e.isSpanContextValid =
          e.createTraceState =
          e.TraceFlags =
          e.SpanStatusCode =
          e.SpanKind =
          e.SamplingDecision =
          e.ProxyTracerProvider =
          e.ProxyTracer =
          e.defaultTextMapSetter =
          e.defaultTextMapGetter =
          e.ValueType =
          e.createNoopMeter =
          e.DiagLogLevel =
          e.DiagConsoleLogger =
          e.ROOT_CONTEXT =
          e.createContextKey =
          e.baggageEntryMetadataFromString =
            void 0;
        var t = __nccwpck_require__(369);
        Object.defineProperty(e, 'baggageEntryMetadataFromString', {
          enumerable: true,
          get: function () {
            return t.baggageEntryMetadataFromString;
          },
        });
        var n = __nccwpck_require__(780);
        Object.defineProperty(e, 'createContextKey', {
          enumerable: true,
          get: function () {
            return n.createContextKey;
          },
        });
        Object.defineProperty(e, 'ROOT_CONTEXT', {
          enumerable: true,
          get: function () {
            return n.ROOT_CONTEXT;
          },
        });
        var a = __nccwpck_require__(972);
        Object.defineProperty(e, 'DiagConsoleLogger', {
          enumerable: true,
          get: function () {
            return a.DiagConsoleLogger;
          },
        });
        var o = __nccwpck_require__(957);
        Object.defineProperty(e, 'DiagLogLevel', {
          enumerable: true,
          get: function () {
            return o.DiagLogLevel;
          },
        });
        var i = __nccwpck_require__(102);
        Object.defineProperty(e, 'createNoopMeter', {
          enumerable: true,
          get: function () {
            return i.createNoopMeter;
          },
        });
        var c = __nccwpck_require__(901);
        Object.defineProperty(e, 'ValueType', {
          enumerable: true,
          get: function () {
            return c.ValueType;
          },
        });
        var s = __nccwpck_require__(194);
        Object.defineProperty(e, 'defaultTextMapGetter', {
          enumerable: true,
          get: function () {
            return s.defaultTextMapGetter;
          },
        });
        Object.defineProperty(e, 'defaultTextMapSetter', {
          enumerable: true,
          get: function () {
            return s.defaultTextMapSetter;
          },
        });
        var u = __nccwpck_require__(125);
        Object.defineProperty(e, 'ProxyTracer', {
          enumerable: true,
          get: function () {
            return u.ProxyTracer;
          },
        });
        var l = __nccwpck_require__(846);
        Object.defineProperty(e, 'ProxyTracerProvider', {
          enumerable: true,
          get: function () {
            return l.ProxyTracerProvider;
          },
        });
        var g = __nccwpck_require__(996);
        Object.defineProperty(e, 'SamplingDecision', {
          enumerable: true,
          get: function () {
            return g.SamplingDecision;
          },
        });
        var p = __nccwpck_require__(357);
        Object.defineProperty(e, 'SpanKind', {
          enumerable: true,
          get: function () {
            return p.SpanKind;
          },
        });
        var d = __nccwpck_require__(847);
        Object.defineProperty(e, 'SpanStatusCode', {
          enumerable: true,
          get: function () {
            return d.SpanStatusCode;
          },
        });
        var _ = __nccwpck_require__(475);
        Object.defineProperty(e, 'TraceFlags', {
          enumerable: true,
          get: function () {
            return _.TraceFlags;
          },
        });
        var f = __nccwpck_require__(98);
        Object.defineProperty(e, 'createTraceState', {
          enumerable: true,
          get: function () {
            return f.createTraceState;
          },
        });
        var b = __nccwpck_require__(139);
        Object.defineProperty(e, 'isSpanContextValid', {
          enumerable: true,
          get: function () {
            return b.isSpanContextValid;
          },
        });
        Object.defineProperty(e, 'isValidTraceId', {
          enumerable: true,
          get: function () {
            return b.isValidTraceId;
          },
        });
        Object.defineProperty(e, 'isValidSpanId', {
          enumerable: true,
          get: function () {
            return b.isValidSpanId;
          },
        });
        var v = __nccwpck_require__(476);
        Object.defineProperty(e, 'INVALID_SPANID', {
          enumerable: true,
          get: function () {
            return v.INVALID_SPANID;
          },
        });
        Object.defineProperty(e, 'INVALID_TRACEID', {
          enumerable: true,
          get: function () {
            return v.INVALID_TRACEID;
          },
        });
        Object.defineProperty(e, 'INVALID_SPAN_CONTEXT', {
          enumerable: true,
          get: function () {
            return v.INVALID_SPAN_CONTEXT;
          },
        });
        const O = __nccwpck_require__(67);
        Object.defineProperty(e, 'context', {
          enumerable: true,
          get: function () {
            return O.context;
          },
        });
        const P = __nccwpck_require__(506);
        Object.defineProperty(e, 'diag', {
          enumerable: true,
          get: function () {
            return P.diag;
          },
        });
        const N = __nccwpck_require__(886);
        Object.defineProperty(e, 'metrics', {
          enumerable: true,
          get: function () {
            return N.metrics;
          },
        });
        const S = __nccwpck_require__(939);
        Object.defineProperty(e, 'propagation', {
          enumerable: true,
          get: function () {
            return S.propagation;
          },
        });
        const C = __nccwpck_require__(845);
        Object.defineProperty(e, 'trace', {
          enumerable: true,
          get: function () {
            return C.trace;
          },
        });
        e['default'] = {
          context: O.context,
          diag: P.diag,
          metrics: N.metrics,
          propagation: S.propagation,
          trace: C.trace,
        };
      })();
      module.exports = r;
    })();
  },
  5737: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';
    /**
     * @license React react-server-dom-webpack-client.edge.development.js
     *
     *   Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     *   This source code is licensed under the MIT license found in the LICENSE file in the
     *   root directory of this source tree.
     */
    true &&
      (function () {
        function _defineProperty(obj, key, value) {
          a: if ('object' == typeof key && key) {
            var e = key[Symbol.toPrimitive];
            if (void 0 !== e) {
              key = e.call(key, 'string');
              if ('object' != typeof key) break a;
              throw new TypeError('@@toPrimitive must return a primitive value.');
            }
            key = String(key);
          }
          key = 'symbol' == typeof key ? key : key + '';
          key in obj
            ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (obj[key] = value);
          return obj;
        }
        function resolveClientReference(bundlerConfig, metadata) {
          if (bundlerConfig) {
            var moduleExports = bundlerConfig[metadata[0]];
            if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))
              moduleExports = bundlerConfig.name;
            else {
              bundlerConfig = moduleExports && moduleExports['*'];
              if (!bundlerConfig)
                throw Error(
                  'Could not find the module "' +
                    metadata[0] +
                    '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'
                );
              moduleExports = metadata[2];
            }
            return 4 === metadata.length
              ? [bundlerConfig.id, bundlerConfig.chunks, moduleExports, 1]
              : [bundlerConfig.id, bundlerConfig.chunks, moduleExports];
          }
          return metadata;
        }
        function resolveServerReference(bundlerConfig, id) {
          var name = '',
            resolvedModuleData = bundlerConfig[id];
          if (resolvedModuleData) name = resolvedModuleData.name;
          else {
            var idx = id.lastIndexOf('#');
            -1 !== idx &&
              ((name = id.slice(idx + 1)),
              (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
            if (!resolvedModuleData)
              throw Error(
                'Could not find the module "' +
                  id +
                  '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
              );
          }
          return resolvedModuleData.async
            ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]
            : [resolvedModuleData.id, resolvedModuleData.chunks, name];
        }
        function requireAsyncModule(id) {
          var promise = globalThis.__next_require__(id);
          if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
            return null;
          promise.then(
            function (value) {
              promise.status = 'fulfilled';
              promise.value = value;
            },
            function (reason) {
              promise.status = 'rejected';
              promise.reason = reason;
            }
          );
          return promise;
        }
        function ignoreReject() {}
        function preloadModule(metadata) {
          for (var chunks = metadata[1], promises = [], i = 0; i < chunks.length; ) {
            var chunkId = chunks[i++];
            chunks[i++];
            var entry = chunkCache.get(chunkId);
            if (void 0 === entry) {
              entry = __webpack_require__.e(chunkId);
              promises.push(entry);
              var resolve = chunkCache.set.bind(chunkCache, chunkId, null);
              entry.then(resolve, ignoreReject);
              chunkCache.set(chunkId, entry);
            } else null !== entry && promises.push(entry);
          }
          return 4 === metadata.length
            ? 0 === promises.length
              ? requireAsyncModule(metadata[0])
              : Promise.all(promises).then(function () {
                  return requireAsyncModule(metadata[0]);
                })
            : 0 < promises.length
              ? Promise.all(promises)
              : null;
        }
        function requireModule(metadata) {
          var moduleExports = globalThis.__next_require__(metadata[0]);
          if (4 === metadata.length && 'function' === typeof moduleExports.then)
            if ('fulfilled' === moduleExports.status) moduleExports = moduleExports.value;
            else throw moduleExports.reason;
          return '*' === metadata[2]
            ? moduleExports
            : '' === metadata[2]
              ? moduleExports.__esModule
                ? moduleExports.default
                : moduleExports
              : moduleExports[metadata[2]];
        }
        function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {
          if (null !== moduleLoading)
            for (var i = 1; i < chunks.length; i += 2) {
              var nonce = nonce$jscomp$0,
                JSCompiler_temp_const = ReactDOMSharedInternals.d,
                JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.X,
                JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];
              var JSCompiler_inline_result = moduleLoading.crossOrigin;
              JSCompiler_inline_result =
                'string' === typeof JSCompiler_inline_result
                  ? 'use-credentials' === JSCompiler_inline_result
                    ? JSCompiler_inline_result
                    : ''
                  : void 0;
              JSCompiler_temp_const$jscomp$0.call(
                JSCompiler_temp_const,
                JSCompiler_temp_const$jscomp$1,
                {
                  crossOrigin: JSCompiler_inline_result,
                  nonce: nonce,
                }
              );
            }
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
          maybeIterable =
            (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
            maybeIterable['@@iterator'];
          return 'function' === typeof maybeIterable ? maybeIterable : null;
        }
        function isObjectPrototype(object) {
          if (!object) return !1;
          var ObjectPrototype = Object.prototype;
          if (object === ObjectPrototype) return !0;
          if (getPrototypeOf(object)) return !1;
          object = Object.getOwnPropertyNames(object);
          for (var i = 0; i < object.length; i++)
            if (!(object[i] in ObjectPrototype)) return !1;
          return !0;
        }
        function isSimpleObject(object) {
          if (!isObjectPrototype(getPrototypeOf(object))) return !1;
          for (
            var names = Object.getOwnPropertyNames(object), i = 0;
            i < names.length;
            i++
          ) {
            var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
            if (
              !descriptor ||
              (!descriptor.enumerable &&
                (('key' !== names[i] && 'ref' !== names[i]) ||
                  'function' !== typeof descriptor.get))
            )
              return !1;
          }
          return !0;
        }
        function objectName(object) {
          return Object.prototype.toString
            .call(object)
            .replace(/^\[object (.*)\]$/, function (m, p0) {
              return p0;
            });
        }
        function describeKeyForErrorMessage(key) {
          var encodedKey = JSON.stringify(key);
          return '"' + key + '"' === encodedKey ? key : encodedKey;
        }
        function describeValueForErrorMessage(value) {
          switch (typeof value) {
            case 'string':
              return JSON.stringify(
                10 >= value.length ? value : value.slice(0, 10) + '...'
              );
            case 'object':
              if (isArrayImpl(value)) return '[...]';
              if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
                return 'client';
              value = objectName(value);
              return 'Object' === value ? '{...}' : value;
            case 'function':
              return value.$$typeof === CLIENT_REFERENCE_TAG
                ? 'client'
                : (value = value.displayName || value.name)
                  ? 'function ' + value
                  : 'function';
            default:
              return String(value);
          }
        }
        function describeElementType(type) {
          if ('string' === typeof type) return type;
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
              return 'SuspenseList';
          }
          if ('object' === typeof type)
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeElementType(type.render);
              case REACT_MEMO_TYPE:
                return describeElementType(type.type);
              case REACT_LAZY_TYPE:
                var payload = type._payload;
                type = type._init;
                try {
                  return describeElementType(type(payload));
                } catch (x) {}
            }
          return '';
        }
        function describeObjectForErrorMessage(objectOrArray, expandedName) {
          var objKind = objectName(objectOrArray);
          if ('Object' !== objKind && 'Array' !== objKind) return objKind;
          var start = -1,
            length = 0;
          if (isArrayImpl(objectOrArray))
            if (jsxChildrenParents.has(objectOrArray)) {
              var type = jsxChildrenParents.get(objectOrArray);
              objKind = '<' + describeElementType(type) + '>';
              for (var i = 0; i < objectOrArray.length; i++) {
                var value = objectOrArray[i];
                value =
                  'string' === typeof value
                    ? value
                    : 'object' === typeof value && null !== value
                      ? '{' + describeObjectForErrorMessage(value) + '}'
                      : '{' + describeValueForErrorMessage(value) + '}';
                '' + i === expandedName
                  ? ((start = objKind.length),
                    (length = value.length),
                    (objKind += value))
                  : (objKind =
                      15 > value.length && 40 > objKind.length + value.length
                        ? objKind + value
                        : objKind + '{...}');
              }
              objKind += '</' + describeElementType(type) + '>';
            } else {
              objKind = '[';
              for (type = 0; type < objectOrArray.length; type++)
                0 < type && (objKind += ', '),
                  (i = objectOrArray[type]),
                  (i =
                    'object' === typeof i && null !== i
                      ? describeObjectForErrorMessage(i)
                      : describeValueForErrorMessage(i)),
                  '' + type === expandedName
                    ? ((start = objKind.length), (length = i.length), (objKind += i))
                    : (objKind =
                        10 > i.length && 40 > objKind.length + i.length
                          ? objKind + i
                          : objKind + '...');
              objKind += ']';
            }
          else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
            objKind = '<' + describeElementType(objectOrArray.type) + '/>';
          else {
            if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
            if (jsxPropsParents.has(objectOrArray)) {
              objKind = jsxPropsParents.get(objectOrArray);
              objKind = '<' + (describeElementType(objKind) || '...');
              type = Object.keys(objectOrArray);
              for (i = 0; i < type.length; i++) {
                objKind += ' ';
                value = type[i];
                objKind += describeKeyForErrorMessage(value) + '=';
                var _value2 = objectOrArray[value];
                var _substr2 =
                  value === expandedName &&
                  'object' === typeof _value2 &&
                  null !== _value2
                    ? describeObjectForErrorMessage(_value2)
                    : describeValueForErrorMessage(_value2);
                'string' !== typeof _value2 && (_substr2 = '{' + _substr2 + '}');
                value === expandedName
                  ? ((start = objKind.length),
                    (length = _substr2.length),
                    (objKind += _substr2))
                  : (objKind =
                      10 > _substr2.length && 40 > objKind.length + _substr2.length
                        ? objKind + _substr2
                        : objKind + '...');
              }
              objKind += '>';
            } else {
              objKind = '{';
              type = Object.keys(objectOrArray);
              for (i = 0; i < type.length; i++)
                0 < i && (objKind += ', '),
                  (value = type[i]),
                  (objKind += describeKeyForErrorMessage(value) + ': '),
                  (_value2 = objectOrArray[value]),
                  (_value2 =
                    'object' === typeof _value2 && null !== _value2
                      ? describeObjectForErrorMessage(_value2)
                      : describeValueForErrorMessage(_value2)),
                  value === expandedName
                    ? ((start = objKind.length),
                      (length = _value2.length),
                      (objKind += _value2))
                    : (objKind =
                        10 > _value2.length && 40 > objKind.length + _value2.length
                          ? objKind + _value2
                          : objKind + '...');
              objKind += '}';
            }
          }
          return void 0 === expandedName
            ? objKind
            : -1 < start && 0 < length
              ? ((objectOrArray = ' '.repeat(start) + '^'.repeat(length)),
                '\n  ' + objKind + '\n  ' + objectOrArray)
              : '\n  ' + objKind;
        }
        function serializeNumber(number) {
          return Number.isFinite(number)
            ? 0 === number && -Infinity === 1 / number
              ? '$-0'
              : number
            : Infinity === number
              ? '$Infinity'
              : -Infinity === number
                ? '$-Infinity'
                : '$NaN';
        }
        function processReply(
          root,
          formFieldPrefix,
          temporaryReferences,
          resolve,
          reject
        ) {
          function serializeTypedArray(tag, typedArray) {
            typedArray = new Blob([
              new Uint8Array(
                typedArray.buffer,
                typedArray.byteOffset,
                typedArray.byteLength
              ),
            ]);
            var blobId = nextPartId++;
            null === formData && (formData = new FormData());
            formData.append(formFieldPrefix + blobId, typedArray);
            return '$' + tag + blobId.toString(16);
          }
          function serializeBinaryReader(reader) {
            function progress(entry) {
              entry.done
                ? ((entry = nextPartId++),
                  data.append(formFieldPrefix + entry, new Blob(buffer)),
                  data.append(
                    formFieldPrefix + streamId,
                    '"$o' + entry.toString(16) + '"'
                  ),
                  data.append(formFieldPrefix + streamId, 'C'),
                  pendingParts--,
                  0 === pendingParts && resolve(data))
                : (buffer.push(entry.value),
                  reader.read(new Uint8Array(1024)).then(progress, reject));
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++,
              buffer = [];
            reader.read(new Uint8Array(1024)).then(progress, reject);
            return '$r' + streamId.toString(16);
          }
          function serializeReader(reader) {
            function progress(entry) {
              if (entry.done)
                data.append(formFieldPrefix + streamId, 'C'),
                  pendingParts--,
                  0 === pendingParts && resolve(data);
              else
                try {
                  var partJSON = JSON.stringify(entry.value, resolveToJSON);
                  data.append(formFieldPrefix + streamId, partJSON);
                  reader.read().then(progress, reject);
                } catch (x) {
                  reject(x);
                }
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++;
            reader.read().then(progress, reject);
            return '$R' + streamId.toString(16);
          }
          function serializeReadableStream(stream) {
            try {
              var binaryReader = stream.getReader({
                mode: 'byob',
              });
            } catch (x) {
              return serializeReader(stream.getReader());
            }
            return serializeBinaryReader(binaryReader);
          }
          function serializeAsyncIterable(iterable, iterator) {
            function progress(entry) {
              if (entry.done) {
                if (void 0 === entry.value) data.append(formFieldPrefix + streamId, 'C');
                else
                  try {
                    var partJSON = JSON.stringify(entry.value, resolveToJSON);
                    data.append(formFieldPrefix + streamId, 'C' + partJSON);
                  } catch (x) {
                    reject(x);
                    return;
                  }
                pendingParts--;
                0 === pendingParts && resolve(data);
              } else
                try {
                  var _partJSON = JSON.stringify(entry.value, resolveToJSON);
                  data.append(formFieldPrefix + streamId, _partJSON);
                  iterator.next().then(progress, reject);
                } catch (x$0) {
                  reject(x$0);
                }
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++;
            iterable = iterable === iterator;
            iterator.next().then(progress, reject);
            return '$' + (iterable ? 'x' : 'X') + streamId.toString(16);
          }
          function resolveToJSON(key, value) {
            var originalValue = this[key];
            'object' !== typeof originalValue ||
              originalValue === value ||
              originalValue instanceof Date ||
              ('Object' !== objectName(originalValue)
                ? console.error(
                    'Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s',
                    objectName(originalValue),
                    describeObjectForErrorMessage(this, key)
                  )
                : console.error(
                    'Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s',
                    describeObjectForErrorMessage(this, key)
                  ));
            if (null === value) return null;
            if ('object' === typeof value) {
              switch (value.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  if (void 0 !== temporaryReferences && -1 === key.indexOf(':')) {
                    var parentReference = writtenObjects.get(this);
                    if (void 0 !== parentReference)
                      return (
                        temporaryReferences.set(parentReference + ':' + key, value), '$T'
                      );
                  }
                  throw Error(
                    'React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.' +
                      describeObjectForErrorMessage(this, key)
                  );
                case REACT_LAZY_TYPE:
                  originalValue = value._payload;
                  var init = value._init;
                  null === formData && (formData = new FormData());
                  pendingParts++;
                  try {
                    parentReference = init(originalValue);
                    var lazyId = nextPartId++,
                      partJSON = serializeModel(parentReference, lazyId);
                    formData.append(formFieldPrefix + lazyId, partJSON);
                    return '$' + lazyId.toString(16);
                  } catch (x) {
                    if (
                      'object' === typeof x &&
                      null !== x &&
                      'function' === typeof x.then
                    ) {
                      pendingParts++;
                      var _lazyId = nextPartId++;
                      parentReference = function () {
                        try {
                          var _partJSON2 = serializeModel(value, _lazyId),
                            _data = formData;
                          _data.append(formFieldPrefix + _lazyId, _partJSON2);
                          pendingParts--;
                          0 === pendingParts && resolve(_data);
                        } catch (reason) {
                          reject(reason);
                        }
                      };
                      x.then(parentReference, parentReference);
                      return '$' + _lazyId.toString(16);
                    }
                    reject(x);
                    return null;
                  } finally {
                    pendingParts--;
                  }
              }
              if ('function' === typeof value.then) {
                null === formData && (formData = new FormData());
                pendingParts++;
                var promiseId = nextPartId++;
                value.then(function (partValue) {
                  try {
                    var _partJSON3 = serializeModel(partValue, promiseId);
                    partValue = formData;
                    partValue.append(formFieldPrefix + promiseId, _partJSON3);
                    pendingParts--;
                    0 === pendingParts && resolve(partValue);
                  } catch (reason) {
                    reject(reason);
                  }
                }, reject);
                return '$@' + promiseId.toString(16);
              }
              parentReference = writtenObjects.get(value);
              if (void 0 !== parentReference)
                if (modelRoot === value) modelRoot = null;
                else return parentReference;
              else
                -1 === key.indexOf(':') &&
                  ((parentReference = writtenObjects.get(this)),
                  void 0 !== parentReference &&
                    ((parentReference = parentReference + ':' + key),
                    writtenObjects.set(value, parentReference),
                    void 0 !== temporaryReferences &&
                      temporaryReferences.set(parentReference, value)));
              if (isArrayImpl(value)) return value;
              if (value instanceof FormData) {
                null === formData && (formData = new FormData());
                var _data3 = formData;
                key = nextPartId++;
                var prefix = formFieldPrefix + key + '_';
                value.forEach(function (originalValue, originalKey) {
                  _data3.append(prefix + originalKey, originalValue);
                });
                return '$K' + key.toString(16);
              }
              if (value instanceof Map)
                return (
                  (key = nextPartId++),
                  (parentReference = serializeModel(Array.from(value), key)),
                  null === formData && (formData = new FormData()),
                  formData.append(formFieldPrefix + key, parentReference),
                  '$Q' + key.toString(16)
                );
              if (value instanceof Set)
                return (
                  (key = nextPartId++),
                  (parentReference = serializeModel(Array.from(value), key)),
                  null === formData && (formData = new FormData()),
                  formData.append(formFieldPrefix + key, parentReference),
                  '$W' + key.toString(16)
                );
              if (value instanceof ArrayBuffer)
                return (
                  (key = new Blob([value])),
                  (parentReference = nextPartId++),
                  null === formData && (formData = new FormData()),
                  formData.append(formFieldPrefix + parentReference, key),
                  '$A' + parentReference.toString(16)
                );
              if (value instanceof Int8Array) return serializeTypedArray('O', value);
              if (value instanceof Uint8Array) return serializeTypedArray('o', value);
              if (value instanceof Uint8ClampedArray)
                return serializeTypedArray('U', value);
              if (value instanceof Int16Array) return serializeTypedArray('S', value);
              if (value instanceof Uint16Array) return serializeTypedArray('s', value);
              if (value instanceof Int32Array) return serializeTypedArray('L', value);
              if (value instanceof Uint32Array) return serializeTypedArray('l', value);
              if (value instanceof Float32Array) return serializeTypedArray('G', value);
              if (value instanceof Float64Array) return serializeTypedArray('g', value);
              if (value instanceof BigInt64Array) return serializeTypedArray('M', value);
              if (value instanceof BigUint64Array) return serializeTypedArray('m', value);
              if (value instanceof DataView) return serializeTypedArray('V', value);
              if ('function' === typeof Blob && value instanceof Blob)
                return (
                  null === formData && (formData = new FormData()),
                  (key = nextPartId++),
                  formData.append(formFieldPrefix + key, value),
                  '$B' + key.toString(16)
                );
              if ((parentReference = getIteratorFn(value)))
                return (
                  (parentReference = parentReference.call(value)),
                  parentReference === value
                    ? ((key = nextPartId++),
                      (parentReference = serializeModel(
                        Array.from(parentReference),
                        key
                      )),
                      null === formData && (formData = new FormData()),
                      formData.append(formFieldPrefix + key, parentReference),
                      '$i' + key.toString(16))
                    : Array.from(parentReference)
                );
              if ('function' === typeof ReadableStream && value instanceof ReadableStream)
                return serializeReadableStream(value);
              parentReference = value[ASYNC_ITERATOR];
              if ('function' === typeof parentReference)
                return serializeAsyncIterable(value, parentReference.call(value));
              parentReference = getPrototypeOf(value);
              if (
                parentReference !== ObjectPrototype &&
                (null === parentReference || null !== getPrototypeOf(parentReference))
              ) {
                if (void 0 === temporaryReferences)
                  throw Error(
                    'Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.' +
                      describeObjectForErrorMessage(this, key)
                  );
                return '$T';
              }
              value.$$typeof === REACT_CONTEXT_TYPE
                ? console.error(
                    'React Context Providers cannot be passed to Server Functions from the Client.%s',
                    describeObjectForErrorMessage(this, key)
                  )
                : 'Object' !== objectName(value)
                  ? console.error(
                      'Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s',
                      objectName(value),
                      describeObjectForErrorMessage(this, key)
                    )
                  : isSimpleObject(value)
                    ? Object.getOwnPropertySymbols &&
                      ((parentReference = Object.getOwnPropertySymbols(value)),
                      0 < parentReference.length &&
                        console.error(
                          'Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s',
                          parentReference[0].description,
                          describeObjectForErrorMessage(this, key)
                        ))
                    : console.error(
                        'Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s',
                        describeObjectForErrorMessage(this, key)
                      );
              return value;
            }
            if ('string' === typeof value) {
              if ('Z' === value[value.length - 1] && this[key] instanceof Date)
                return '$D' + value;
              key = '$' === value[0] ? '$' + value : value;
              return key;
            }
            if ('boolean' === typeof value) return value;
            if ('number' === typeof value) return serializeNumber(value);
            if ('undefined' === typeof value) return '$undefined';
            if ('function' === typeof value) {
              parentReference = knownServerReferences.get(value);
              if (void 0 !== parentReference)
                return (
                  (key = JSON.stringify(
                    {
                      id: parentReference.id,
                      bound: parentReference.bound,
                    },
                    resolveToJSON
                  )),
                  null === formData && (formData = new FormData()),
                  (parentReference = nextPartId++),
                  formData.set(formFieldPrefix + parentReference, key),
                  '$F' + parentReference.toString(16)
                );
              if (
                void 0 !== temporaryReferences &&
                -1 === key.indexOf(':') &&
                ((parentReference = writtenObjects.get(this)), void 0 !== parentReference)
              )
                return temporaryReferences.set(parentReference + ':' + key, value), '$T';
              throw Error(
                'Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.'
              );
            }
            if ('symbol' === typeof value) {
              if (
                void 0 !== temporaryReferences &&
                -1 === key.indexOf(':') &&
                ((parentReference = writtenObjects.get(this)), void 0 !== parentReference)
              )
                return temporaryReferences.set(parentReference + ':' + key, value), '$T';
              throw Error(
                'Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.' +
                  describeObjectForErrorMessage(this, key)
              );
            }
            if ('bigint' === typeof value) return '$n' + value.toString(10);
            throw Error(
              'Type ' +
                typeof value +
                ' is not supported as an argument to a Server Function.'
            );
          }
          function serializeModel(model, id) {
            'object' === typeof model &&
              null !== model &&
              ((id = '$' + id.toString(16)),
              writtenObjects.set(model, id),
              void 0 !== temporaryReferences && temporaryReferences.set(id, model));
            modelRoot = model;
            return JSON.stringify(model, resolveToJSON);
          }
          var nextPartId = 1,
            pendingParts = 0,
            formData = null,
            writtenObjects = new WeakMap(),
            modelRoot = root,
            json = serializeModel(root, 0);
          null === formData
            ? resolve(json)
            : (formData.set(formFieldPrefix + '0', json),
              0 === pendingParts && resolve(formData));
          return function () {
            0 < pendingParts &&
              ((pendingParts = 0), null === formData ? resolve(json) : resolve(formData));
          };
        }
        function encodeFormData(reference) {
          var resolve,
            reject,
            thenable = new Promise(function (res, rej) {
              resolve = res;
              reject = rej;
            });
          processReply(
            reference,
            '',
            void 0,
            function (body) {
              if ('string' === typeof body) {
                var data = new FormData();
                data.append('0', body);
                body = data;
              }
              thenable.status = 'fulfilled';
              thenable.value = body;
              resolve(body);
            },
            function (e) {
              thenable.status = 'rejected';
              thenable.reason = e;
              reject(e);
            }
          );
          return thenable;
        }
        function defaultEncodeFormAction(identifierPrefix) {
          var referenceClosure = knownServerReferences.get(this);
          if (!referenceClosure)
            throw Error(
              'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.'
            );
          var data = null;
          if (null !== referenceClosure.bound) {
            data = boundCache.get(referenceClosure);
            data ||
              ((data = encodeFormData({
                id: referenceClosure.id,
                bound: referenceClosure.bound,
              })),
              boundCache.set(referenceClosure, data));
            if ('rejected' === data.status) throw data.reason;
            if ('fulfilled' !== data.status) throw data;
            referenceClosure = data.value;
            var prefixedData = new FormData();
            referenceClosure.forEach(function (value, key) {
              prefixedData.append('$ACTION_' + identifierPrefix + ':' + key, value);
            });
            data = prefixedData;
            referenceClosure = '$ACTION_REF_' + identifierPrefix;
          } else referenceClosure = '$ACTION_ID_' + referenceClosure.id;
          return {
            name: referenceClosure,
            method: 'POST',
            encType: 'multipart/form-data',
            data: data,
          };
        }
        function isSignatureEqual(referenceId, numberOfBoundArgs) {
          var referenceClosure = knownServerReferences.get(this);
          if (!referenceClosure)
            throw Error(
              'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.'
            );
          if (referenceClosure.id !== referenceId) return !1;
          var boundPromise = referenceClosure.bound;
          if (null === boundPromise) return 0 === numberOfBoundArgs;
          switch (boundPromise.status) {
            case 'fulfilled':
              return boundPromise.value.length === numberOfBoundArgs;
            case 'pending':
              throw boundPromise;
            case 'rejected':
              throw boundPromise.reason;
            default:
              throw (
                ('string' !== typeof boundPromise.status &&
                  ((boundPromise.status = 'pending'),
                  boundPromise.then(
                    function (boundArgs) {
                      boundPromise.status = 'fulfilled';
                      boundPromise.value = boundArgs;
                    },
                    function (error) {
                      boundPromise.status = 'rejected';
                      boundPromise.reason = error;
                    }
                  )),
                boundPromise)
              );
          }
        }
        function createFakeServerFunction(
          name,
          filename,
          sourceMap,
          line,
          col,
          environmentName,
          innerFunction
        ) {
          name || (name = '<anonymous>');
          var encodedName = JSON.stringify(name);
          1 >= line
            ? ((line = encodedName.length + 7),
              (col =
                's=>({' +
                encodedName +
                ' '.repeat(col < line ? 0 : col - line) +
                ':(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */'))
            : (col =
                '/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */' +
                '\n'.repeat(line - 2) +
                'server=>({' +
                encodedName +
                ':\n' +
                ' '.repeat(1 > col ? 0 : col - 1) +
                '(...args) => server(...args)})');
          filename.startsWith('/') && (filename = 'file://' + filename);
          sourceMap
            ? ((col +=
                '\n//# sourceURL=rsc://React/' +
                encodeURIComponent(environmentName) +
                '/' +
                filename +
                '?s' +
                fakeServerFunctionIdx++),
              (col += '\n//# sourceMappingURL=' + sourceMap))
            : filename && (col += '\n//# sourceURL=' + filename);
          try {
            return (0, eval)(col)(innerFunction)[name];
          } catch (x) {
            return innerFunction;
          }
        }
        function registerBoundServerReference(reference, id, bound, encodeFormAction) {
          knownServerReferences.has(reference) ||
            (knownServerReferences.set(reference, {
              id: id,
              originalBind: reference.bind,
              bound: bound,
            }),
            Object.defineProperties(reference, {
              $$FORM_ACTION: {
                value:
                  void 0 === encodeFormAction
                    ? defaultEncodeFormAction
                    : function () {
                        var referenceClosure = knownServerReferences.get(this);
                        if (!referenceClosure)
                          throw Error(
                            'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.'
                          );
                        var boundPromise = referenceClosure.bound;
                        null === boundPromise && (boundPromise = Promise.resolve([]));
                        return encodeFormAction(referenceClosure.id, boundPromise);
                      },
              },
              $$IS_SIGNATURE_EQUAL: {
                value: isSignatureEqual,
              },
              bind: {
                value: bind,
              },
            }));
        }
        function bind() {
          var referenceClosure = knownServerReferences.get(this);
          if (!referenceClosure) return FunctionBind.apply(this, arguments);
          var newFn = referenceClosure.originalBind.apply(this, arguments);
          null != arguments[0] &&
            console.error(
              'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().'
            );
          var args = ArraySlice.call(arguments, 1),
            boundPromise = null;
          boundPromise =
            null !== referenceClosure.bound
              ? Promise.resolve(referenceClosure.bound).then(function (boundArgs) {
                  return boundArgs.concat(args);
                })
              : Promise.resolve(args);
          knownServerReferences.set(newFn, {
            id: referenceClosure.id,
            originalBind: newFn.bind,
            bound: boundPromise,
          });
          Object.defineProperties(newFn, {
            $$FORM_ACTION: {
              value: this.$$FORM_ACTION,
            },
            $$IS_SIGNATURE_EQUAL: {
              value: isSignatureEqual,
            },
            bind: {
              value: bind,
            },
          });
          return newFn;
        }
        function createBoundServerReference(
          metaData,
          callServer,
          encodeFormAction,
          findSourceMapURL
        ) {
          function action() {
            var args = Array.prototype.slice.call(arguments);
            return bound
              ? 'fulfilled' === bound.status
                ? callServer(id, bound.value.concat(args))
                : Promise.resolve(bound).then(function (boundArgs) {
                    return callServer(id, boundArgs.concat(args));
                  })
              : callServer(id, args);
          }
          var id = metaData.id,
            bound = metaData.bound,
            location = metaData.location;
          if (location) {
            var functionName = metaData.name || '',
              filename = location[1],
              line = location[2];
            location = location[3];
            metaData = metaData.env || 'Server';
            findSourceMapURL =
              null == findSourceMapURL ? null : findSourceMapURL(filename, metaData);
            action = createFakeServerFunction(
              functionName,
              filename,
              findSourceMapURL,
              line,
              location,
              metaData,
              action
            );
          }
          registerBoundServerReference(action, id, bound, encodeFormAction);
          return action;
        }
        function parseStackLocation(error) {
          error = error.stack;
          error.startsWith('Error: react-stack-top-frame\n') && (error = error.slice(29));
          var endOfFirst = error.indexOf('\n');
          if (-1 !== endOfFirst) {
            var endOfSecond = error.indexOf('\n', endOfFirst + 1);
            endOfFirst =
              -1 === endOfSecond
                ? error.slice(endOfFirst + 1)
                : error.slice(endOfFirst + 1, endOfSecond);
          } else endOfFirst = error;
          error = v8FrameRegExp.exec(endOfFirst);
          if (!error && ((error = jscSpiderMonkeyFrameRegExp.exec(endOfFirst)), !error))
            return null;
          endOfFirst = error[1] || '';
          '<anonymous>' === endOfFirst && (endOfFirst = '');
          endOfSecond = error[2] || error[5] || '';
          '<anonymous>' === endOfSecond && (endOfSecond = '');
          return [
            endOfFirst,
            endOfSecond,
            +(error[3] || error[6]),
            +(error[4] || error[7]),
          ];
        }
        function createServerReference$1(
          id,
          callServer,
          encodeFormAction,
          findSourceMapURL,
          functionName
        ) {
          function action() {
            var args = Array.prototype.slice.call(arguments);
            return callServer(id, args);
          }
          var location = parseStackLocation(Error('react-stack-top-frame'));
          if (null !== location) {
            var filename = location[1],
              line = location[2];
            location = location[3];
            findSourceMapURL =
              null == findSourceMapURL ? null : findSourceMapURL(filename, 'Client');
            action = createFakeServerFunction(
              functionName || '',
              filename,
              findSourceMapURL,
              line,
              location,
              'Client',
              action
            );
          }
          registerBoundServerReference(action, id, null, encodeFormAction);
          return action;
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ('function' === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE
              ? null
              : type.displayName || type.name || null;
          if ('string' === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return 'Fragment';
            case REACT_PROFILER_TYPE:
              return 'Profiler';
            case REACT_STRICT_MODE_TYPE:
              return 'StrictMode';
            case REACT_SUSPENSE_TYPE:
              return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
              return 'SuspenseList';
            case REACT_ACTIVITY_TYPE:
              return 'Activity';
          }
          if ('object' === typeof type)
            switch (
              ('number' === typeof type.tag &&
                console.error(
                  'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
                ),
              type.$$typeof)
            ) {
              case REACT_PORTAL_TYPE:
                return 'Portal';
              case REACT_CONTEXT_TYPE:
                return (type.displayName || 'Context') + '.Provider';
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || 'Context') + '.Consumer';
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type ||
                  ((type = innerType.displayName || innerType.name || ''),
                  (type = '' !== type ? 'ForwardRef(' + type + ')' : 'ForwardRef'));
                return type;
              case REACT_MEMO_TYPE:
                return (
                  (innerType = type.displayName || null),
                  null !== innerType
                    ? innerType
                    : getComponentNameFromType(type.type) || 'Memo'
                );
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {}
            }
          return null;
        }
        function prepareStackTrace(error, structuredStackTrace) {
          error = (error.name || 'Error') + ': ' + (error.message || '');
          for (var i = 0; i < structuredStackTrace.length; i++)
            error += '\n    at ' + structuredStackTrace[i].toString();
          return error;
        }
        function ReactPromise(status, value, reason, response) {
          this.status = status;
          this.value = value;
          this.reason = reason;
          this._response = response;
          this._debugInfo = null;
        }
        function readChunk(chunk) {
          switch (chunk.status) {
            case 'resolved_model':
              initializeModelChunk(chunk);
              break;
            case 'resolved_module':
              initializeModuleChunk(chunk);
          }
          switch (chunk.status) {
            case 'fulfilled':
              return chunk.value;
            case 'pending':
            case 'blocked':
              throw chunk;
            default:
              throw chunk.reason;
          }
        }
        function createPendingChunk(response) {
          return new ReactPromise('pending', null, null, response);
        }
        function wakeChunk(listeners, value) {
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
        }
        function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
          switch (chunk.status) {
            case 'fulfilled':
              wakeChunk(resolveListeners, chunk.value);
              break;
            case 'pending':
            case 'blocked':
              if (chunk.value)
                for (var i = 0; i < resolveListeners.length; i++)
                  chunk.value.push(resolveListeners[i]);
              else chunk.value = resolveListeners;
              if (chunk.reason) {
                if (rejectListeners)
                  for (
                    resolveListeners = 0;
                    resolveListeners < rejectListeners.length;
                    resolveListeners++
                  )
                    chunk.reason.push(rejectListeners[resolveListeners]);
              } else chunk.reason = rejectListeners;
              break;
            case 'rejected':
              rejectListeners && wakeChunk(rejectListeners, chunk.reason);
          }
        }
        function triggerErrorOnChunk(chunk, error) {
          if ('pending' !== chunk.status && 'blocked' !== chunk.status)
            chunk.reason.error(error);
          else {
            var listeners = chunk.reason;
            chunk.status = 'rejected';
            chunk.reason = error;
            null !== listeners && wakeChunk(listeners, error);
          }
        }
        function createResolvedIteratorResultChunk(response, value, done) {
          return new ReactPromise(
            'resolved_model',
            (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
            null,
            response
          );
        }
        function resolveIteratorResultChunk(chunk, value, done) {
          resolveModelChunk(
            chunk,
            (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}'
          );
        }
        function resolveModelChunk(chunk, value) {
          if ('pending' !== chunk.status) chunk.reason.enqueueModel(value);
          else {
            var resolveListeners = chunk.value,
              rejectListeners = chunk.reason;
            chunk.status = 'resolved_model';
            chunk.value = value;
            null !== resolveListeners &&
              (initializeModelChunk(chunk),
              wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
          }
        }
        function resolveModuleChunk(chunk, value) {
          if ('pending' === chunk.status || 'blocked' === chunk.status) {
            var resolveListeners = chunk.value,
              rejectListeners = chunk.reason;
            chunk.status = 'resolved_module';
            chunk.value = value;
            null !== resolveListeners &&
              (initializeModuleChunk(chunk),
              wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
          }
        }
        function initializeModelChunk(chunk) {
          var prevHandler = initializingHandler;
          initializingHandler = null;
          var resolvedModel = chunk.value;
          chunk.status = 'blocked';
          chunk.value = null;
          chunk.reason = null;
          try {
            var value = JSON.parse(resolvedModel, chunk._response._fromJSON),
              resolveListeners = chunk.value;
            null !== resolveListeners &&
              ((chunk.value = null),
              (chunk.reason = null),
              wakeChunk(resolveListeners, value));
            if (null !== initializingHandler) {
              if (initializingHandler.errored) throw initializingHandler.value;
              if (0 < initializingHandler.deps) {
                initializingHandler.value = value;
                initializingHandler.chunk = chunk;
                return;
              }
            }
            chunk.status = 'fulfilled';
            chunk.value = value;
          } catch (error) {
            (chunk.status = 'rejected'), (chunk.reason = error);
          } finally {
            initializingHandler = prevHandler;
          }
        }
        function initializeModuleChunk(chunk) {
          try {
            var value = requireModule(chunk.value);
            chunk.status = 'fulfilled';
            chunk.value = value;
          } catch (error) {
            (chunk.status = 'rejected'), (chunk.reason = error);
          }
        }
        function reportGlobalError(response, error) {
          response._closed = !0;
          response._closedReason = error;
          response._chunks.forEach(function (chunk) {
            'pending' === chunk.status && triggerErrorOnChunk(chunk, error);
          });
        }
        function nullRefGetter() {
          return null;
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return '<>';
          if ('function' === typeof type) return '"use client"';
          if (
            'object' === typeof type &&
            null !== type &&
            type.$$typeof === REACT_LAZY_TYPE
          )
            return type._init === readChunk ? '"use client"' : '<...>';
          try {
            var name = getComponentNameFromType(type);
            return name ? '<' + name + '>' : '<...>';
          } catch (x) {
            return '<...>';
          }
        }
        function createLazyChunkWrapper(chunk) {
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: chunk,
            _init: readChunk,
          };
          chunk = chunk._debugInfo || (chunk._debugInfo = []);
          lazyType._debugInfo = chunk;
          return lazyType;
        }
        function getChunk(response, id) {
          var chunks = response._chunks,
            chunk = chunks.get(id);
          chunk ||
            ((chunk = response._closed
              ? new ReactPromise('rejected', null, response._closedReason, response)
              : createPendingChunk(response)),
            chunks.set(id, chunk));
          return chunk;
        }
        function waitForReference(
          referencedChunk,
          parentObject,
          key,
          response,
          map,
          path
        ) {
          function fulfill(value) {
            for (var i = 1; i < path.length; i++) {
              for (; value.$$typeof === REACT_LAZY_TYPE; )
                if (((value = value._payload), value === handler.chunk))
                  value = handler.value;
                else if ('fulfilled' === value.status) value = value.value;
                else {
                  path.splice(0, i - 1);
                  value.then(fulfill, reject);
                  return;
                }
              value = value[path[i]];
            }
            i = map(response, value, parentObject, key);
            parentObject[key] = i;
            '' === key && null === handler.value && (handler.value = i);
            if (
              parentObject[0] === REACT_ELEMENT_TYPE &&
              'object' === typeof handler.value &&
              null !== handler.value &&
              handler.value.$$typeof === REACT_ELEMENT_TYPE
            )
              switch (((value = handler.value), key)) {
                case '3':
                  value.props = i;
                  break;
                case '4':
                  value._owner = i;
              }
            handler.deps--;
            0 === handler.deps &&
              ((i = handler.chunk),
              null !== i &&
                'blocked' === i.status &&
                ((value = i.value),
                (i.status = 'fulfilled'),
                (i.value = handler.value),
                null !== value && wakeChunk(value, handler.value)));
          }
          function reject(error) {
            if (!handler.errored) {
              var blockedValue = handler.value;
              handler.errored = !0;
              handler.value = error;
              var chunk = handler.chunk;
              if (null !== chunk && 'blocked' === chunk.status) {
                if (
                  'object' === typeof blockedValue &&
                  null !== blockedValue &&
                  blockedValue.$$typeof === REACT_ELEMENT_TYPE
                ) {
                  var erroredComponent = {
                    name: getComponentNameFromType(blockedValue.type) || '',
                    owner: blockedValue._owner,
                  };
                  erroredComponent.debugStack = blockedValue._debugStack;
                  supportsCreateTask &&
                    (erroredComponent.debugTask = blockedValue._debugTask);
                  (chunk._debugInfo || (chunk._debugInfo = [])).push(erroredComponent);
                }
                triggerErrorOnChunk(chunk, error);
              }
            }
          }
          if (initializingHandler) {
            var handler = initializingHandler;
            handler.deps++;
          } else
            handler = initializingHandler = {
              parent: null,
              chunk: null,
              value: null,
              deps: 1,
              errored: !1,
            };
          referencedChunk.then(fulfill, reject);
          return null;
        }
        function loadServerReference(response, metaData, parentObject, key) {
          if (!response._serverReferenceConfig)
            return createBoundServerReference(
              metaData,
              response._callServer,
              response._encodeFormAction,
              response._debugFindSourceMapURL
            );
          var serverReference = resolveServerReference(
              response._serverReferenceConfig,
              metaData.id
            ),
            promise = preloadModule(serverReference);
          if (promise)
            metaData.bound && (promise = Promise.all([promise, metaData.bound]));
          else if (metaData.bound) promise = Promise.resolve(metaData.bound);
          else
            return (
              (promise = requireModule(serverReference)),
              registerBoundServerReference(
                promise,
                metaData.id,
                metaData.bound,
                response._encodeFormAction
              ),
              promise
            );
          if (initializingHandler) {
            var handler = initializingHandler;
            handler.deps++;
          } else
            handler = initializingHandler = {
              parent: null,
              chunk: null,
              value: null,
              deps: 1,
              errored: !1,
            };
          promise.then(
            function () {
              var resolvedValue = requireModule(serverReference);
              if (metaData.bound) {
                var boundArgs = metaData.bound.value.slice(0);
                boundArgs.unshift(null);
                resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);
              }
              registerBoundServerReference(
                resolvedValue,
                metaData.id,
                metaData.bound,
                response._encodeFormAction
              );
              parentObject[key] = resolvedValue;
              '' === key && null === handler.value && (handler.value = resolvedValue);
              if (
                parentObject[0] === REACT_ELEMENT_TYPE &&
                'object' === typeof handler.value &&
                null !== handler.value &&
                handler.value.$$typeof === REACT_ELEMENT_TYPE
              )
                switch (((boundArgs = handler.value), key)) {
                  case '3':
                    boundArgs.props = resolvedValue;
                    break;
                  case '4':
                    boundArgs._owner = resolvedValue;
                }
              handler.deps--;
              0 === handler.deps &&
                ((resolvedValue = handler.chunk),
                null !== resolvedValue &&
                  'blocked' === resolvedValue.status &&
                  ((boundArgs = resolvedValue.value),
                  (resolvedValue.status = 'fulfilled'),
                  (resolvedValue.value = handler.value),
                  null !== boundArgs && wakeChunk(boundArgs, handler.value)));
            },
            function (error) {
              if (!handler.errored) {
                var blockedValue = handler.value;
                handler.errored = !0;
                handler.value = error;
                var chunk = handler.chunk;
                if (null !== chunk && 'blocked' === chunk.status) {
                  if (
                    'object' === typeof blockedValue &&
                    null !== blockedValue &&
                    blockedValue.$$typeof === REACT_ELEMENT_TYPE
                  ) {
                    var erroredComponent = {
                      name: getComponentNameFromType(blockedValue.type) || '',
                      owner: blockedValue._owner,
                    };
                    erroredComponent.debugStack = blockedValue._debugStack;
                    supportsCreateTask &&
                      (erroredComponent.debugTask = blockedValue._debugTask);
                    (chunk._debugInfo || (chunk._debugInfo = [])).push(erroredComponent);
                  }
                  triggerErrorOnChunk(chunk, error);
                }
              }
            }
          );
          return null;
        }
        function getOutlinedModel(response, reference, parentObject, key, map) {
          reference = reference.split(':');
          var id = parseInt(reference[0], 16);
          id = getChunk(response, id);
          switch (id.status) {
            case 'resolved_model':
              initializeModelChunk(id);
              break;
            case 'resolved_module':
              initializeModuleChunk(id);
          }
          switch (id.status) {
            case 'fulfilled':
              for (var value = id.value, i = 1; i < reference.length; i++) {
                for (; value.$$typeof === REACT_LAZY_TYPE; )
                  if (((value = value._payload), 'fulfilled' === value.status))
                    value = value.value;
                  else
                    return waitForReference(
                      value,
                      parentObject,
                      key,
                      response,
                      map,
                      reference.slice(i - 1)
                    );
                value = value[reference[i]];
              }
              response = map(response, value, parentObject, key);
              id._debugInfo &&
                ('object' !== typeof response ||
                  null === response ||
                  (!isArrayImpl(response) &&
                    'function' !== typeof response[ASYNC_ITERATOR] &&
                    response.$$typeof !== REACT_ELEMENT_TYPE) ||
                  response._debugInfo ||
                  Object.defineProperty(response, '_debugInfo', {
                    configurable: !1,
                    enumerable: !1,
                    writable: !0,
                    value: id._debugInfo,
                  }));
              return response;
            case 'pending':
            case 'blocked':
              return waitForReference(id, parentObject, key, response, map, reference);
            default:
              return (
                initializingHandler
                  ? ((initializingHandler.errored = !0),
                    (initializingHandler.value = id.reason))
                  : (initializingHandler = {
                      parent: null,
                      chunk: null,
                      value: id.reason,
                      deps: 0,
                      errored: !0,
                    }),
                null
              );
          }
        }
        function createMap(response, model) {
          return new Map(model);
        }
        function createSet(response, model) {
          return new Set(model);
        }
        function createBlob(response, model) {
          return new Blob(model.slice(1), {
            type: model[0],
          });
        }
        function createFormData(response, model) {
          response = new FormData();
          for (var i = 0; i < model.length; i++)
            response.append(model[i][0], model[i][1]);
          return response;
        }
        function extractIterator(response, model) {
          return model[Symbol.iterator]();
        }
        function createModel(response, model) {
          return model;
        }
        function parseModelString(response, parentObject, key, value) {
          if ('$' === value[0]) {
            if ('$' === value)
              return (
                null !== initializingHandler &&
                  '0' === key &&
                  (initializingHandler = {
                    parent: initializingHandler,
                    chunk: null,
                    value: null,
                    deps: 0,
                    errored: !1,
                  }),
                REACT_ELEMENT_TYPE
              );
            switch (value[1]) {
              case '$':
                return value.slice(1);
              case 'L':
                return (
                  (parentObject = parseInt(value.slice(2), 16)),
                  (response = getChunk(response, parentObject)),
                  createLazyChunkWrapper(response)
                );
              case '@':
                if (2 === value.length) return new Promise(function () {});
                parentObject = parseInt(value.slice(2), 16);
                return getChunk(response, parentObject);
              case 'S':
                return Symbol.for(value.slice(2));
              case 'F':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(
                    response,
                    value,
                    parentObject,
                    key,
                    loadServerReference
                  )
                );
              case 'T':
                parentObject = '$' + value.slice(2);
                response = response._tempRefs;
                if (null == response)
                  throw Error(
                    'Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.'
                  );
                return response.get(parentObject);
              case 'Q':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(response, value, parentObject, key, createMap)
                );
              case 'W':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(response, value, parentObject, key, createSet)
                );
              case 'B':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(response, value, parentObject, key, createBlob)
                );
              case 'K':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(response, value, parentObject, key, createFormData)
                );
              case 'Z':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(response, value, parentObject, key, resolveErrorDev)
                );
              case 'i':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(response, value, parentObject, key, extractIterator)
                );
              case 'I':
                return Infinity;
              case '-':
                return '$-0' === value ? -0 : -Infinity;
              case 'N':
                return NaN;
              case 'u':
                return;
              case 'D':
                return new Date(Date.parse(value.slice(2)));
              case 'n':
                return BigInt(value.slice(2));
              case 'E':
                try {
                  return (0, eval)(value.slice(2));
                } catch (x) {
                  return function () {};
                }
              case 'Y':
                return (
                  Object.defineProperty(parentObject, key, {
                    get: function () {
                      return 'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.';
                    },
                    enumerable: !0,
                    configurable: !1,
                  }),
                  null
                );
              default:
                return (
                  (value = value.slice(1)),
                  getOutlinedModel(response, value, parentObject, key, createModel)
                );
            }
          }
          return value;
        }
        function missingCall() {
          throw Error(
            'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
          );
        }
        function ResponseInstance(
          bundlerConfig,
          serverReferenceConfig,
          moduleLoading,
          callServer,
          encodeFormAction,
          nonce,
          temporaryReferences,
          findSourceMapURL,
          replayConsole,
          environmentName
        ) {
          var chunks = new Map();
          this._bundlerConfig = bundlerConfig;
          this._serverReferenceConfig = serverReferenceConfig;
          this._moduleLoading = moduleLoading;
          this._callServer = void 0 !== callServer ? callServer : missingCall;
          this._encodeFormAction = encodeFormAction;
          this._nonce = nonce;
          this._chunks = chunks;
          this._stringDecoder = new TextDecoder();
          this._fromJSON = null;
          this._rowLength = this._rowTag = this._rowID = this._rowState = 0;
          this._buffer = [];
          this._closed = !1;
          this._closedReason = null;
          this._tempRefs = temporaryReferences;
          this._debugRootOwner = bundlerConfig =
            void 0 === ReactSharedInteralsServer || null === ReactSharedInteralsServer.A
              ? null
              : ReactSharedInteralsServer.A.getOwner();
          this._debugRootStack =
            null !== bundlerConfig ? Error('react-stack-top-frame') : null;
          environmentName = void 0 === environmentName ? 'Server' : environmentName;
          supportsCreateTask &&
            (this._debugRootTask = console.createTask(
              '"use ' + environmentName.toLowerCase() + '"'
            ));
          this._debugFindSourceMapURL = findSourceMapURL;
          this._replayConsole = replayConsole;
          this._rootEnvironmentName = environmentName;
          this._fromJSON = createFromJSONCallback(this);
        }
        function resolveModel(response, id, model) {
          var chunks = response._chunks,
            chunk = chunks.get(id);
          chunk
            ? resolveModelChunk(chunk, model)
            : chunks.set(id, new ReactPromise('resolved_model', model, null, response));
        }
        function resolveText(response, id, text) {
          var chunks = response._chunks,
            chunk = chunks.get(id);
          chunk && 'pending' !== chunk.status
            ? chunk.reason.enqueueValue(text)
            : chunks.set(id, new ReactPromise('fulfilled', text, null, response));
        }
        function resolveBuffer(response, id, buffer) {
          var chunks = response._chunks,
            chunk = chunks.get(id);
          chunk && 'pending' !== chunk.status
            ? chunk.reason.enqueueValue(buffer)
            : chunks.set(id, new ReactPromise('fulfilled', buffer, null, response));
        }
        function resolveModule(response, id, model) {
          var chunks = response._chunks,
            chunk = chunks.get(id);
          model = JSON.parse(model, response._fromJSON);
          var clientReference = resolveClientReference(response._bundlerConfig, model);
          prepareDestinationWithChunks(
            response._moduleLoading,
            model[1],
            response._nonce
          );
          if ((model = preloadModule(clientReference))) {
            if (chunk) {
              var blockedChunk = chunk;
              blockedChunk.status = 'blocked';
            } else
              (blockedChunk = new ReactPromise('blocked', null, null, response)),
                chunks.set(id, blockedChunk);
            model.then(
              function () {
                return resolveModuleChunk(blockedChunk, clientReference);
              },
              function (error) {
                return triggerErrorOnChunk(blockedChunk, error);
              }
            );
          } else
            chunk
              ? resolveModuleChunk(chunk, clientReference)
              : chunks.set(
                  id,
                  new ReactPromise('resolved_module', clientReference, null, response)
                );
        }
        function resolveStream(response, id, stream, controller) {
          var chunks = response._chunks,
            chunk = chunks.get(id);
          chunk
            ? 'pending' === chunk.status &&
              ((response = chunk.value),
              (chunk.status = 'fulfilled'),
              (chunk.value = stream),
              (chunk.reason = controller),
              null !== response && wakeChunk(response, chunk.value))
            : chunks.set(id, new ReactPromise('fulfilled', stream, controller, response));
        }
        function startReadableStream(response, id, type) {
          var controller = null;
          type = new ReadableStream({
            type: type,
            start: function (c) {
              controller = c;
            },
          });
          var previousBlockedChunk = null;
          resolveStream(response, id, type, {
            enqueueValue: function (value) {
              null === previousBlockedChunk
                ? controller.enqueue(value)
                : previousBlockedChunk.then(function () {
                    controller.enqueue(value);
                  });
            },
            enqueueModel: function (json) {
              if (null === previousBlockedChunk) {
                var chunk = new ReactPromise('resolved_model', json, null, response);
                initializeModelChunk(chunk);
                'fulfilled' === chunk.status
                  ? controller.enqueue(chunk.value)
                  : (chunk.then(
                      function (v) {
                        return controller.enqueue(v);
                      },
                      function (e) {
                        return controller.error(e);
                      }
                    ),
                    (previousBlockedChunk = chunk));
              } else {
                chunk = previousBlockedChunk;
                var _chunk3 = createPendingChunk(response);
                _chunk3.then(
                  function (v) {
                    return controller.enqueue(v);
                  },
                  function (e) {
                    return controller.error(e);
                  }
                );
                previousBlockedChunk = _chunk3;
                chunk.then(function () {
                  previousBlockedChunk === _chunk3 && (previousBlockedChunk = null);
                  resolveModelChunk(_chunk3, json);
                });
              }
            },
            close: function () {
              if (null === previousBlockedChunk) controller.close();
              else {
                var blockedChunk = previousBlockedChunk;
                previousBlockedChunk = null;
                blockedChunk.then(function () {
                  return controller.close();
                });
              }
            },
            error: function (error) {
              if (null === previousBlockedChunk) controller.error(error);
              else {
                var blockedChunk = previousBlockedChunk;
                previousBlockedChunk = null;
                blockedChunk.then(function () {
                  return controller.error(error);
                });
              }
            },
          });
        }
        function asyncIterator() {
          return this;
        }
        function createIterator(next) {
          next = {
            next: next,
          };
          next[ASYNC_ITERATOR] = asyncIterator;
          return next;
        }
        function startAsyncIterable(response, id, iterator) {
          var buffer = [],
            closed = !1,
            nextWriteIndex = 0,
            iterable = _defineProperty({}, ASYNC_ITERATOR, function () {
              var nextReadIndex = 0;
              return createIterator(function (arg) {
                if (void 0 !== arg)
                  throw Error(
                    'Values cannot be passed to next() of AsyncIterables passed to Client Components.'
                  );
                if (nextReadIndex === buffer.length) {
                  if (closed)
                    return new ReactPromise(
                      'fulfilled',
                      {
                        done: !0,
                        value: void 0,
                      },
                      null,
                      response
                    );
                  buffer[nextReadIndex] = createPendingChunk(response);
                }
                return buffer[nextReadIndex++];
              });
            });
          resolveStream(response, id, iterator ? iterable[ASYNC_ITERATOR]() : iterable, {
            enqueueValue: function (value) {
              if (nextWriteIndex === buffer.length)
                buffer[nextWriteIndex] = new ReactPromise(
                  'fulfilled',
                  {
                    done: !1,
                    value: value,
                  },
                  null,
                  response
                );
              else {
                var chunk = buffer[nextWriteIndex],
                  resolveListeners = chunk.value,
                  rejectListeners = chunk.reason;
                chunk.status = 'fulfilled';
                chunk.value = {
                  done: !1,
                  value: value,
                };
                null !== resolveListeners &&
                  wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
              }
              nextWriteIndex++;
            },
            enqueueModel: function (value) {
              nextWriteIndex === buffer.length
                ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                    response,
                    value,
                    !1
                  ))
                : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
              nextWriteIndex++;
            },
            close: function (value) {
              closed = !0;
              nextWriteIndex === buffer.length
                ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                    response,
                    value,
                    !0
                  ))
                : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
              for (nextWriteIndex++; nextWriteIndex < buffer.length; )
                resolveIteratorResultChunk(buffer[nextWriteIndex++], '"$undefined"', !0);
            },
            error: function (error) {
              closed = !0;
              for (
                nextWriteIndex === buffer.length &&
                (buffer[nextWriteIndex] = createPendingChunk(response));
                nextWriteIndex < buffer.length;

              )
                triggerErrorOnChunk(buffer[nextWriteIndex++], error);
            },
          });
        }
        function stopStream(response, id, row) {
          (response = response._chunks.get(id)) &&
            'fulfilled' === response.status &&
            response.reason.close('' === row ? '"$undefined"' : row);
        }
        function resolveErrorDev(response, errorInfo) {
          var name = errorInfo.name,
            env = errorInfo.env;
          errorInfo = buildFakeCallStack(
            response,
            errorInfo.stack,
            env,
            Error.bind(
              null,
              errorInfo.message ||
                'An error occurred in the Server Components render but no message was provided'
            )
          );
          response = getRootTask(response, env);
          response = null != response ? response.run(errorInfo) : errorInfo();
          response.name = name;
          response.environmentName = env;
          return response;
        }
        function resolveHint(response, code, model) {
          response = JSON.parse(model, response._fromJSON);
          model = ReactDOMSharedInternals.d;
          switch (code) {
            case 'D':
              model.D(response);
              break;
            case 'C':
              'string' === typeof response
                ? model.C(response)
                : model.C(response[0], response[1]);
              break;
            case 'L':
              code = response[0];
              var as = response[1];
              3 === response.length ? model.L(code, as, response[2]) : model.L(code, as);
              break;
            case 'm':
              'string' === typeof response
                ? model.m(response)
                : model.m(response[0], response[1]);
              break;
            case 'X':
              'string' === typeof response
                ? model.X(response)
                : model.X(response[0], response[1]);
              break;
            case 'S':
              'string' === typeof response
                ? model.S(response)
                : model.S(
                    response[0],
                    0 === response[1] ? void 0 : response[1],
                    3 === response.length ? response[2] : void 0
                  );
              break;
            case 'M':
              'string' === typeof response
                ? model.M(response)
                : model.M(response[0], response[1]);
          }
        }
        function createFakeFunction(
          name,
          filename,
          sourceMap,
          line,
          col,
          environmentName
        ) {
          name || (name = '<anonymous>');
          var encodedName = JSON.stringify(name);
          1 >= line
            ? ((line = encodedName.length + 7),
              (col =
                '({' +
                encodedName +
                ':_=>' +
                ' '.repeat(col < line ? 0 : col - line) +
                '_()})\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */'))
            : (col =
                '/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */' +
                '\n'.repeat(line - 2) +
                '({' +
                encodedName +
                ':_=>\n' +
                ' '.repeat(1 > col ? 0 : col - 1) +
                '_()})');
          filename.startsWith('/') && (filename = 'file://' + filename);
          sourceMap
            ? ((col +=
                '\n//# sourceURL=rsc://React/' +
                encodeURIComponent(environmentName) +
                '/' +
                encodeURI(filename) +
                '?' +
                fakeFunctionIdx++),
              (col += '\n//# sourceMappingURL=' + sourceMap))
            : (col = filename
                ? col + ('\n//# sourceURL=' + encodeURI(filename))
                : col + '\n//# sourceURL=<anonymous>');
          try {
            var fn = (0, eval)(col)[name];
          } catch (x) {
            fn = function (_) {
              return _();
            };
          }
          return fn;
        }
        function buildFakeCallStack(response, stack, environmentName, innerCall) {
          for (var i = 0; i < stack.length; i++) {
            var frame = stack[i],
              frameKey = frame.join('-') + '-' + environmentName,
              fn = fakeFunctionCache.get(frameKey);
            if (void 0 === fn) {
              fn = frame[0];
              var filename = frame[1],
                line = frame[2];
              frame = frame[3];
              var findSourceMapURL = response._debugFindSourceMapURL;
              findSourceMapURL = findSourceMapURL
                ? findSourceMapURL(filename, environmentName)
                : null;
              fn = createFakeFunction(
                fn,
                filename,
                findSourceMapURL,
                line,
                frame,
                environmentName
              );
              fakeFunctionCache.set(frameKey, fn);
            }
            innerCall = fn.bind(null, innerCall);
          }
          return innerCall;
        }
        function getRootTask(response, childEnvironmentName) {
          var rootTask = response._debugRootTask;
          return rootTask
            ? response._rootEnvironmentName !== childEnvironmentName
              ? ((response = console.createTask.bind(
                  console,
                  '"use ' + childEnvironmentName.toLowerCase() + '"'
                )),
                rootTask.run(response))
              : rootTask
            : null;
        }
        function initializeFakeTask(response, debugInfo, childEnvironmentName) {
          if (!supportsCreateTask || null == debugInfo.stack) return null;
          var stack = debugInfo.stack,
            env = null == debugInfo.env ? response._rootEnvironmentName : debugInfo.env;
          if (env !== childEnvironmentName)
            return (
              (debugInfo =
                null == debugInfo.owner
                  ? null
                  : initializeFakeTask(response, debugInfo.owner, env)),
              buildFakeTask(
                response,
                debugInfo,
                stack,
                '"use ' + childEnvironmentName.toLowerCase() + '"',
                env
              )
            );
          childEnvironmentName = debugInfo.debugTask;
          if (void 0 !== childEnvironmentName) return childEnvironmentName;
          childEnvironmentName =
            null == debugInfo.owner
              ? null
              : initializeFakeTask(response, debugInfo.owner, env);
          return (debugInfo.debugTask = buildFakeTask(
            response,
            childEnvironmentName,
            stack,
            '<' + (debugInfo.name || '...') + '>',
            env
          ));
        }
        function buildFakeTask(response, ownerTask, stack, taskName, env) {
          taskName = console.createTask.bind(console, taskName);
          stack = buildFakeCallStack(response, stack, env, taskName);
          return null === ownerTask
            ? ((response = getRootTask(response, env)),
              null != response ? response.run(stack) : stack())
            : ownerTask.run(stack);
        }
        function fakeJSXCallSite() {
          return Error('react-stack-top-frame');
        }
        function initializeFakeStack(response, debugInfo) {
          void 0 === debugInfo.debugStack &&
            (null != debugInfo.stack &&
              (debugInfo.debugStack = createFakeJSXCallStackInDEV(
                response,
                debugInfo.stack,
                null == debugInfo.env ? '' : debugInfo.env
              )),
            null != debugInfo.owner && initializeFakeStack(response, debugInfo.owner));
        }
        function resolveDebugInfo(response, id, debugInfo) {
          var env =
            void 0 === debugInfo.env ? response._rootEnvironmentName : debugInfo.env;
          void 0 !== debugInfo.stack && initializeFakeTask(response, debugInfo, env);
          null === debugInfo.owner && null != response._debugRootOwner
            ? ((debugInfo.owner = response._debugRootOwner),
              (debugInfo.debugStack = response._debugRootStack))
            : void 0 !== debugInfo.stack && initializeFakeStack(response, debugInfo);
          response = getChunk(response, id);
          (response._debugInfo || (response._debugInfo = [])).push(debugInfo);
        }
        function getCurrentStackInDEV() {
          var owner = currentOwnerInDEV;
          if (null === owner) return '';
          try {
            var info = '';
            if (owner.owner || 'string' !== typeof owner.name) {
              for (; owner; ) {
                var ownerStack = owner.debugStack;
                if (null != ownerStack) {
                  if ((owner = owner.owner)) {
                    var JSCompiler_temp_const = info;
                    var error = ownerStack,
                      prevPrepareStackTrace = Error.prepareStackTrace;
                    Error.prepareStackTrace = prepareStackTrace;
                    var stack = error.stack;
                    Error.prepareStackTrace = prevPrepareStackTrace;
                    stack.startsWith('Error: react-stack-top-frame\n') &&
                      (stack = stack.slice(29));
                    var idx = stack.indexOf('\n');
                    -1 !== idx && (stack = stack.slice(idx + 1));
                    idx = stack.indexOf('react-stack-bottom-frame');
                    -1 !== idx && (idx = stack.lastIndexOf('\n', idx));
                    var JSCompiler_inline_result =
                      -1 !== idx ? (stack = stack.slice(0, idx)) : '';
                    info = JSCompiler_temp_const + ('\n' + JSCompiler_inline_result);
                  }
                } else break;
              }
              var JSCompiler_inline_result$jscomp$0 = info;
            } else {
              JSCompiler_temp_const = owner.name;
              if (void 0 === prefix)
                try {
                  throw Error();
                } catch (x) {
                  (prefix =
                    ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) || ''),
                    (suffix =
                      -1 < x.stack.indexOf('\n    at')
                        ? ' (<anonymous>)'
                        : -1 < x.stack.indexOf('@')
                          ? '@unknown:0:0'
                          : '');
                }
              JSCompiler_inline_result$jscomp$0 =
                '\n' + prefix + JSCompiler_temp_const + suffix;
            }
          } catch (x) {
            JSCompiler_inline_result$jscomp$0 =
              '\nError generating stack: ' + x.message + '\n' + x.stack;
          }
          return JSCompiler_inline_result$jscomp$0;
        }
        function resolveConsoleEntry(response, value) {
          if (response._replayConsole) {
            var payload = JSON.parse(value, response._fromJSON);
            value = payload[0];
            var stackTrace = payload[1],
              owner = payload[2],
              env = payload[3];
            payload = payload.slice(4);
            replayConsoleWithCallStackInDEV(
              response,
              value,
              stackTrace,
              owner,
              env,
              payload
            );
          }
        }
        function mergeBuffer(buffer, lastChunk) {
          for (var l = buffer.length, byteLength = lastChunk.length, i = 0; i < l; i++)
            byteLength += buffer[i].byteLength;
          byteLength = new Uint8Array(byteLength);
          for (var _i2 = (i = 0); _i2 < l; _i2++) {
            var chunk = buffer[_i2];
            byteLength.set(chunk, i);
            i += chunk.byteLength;
          }
          byteLength.set(lastChunk, i);
          return byteLength;
        }
        function resolveTypedArray(
          response,
          id,
          buffer,
          lastChunk,
          constructor,
          bytesPerElement
        ) {
          buffer =
            0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
              ? lastChunk
              : mergeBuffer(buffer, lastChunk);
          constructor = new constructor(
            buffer.buffer,
            buffer.byteOffset,
            buffer.byteLength / bytesPerElement
          );
          resolveBuffer(response, id, constructor);
        }
        function processFullBinaryRow(response, id, tag, buffer, chunk) {
          switch (tag) {
            case 65:
              resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);
              return;
            case 79:
              resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);
              return;
            case 111:
              resolveBuffer(
                response,
                id,
                0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)
              );
              return;
            case 85:
              resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);
              return;
            case 83:
              resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);
              return;
            case 115:
              resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);
              return;
            case 76:
              resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);
              return;
            case 108:
              resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);
              return;
            case 71:
              resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);
              return;
            case 103:
              resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);
              return;
            case 77:
              resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);
              return;
            case 109:
              resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);
              return;
            case 86:
              resolveTypedArray(response, id, buffer, chunk, DataView, 1);
              return;
          }
          for (
            var stringDecoder = response._stringDecoder, row = '', i = 0;
            i < buffer.length;
            i++
          )
            row += stringDecoder.decode(buffer[i], decoderOptions);
          row += stringDecoder.decode(chunk);
          processFullStringRow(response, id, tag, row);
        }
        function processFullStringRow(response, id, tag, row) {
          switch (tag) {
            case 73:
              resolveModule(response, id, row);
              break;
            case 72:
              resolveHint(response, row[0], row.slice(1));
              break;
            case 69:
              row = JSON.parse(row);
              tag = resolveErrorDev(response, row);
              tag.digest = row.digest;
              row = response._chunks;
              var chunk = row.get(id);
              chunk
                ? triggerErrorOnChunk(chunk, tag)
                : row.set(id, new ReactPromise('rejected', null, tag, response));
              break;
            case 84:
              resolveText(response, id, row);
              break;
            case 78:
            case 68:
              tag = new ReactPromise('resolved_model', row, null, response);
              initializeModelChunk(tag);
              'fulfilled' === tag.status
                ? resolveDebugInfo(response, id, tag.value)
                : tag.then(
                    function (v) {
                      return resolveDebugInfo(response, id, v);
                    },
                    function () {}
                  );
              break;
            case 87:
              resolveConsoleEntry(response, row);
              break;
            case 82:
              startReadableStream(response, id, void 0);
              break;
            case 114:
              startReadableStream(response, id, 'bytes');
              break;
            case 88:
              startAsyncIterable(response, id, !1);
              break;
            case 120:
              startAsyncIterable(response, id, !0);
              break;
            case 67:
              stopStream(response, id, row);
              break;
            default:
              resolveModel(response, id, row);
          }
        }
        function createFromJSONCallback(response) {
          return function (key, value) {
            if ('string' === typeof value)
              return parseModelString(response, this, key, value);
            if ('object' === typeof value && null !== value) {
              if (value[0] === REACT_ELEMENT_TYPE) {
                var type = value[1];
                key = value[4];
                var stack = value[5],
                  validated = value[6];
                value = {
                  $$typeof: REACT_ELEMENT_TYPE,
                  type: type,
                  key: value[2],
                  props: value[3],
                  _owner: null === key ? response._debugRootOwner : key,
                };
                Object.defineProperty(value, 'ref', {
                  enumerable: !1,
                  get: nullRefGetter,
                });
                value._store = {};
                Object.defineProperty(value._store, 'validated', {
                  configurable: !1,
                  enumerable: !1,
                  writable: !0,
                  value: validated,
                });
                Object.defineProperty(value, '_debugInfo', {
                  configurable: !1,
                  enumerable: !1,
                  writable: !0,
                  value: null,
                });
                validated = response._rootEnvironmentName;
                null !== key && null != key.env && (validated = key.env);
                var normalizedStackTrace = null;
                null === key && null != response._debugRootStack
                  ? (normalizedStackTrace = response._debugRootStack)
                  : null !== stack &&
                    (normalizedStackTrace = createFakeJSXCallStackInDEV(
                      response,
                      stack,
                      validated
                    ));
                Object.defineProperty(value, '_debugStack', {
                  configurable: !1,
                  enumerable: !1,
                  writable: !0,
                  value: normalizedStackTrace,
                });
                normalizedStackTrace = null;
                supportsCreateTask &&
                  null !== stack &&
                  ((type = console.createTask.bind(console, getTaskName(type))),
                  (stack = buildFakeCallStack(response, stack, validated, type)),
                  (type =
                    null === key ? null : initializeFakeTask(response, key, validated)),
                  null === type
                    ? ((type = response._debugRootTask),
                      (normalizedStackTrace = null != type ? type.run(stack) : stack()))
                    : (normalizedStackTrace = type.run(stack)));
                Object.defineProperty(value, '_debugTask', {
                  configurable: !1,
                  enumerable: !1,
                  writable: !0,
                  value: normalizedStackTrace,
                });
                null !== key && initializeFakeStack(response, key);
                null !== initializingHandler
                  ? ((stack = initializingHandler),
                    (initializingHandler = stack.parent),
                    stack.errored
                      ? ((key = new ReactPromise(
                          'rejected',
                          null,
                          stack.value,
                          response
                        )),
                        (stack = {
                          name: getComponentNameFromType(value.type) || '',
                          owner: value._owner,
                        }),
                        (stack.debugStack = value._debugStack),
                        supportsCreateTask && (stack.debugTask = value._debugTask),
                        (key._debugInfo = [stack]),
                        (value = createLazyChunkWrapper(key)))
                      : 0 < stack.deps &&
                        ((key = new ReactPromise('blocked', null, null, response)),
                        (stack.value = value),
                        (stack.chunk = key),
                        (value = Object.freeze.bind(Object, value.props)),
                        key.then(value, value),
                        (value = createLazyChunkWrapper(key))))
                  : Object.freeze(value.props);
              }
              return value;
            }
            return value;
          };
        }
        function noServerCall() {
          throw Error(
            'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.'
          );
        }
        function createResponseFromOptions(options) {
          return new ResponseInstance(
            options.serverConsumerManifest.moduleMap,
            options.serverConsumerManifest.serverModuleMap,
            options.serverConsumerManifest.moduleLoading,
            noServerCall,
            options.encodeFormAction,
            'string' === typeof options.nonce ? options.nonce : void 0,
            options && options.temporaryReferences ? options.temporaryReferences : void 0,
            options && options.findSourceMapURL ? options.findSourceMapURL : void 0,
            options ? !0 === options.replayConsoleLogs : !1,
            options && options.environmentName ? options.environmentName : void 0
          );
        }
        function startReadingFromStream(response, stream) {
          function progress(_ref) {
            var value = _ref.value;
            if (_ref.done) reportGlobalError(response, Error('Connection closed.'));
            else {
              var i = 0,
                rowState = response._rowState;
              _ref = response._rowID;
              for (
                var rowTag = response._rowTag,
                  rowLength = response._rowLength,
                  buffer = response._buffer,
                  chunkLength = value.length;
                i < chunkLength;

              ) {
                var lastIdx = -1;
                switch (rowState) {
                  case 0:
                    lastIdx = value[i++];
                    58 === lastIdx
                      ? (rowState = 1)
                      : (_ref =
                          (_ref << 4) | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
                    continue;
                  case 1:
                    rowState = value[i];
                    84 === rowState ||
                    65 === rowState ||
                    79 === rowState ||
                    111 === rowState ||
                    85 === rowState ||
                    83 === rowState ||
                    115 === rowState ||
                    76 === rowState ||
                    108 === rowState ||
                    71 === rowState ||
                    103 === rowState ||
                    77 === rowState ||
                    109 === rowState ||
                    86 === rowState
                      ? ((rowTag = rowState), (rowState = 2), i++)
                      : (64 < rowState && 91 > rowState) ||
                          35 === rowState ||
                          114 === rowState ||
                          120 === rowState
                        ? ((rowTag = rowState), (rowState = 3), i++)
                        : ((rowTag = 0), (rowState = 3));
                    continue;
                  case 2:
                    lastIdx = value[i++];
                    44 === lastIdx
                      ? (rowState = 4)
                      : (rowLength =
                          (rowLength << 4) |
                          (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
                    continue;
                  case 3:
                    lastIdx = value.indexOf(10, i);
                    break;
                  case 4:
                    (lastIdx = i + rowLength), lastIdx > value.length && (lastIdx = -1);
                }
                var offset = value.byteOffset + i;
                if (-1 < lastIdx)
                  (rowLength = new Uint8Array(value.buffer, offset, lastIdx - i)),
                    processFullBinaryRow(response, _ref, rowTag, buffer, rowLength),
                    (i = lastIdx),
                    3 === rowState && i++,
                    (rowLength = _ref = rowTag = rowState = 0),
                    (buffer.length = 0);
                else {
                  value = new Uint8Array(value.buffer, offset, value.byteLength - i);
                  buffer.push(value);
                  rowLength -= value.byteLength;
                  break;
                }
              }
              response._rowState = rowState;
              response._rowID = _ref;
              response._rowTag = rowTag;
              response._rowLength = rowLength;
              return reader.read().then(progress).catch(error);
            }
          }
          function error(e) {
            reportGlobalError(response, e);
          }
          var reader = stream.getReader();
          reader.read().then(progress).catch(error);
        }
        var ReactDOM = __webpack_require__(1405),
          React = __webpack_require__(8516),
          decoderOptions = {
            stream: !0,
          },
          bind$1 = Function.prototype.bind,
          chunkCache = new Map(),
          ReactDOMSharedInternals =
            ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
          REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
          REACT_PORTAL_TYPE = Symbol.for('react.portal'),
          REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
          REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode'),
          REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        Symbol.for('react.provider');
        var REACT_CONSUMER_TYPE = Symbol.for('react.consumer'),
          REACT_CONTEXT_TYPE = Symbol.for('react.context'),
          REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
          REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
          REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
          REACT_MEMO_TYPE = Symbol.for('react.memo'),
          REACT_LAZY_TYPE = Symbol.for('react.lazy'),
          REACT_ACTIVITY_TYPE = Symbol.for('react.activity'),
          MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
          ASYNC_ITERATOR = Symbol.asyncIterator,
          isArrayImpl = Array.isArray,
          getPrototypeOf = Object.getPrototypeOf,
          jsxPropsParents = new WeakMap(),
          jsxChildrenParents = new WeakMap(),
          CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference'),
          ObjectPrototype = Object.prototype,
          knownServerReferences = new WeakMap(),
          boundCache = new WeakMap(),
          fakeServerFunctionIdx = 0,
          FunctionBind = Function.prototype.bind,
          ArraySlice = Array.prototype.slice,
          v8FrameRegExp =
            /^ {3} at (?:(.+) \((.+):(\d+):(\d+)\)|(?:async )?(.+):(\d+):(\d+))$/,
          jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\d+):(\d+)/,
          REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'),
          prefix,
          suffix;
        new ('function' === typeof WeakMap ? WeakMap : Map)();
        var ReactSharedInteralsServer =
            React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
          ReactSharedInternals =
            React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE ||
            ReactSharedInteralsServer;
        ReactPromise.prototype = Object.create(Promise.prototype);
        ReactPromise.prototype.then = function (resolve, reject) {
          switch (this.status) {
            case 'resolved_model':
              initializeModelChunk(this);
              break;
            case 'resolved_module':
              initializeModuleChunk(this);
          }
          switch (this.status) {
            case 'fulfilled':
              resolve(this.value);
              break;
            case 'pending':
            case 'blocked':
              resolve &&
                (null === this.value && (this.value = []), this.value.push(resolve));
              reject &&
                (null === this.reason && (this.reason = []), this.reason.push(reject));
              break;
            default:
              reject && reject(this.reason);
          }
        };
        var initializingHandler = null,
          supportsCreateTask = !!console.createTask,
          fakeFunctionCache = new Map(),
          fakeFunctionIdx = 0,
          createFakeJSXCallStack = {
            'react-stack-bottom-frame': function (response, stack, environmentName) {
              return buildFakeCallStack(
                response,
                stack,
                environmentName,
                fakeJSXCallSite
              )();
            },
          },
          createFakeJSXCallStackInDEV =
            createFakeJSXCallStack['react-stack-bottom-frame'].bind(
              createFakeJSXCallStack
            ),
          currentOwnerInDEV = null,
          replayConsoleWithCallStack = {
            'react-stack-bottom-frame': function (
              response,
              methodName,
              stackTrace,
              owner,
              env,
              args
            ) {
              var prevStack = ReactSharedInternals.getCurrentStack;
              ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
              currentOwnerInDEV = null === owner ? response._debugRootOwner : owner;
              try {
                a: {
                  var offset = 0;
                  switch (methodName) {
                    case 'dir':
                    case 'dirxml':
                    case 'groupEnd':
                    case 'table':
                      var JSCompiler_inline_result = bind$1.apply(
                        console[methodName],
                        [console].concat(args)
                      );
                      break a;
                    case 'assert':
                      offset = 1;
                  }
                  var newArgs = args.slice(0);
                  'string' === typeof newArgs[offset]
                    ? newArgs.splice(
                        offset,
                        1,
                        '\u001b[0m\u001b[7m%c%s\u001b[0m%c ' + newArgs[offset],
                        'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px',
                        ' ' + env + ' ',
                        ''
                      )
                    : newArgs.splice(
                        offset,
                        0,
                        '\u001b[0m\u001b[7m%c%s\u001b[0m%c ',
                        'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px',
                        ' ' + env + ' ',
                        ''
                      );
                  newArgs.unshift(console);
                  JSCompiler_inline_result = bind$1.apply(console[methodName], newArgs);
                }
                var callStack = buildFakeCallStack(
                  response,
                  stackTrace,
                  env,
                  JSCompiler_inline_result
                );
                if (null != owner) {
                  var task = initializeFakeTask(response, owner, env);
                  initializeFakeStack(response, owner);
                  if (null !== task) {
                    task.run(callStack);
                    return;
                  }
                }
                var rootTask = getRootTask(response, env);
                null != rootTask ? rootTask.run(callStack) : callStack();
              } finally {
                (currentOwnerInDEV = null),
                  (ReactSharedInternals.getCurrentStack = prevStack);
              }
            },
          },
          replayConsoleWithCallStackInDEV = replayConsoleWithCallStack[
            'react-stack-bottom-frame'
          ].bind(replayConsoleWithCallStack);
        exports.createFromFetch = function (promiseForResponse, options) {
          var response = createResponseFromOptions(options);
          promiseForResponse.then(
            function (r) {
              startReadingFromStream(response, r.body);
            },
            function (e) {
              reportGlobalError(response, e);
            }
          );
          return getChunk(response, 0);
        };
        exports.createFromReadableStream = function (stream, options) {
          options = createResponseFromOptions(options);
          startReadingFromStream(options, stream);
          return getChunk(options, 0);
        };
        exports.createServerReference = function (id) {
          return createServerReference$1(id, noServerCall);
        };
        exports.createTemporaryReferenceSet = function () {
          return new Map();
        };
        exports.encodeReply = function (value, options) {
          return new Promise(function (resolve, reject) {
            var abort = processReply(
              value,
              '',
              options && options.temporaryReferences
                ? options.temporaryReferences
                : void 0,
              resolve,
              reject
            );
            if (options && options.signal) {
              var signal = options.signal;
              if (signal.aborted) abort(signal.reason);
              else {
                var listener = function () {
                  abort(signal.reason);
                  signal.removeEventListener('abort', listener);
                };
                signal.addEventListener('abort', listener);
              }
            }
          });
        };
        exports.registerServerReference = function (reference, id, encodeFormAction) {
          registerBoundServerReference(reference, id, null, encodeFormAction);
          return reference;
        };
      })();
  },
  4999: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    if (false) {
    } else {
      module.exports = __webpack_require__(5737);
    }
  },
  5760: function () {},
  2618: function (module) {
    (() => {
      'use strict';
      var e = {
        328: (e) => {
          function hash(e) {
            var r = 5381,
              _ = e.length;
            while (_) {
              r = (r * 33) ^ e.charCodeAt(--_);
            }
            return r >>> 0;
          }
          e.exports = hash;
        },
      };
      var r = {};
      function __nccwpck_require__(_) {
        var a = r[_];
        if (a !== undefined) {
          return a.exports;
        }
        var t = (r[_] = { exports: {} });
        var i = true;
        try {
          e[_](t, t.exports, __nccwpck_require__);
          i = false;
        } finally {
          if (i) delete r[_];
        }
        return t.exports;
      }
      if (typeof __nccwpck_require__ !== 'undefined')
        __nccwpck_require__.ab = __dirname + '/';
      var _ = __nccwpck_require__(328);
      module.exports = _;
    })();
  },
  8567: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'Batcher', {
      enumerable: true,
      get: function () {
        return Batcher;
      },
    });
    const _detachedpromise = __webpack_require__(8308);
    class Batcher {
      constructor(
        cacheKeyFn,
        /**
         * A function that will be called to schedule the wrapped function to be executed. This
         * defaults to a function that will execute the function immediately.
         */ schedulerFn = (fn) => fn()
      ) {
        this.cacheKeyFn = cacheKeyFn;
        this.schedulerFn = schedulerFn;
        this.pending = new Map();
      }
      static create(options) {
        return new Batcher(
          options == null ? void 0 : options.cacheKeyFn,
          options == null ? void 0 : options.schedulerFn
        );
      }
      /**
       * Wraps a function in a promise that will be resolved or rejected only once for a
       * given key. This will allow multiple calls to the function to be made, but only one
       * will be executed at a time. The result of the first call will be returned to all
       * callers.
       *
       * @param key The key to use for the cache
       * @param fn The function to wrap
       * @returns A promise that resolves to the result of the function
       */ async batch(key, fn) {
        const cacheKey = this.cacheKeyFn ? await this.cacheKeyFn(key) : key;
        if (cacheKey === null) {
          return fn(cacheKey, Promise.resolve);
        }
        const pending = this.pending.get(cacheKey);
        if (pending) return pending;
        const { promise, resolve, reject } = new _detachedpromise.DetachedPromise();
        this.pending.set(cacheKey, promise);
        this.schedulerFn(async () => {
          try {
            const result = await fn(cacheKey, resolve);
            // Resolving a promise multiple times is a no-op, so we can safely
            // resolve all pending promises with the same result.
            resolve(result);
          } catch (err) {
            reject(err);
          } finally {
            this.pending.delete(cacheKey);
          }
        });
        return promise;
      }
    }

    //# sourceMappingURL=batcher.js.map
  },
  6914: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ACTION_SUFFIX: function () {
        return ACTION_SUFFIX;
      },
      APP_DIR_ALIAS: function () {
        return APP_DIR_ALIAS;
      },
      CACHE_ONE_YEAR: function () {
        return CACHE_ONE_YEAR;
      },
      DOT_NEXT_ALIAS: function () {
        return DOT_NEXT_ALIAS;
      },
      ESLINT_DEFAULT_DIRS: function () {
        return ESLINT_DEFAULT_DIRS;
      },
      GSP_NO_RETURNED_VALUE: function () {
        return GSP_NO_RETURNED_VALUE;
      },
      GSSP_COMPONENT_MEMBER_ERROR: function () {
        return GSSP_COMPONENT_MEMBER_ERROR;
      },
      GSSP_NO_RETURNED_VALUE: function () {
        return GSSP_NO_RETURNED_VALUE;
      },
      INFINITE_CACHE: function () {
        return INFINITE_CACHE;
      },
      INSTRUMENTATION_HOOK_FILENAME: function () {
        return INSTRUMENTATION_HOOK_FILENAME;
      },
      MATCHED_PATH_HEADER: function () {
        return MATCHED_PATH_HEADER;
      },
      MIDDLEWARE_FILENAME: function () {
        return MIDDLEWARE_FILENAME;
      },
      MIDDLEWARE_LOCATION_REGEXP: function () {
        return MIDDLEWARE_LOCATION_REGEXP;
      },
      NEXT_BODY_SUFFIX: function () {
        return NEXT_BODY_SUFFIX;
      },
      NEXT_CACHE_IMPLICIT_TAG_ID: function () {
        return NEXT_CACHE_IMPLICIT_TAG_ID;
      },
      NEXT_CACHE_REVALIDATED_TAGS_HEADER: function () {
        return NEXT_CACHE_REVALIDATED_TAGS_HEADER;
      },
      NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function () {
        return NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER;
      },
      NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function () {
        return NEXT_CACHE_SOFT_TAG_MAX_LENGTH;
      },
      NEXT_CACHE_TAGS_HEADER: function () {
        return NEXT_CACHE_TAGS_HEADER;
      },
      NEXT_CACHE_TAG_MAX_ITEMS: function () {
        return NEXT_CACHE_TAG_MAX_ITEMS;
      },
      NEXT_CACHE_TAG_MAX_LENGTH: function () {
        return NEXT_CACHE_TAG_MAX_LENGTH;
      },
      NEXT_DATA_SUFFIX: function () {
        return NEXT_DATA_SUFFIX;
      },
      NEXT_INTERCEPTION_MARKER_PREFIX: function () {
        return NEXT_INTERCEPTION_MARKER_PREFIX;
      },
      NEXT_META_SUFFIX: function () {
        return NEXT_META_SUFFIX;
      },
      NEXT_QUERY_PARAM_PREFIX: function () {
        return NEXT_QUERY_PARAM_PREFIX;
      },
      NEXT_RESUME_HEADER: function () {
        return NEXT_RESUME_HEADER;
      },
      NON_STANDARD_NODE_ENV: function () {
        return NON_STANDARD_NODE_ENV;
      },
      PAGES_DIR_ALIAS: function () {
        return PAGES_DIR_ALIAS;
      },
      PRERENDER_REVALIDATE_HEADER: function () {
        return PRERENDER_REVALIDATE_HEADER;
      },
      PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function () {
        return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;
      },
      PUBLIC_DIR_MIDDLEWARE_CONFLICT: function () {
        return PUBLIC_DIR_MIDDLEWARE_CONFLICT;
      },
      ROOT_DIR_ALIAS: function () {
        return ROOT_DIR_ALIAS;
      },
      RSC_ACTION_CLIENT_WRAPPER_ALIAS: function () {
        return RSC_ACTION_CLIENT_WRAPPER_ALIAS;
      },
      RSC_ACTION_ENCRYPTION_ALIAS: function () {
        return RSC_ACTION_ENCRYPTION_ALIAS;
      },
      RSC_ACTION_PROXY_ALIAS: function () {
        return RSC_ACTION_PROXY_ALIAS;
      },
      RSC_ACTION_VALIDATE_ALIAS: function () {
        return RSC_ACTION_VALIDATE_ALIAS;
      },
      RSC_CACHE_WRAPPER_ALIAS: function () {
        return RSC_CACHE_WRAPPER_ALIAS;
      },
      RSC_MOD_REF_PROXY_ALIAS: function () {
        return RSC_MOD_REF_PROXY_ALIAS;
      },
      RSC_PREFETCH_SUFFIX: function () {
        return RSC_PREFETCH_SUFFIX;
      },
      RSC_SEGMENTS_DIR_SUFFIX: function () {
        return RSC_SEGMENTS_DIR_SUFFIX;
      },
      RSC_SEGMENT_SUFFIX: function () {
        return RSC_SEGMENT_SUFFIX;
      },
      RSC_SUFFIX: function () {
        return RSC_SUFFIX;
      },
      SERVER_PROPS_EXPORT_ERROR: function () {
        return SERVER_PROPS_EXPORT_ERROR;
      },
      SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function () {
        return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;
      },
      SERVER_PROPS_SSG_CONFLICT: function () {
        return SERVER_PROPS_SSG_CONFLICT;
      },
      SERVER_RUNTIME: function () {
        return SERVER_RUNTIME;
      },
      SSG_FALLBACK_EXPORT_ERROR: function () {
        return SSG_FALLBACK_EXPORT_ERROR;
      },
      SSG_GET_INITIAL_PROPS_CONFLICT: function () {
        return SSG_GET_INITIAL_PROPS_CONFLICT;
      },
      STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function () {
        return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;
      },
      UNSTABLE_REVALIDATE_RENAME_ERROR: function () {
        return UNSTABLE_REVALIDATE_RENAME_ERROR;
      },
      WEBPACK_LAYERS: function () {
        return WEBPACK_LAYERS;
      },
      WEBPACK_RESOURCE_QUERIES: function () {
        return WEBPACK_RESOURCE_QUERIES;
      },
    });
    const NEXT_QUERY_PARAM_PREFIX = 'nxtP';
    const NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI';
    const MATCHED_PATH_HEADER = 'x-matched-path';
    const PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate';
    const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER =
      'x-prerender-revalidate-if-generated';
    const RSC_PREFETCH_SUFFIX = '.prefetch.rsc';
    const RSC_SEGMENTS_DIR_SUFFIX = '.segments';
    const RSC_SEGMENT_SUFFIX = '.segment.rsc';
    const RSC_SUFFIX = '.rsc';
    const ACTION_SUFFIX = '.action';
    const NEXT_DATA_SUFFIX = '.json';
    const NEXT_META_SUFFIX = '.meta';
    const NEXT_BODY_SUFFIX = '.body';
    const NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags';
    const NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags';
    const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = 'x-next-revalidate-tag-token';
    const NEXT_RESUME_HEADER = 'next-resume';
    const NEXT_CACHE_TAG_MAX_ITEMS = 128;
    const NEXT_CACHE_TAG_MAX_LENGTH = 256;
    const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;
    const NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_';
    const CACHE_ONE_YEAR = 31536000;
    const INFINITE_CACHE = 0xfffffffe;
    const MIDDLEWARE_FILENAME = 'middleware';
    const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;
    const INSTRUMENTATION_HOOK_FILENAME = 'instrumentation';
    const PAGES_DIR_ALIAS = 'private-next-pages';
    const DOT_NEXT_ALIAS = 'private-dot-next';
    const ROOT_DIR_ALIAS = 'private-next-root-dir';
    const APP_DIR_ALIAS = 'private-next-app-dir';
    const RSC_MOD_REF_PROXY_ALIAS =
      'next/dist/build/webpack/loaders/next-flight-loader/module-proxy';
    const RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate';
    const RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference';
    const RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper';
    const RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption';
    const RSC_ACTION_CLIENT_WRAPPER_ALIAS = 'private-next-rsc-action-client-wrapper';
    const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;
    const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;
    const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;
    const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;
    const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;
    const SERVER_PROPS_EXPORT_ERROR = `pages with \`getServerSideProps\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;
    const GSP_NO_RETURNED_VALUE =
      'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?';
    const GSSP_NO_RETURNED_VALUE =
      'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?';
    const UNSTABLE_REVALIDATE_RENAME_ERROR =
      'The `unstable_revalidate` property is available for general use.\n' +
      'Please use `revalidate` instead.';
    const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;
    const NON_STANDARD_NODE_ENV = `You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;
    const SSG_FALLBACK_EXPORT_ERROR = `Pages with \`fallback\` enabled in \`getStaticPaths\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;
    const ESLINT_DEFAULT_DIRS = ['app', 'pages', 'components', 'lib', 'src'];
    const SERVER_RUNTIME = {
      edge: 'edge',
      experimentalEdge: 'experimental-edge',
      nodejs: 'nodejs',
    };
    /**
     * The names of the webpack layers. These layers are the primitives for the webpack
     * chunks.
     */ const WEBPACK_LAYERS_NAMES = {
      /** The layer for the shared code between the client and server bundles. */ shared:
        'shared',
      /**
       * The layer for server-only runtime and picking up `react-server` export conditions.
       * Including app router RSC pages and app router custom routes and metadata routes.
       */ reactServerComponents: 'rsc',
      /** Server Side Rendering layer for app (ssr). */ serverSideRendering: 'ssr',
      /** The browser client bundle layer for actions. */ actionBrowser: 'action-browser',
      /** The Node.js bundle layer for the API routes. */ apiNode: 'api-node',
      /** The Edge Lite bundle layer for the API routes. */ apiEdge: 'api-edge',
      /** The layer for the middleware code. */ middleware: 'middleware',
      /** The layer for the instrumentation hooks. */ instrument: 'instrument',
      /** The layer for assets on the edge. */ edgeAsset: 'edge-asset',
      /** The browser client bundle layer for App directory. */ appPagesBrowser:
        'app-pages-browser',
      /** The browser client bundle layer for Pages directory. */ pagesDirBrowser:
        'pages-dir-browser',
      /** The Edge Lite bundle layer for Pages directory. */ pagesDirEdge:
        'pages-dir-edge',
      /** The Node.js bundle layer for Pages directory. */ pagesDirNode: 'pages-dir-node',
    };
    const WEBPACK_LAYERS = {
      ...WEBPACK_LAYERS_NAMES,
      GROUP: {
        builtinReact: [
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.actionBrowser,
        ],
        serverOnly: [
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.actionBrowser,
          WEBPACK_LAYERS_NAMES.instrument,
          WEBPACK_LAYERS_NAMES.middleware,
        ],
        neutralTarget: [
          // pages api
          WEBPACK_LAYERS_NAMES.apiNode,
          WEBPACK_LAYERS_NAMES.apiEdge,
        ],
        clientOnly: [
          WEBPACK_LAYERS_NAMES.serverSideRendering,
          WEBPACK_LAYERS_NAMES.appPagesBrowser,
        ],
        bundled: [
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.actionBrowser,
          WEBPACK_LAYERS_NAMES.serverSideRendering,
          WEBPACK_LAYERS_NAMES.appPagesBrowser,
          WEBPACK_LAYERS_NAMES.shared,
          WEBPACK_LAYERS_NAMES.instrument,
          WEBPACK_LAYERS_NAMES.middleware,
        ],
        appPages: [
          // app router pages and layouts
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.serverSideRendering,
          WEBPACK_LAYERS_NAMES.appPagesBrowser,
          WEBPACK_LAYERS_NAMES.actionBrowser,
        ],
      },
    };
    const WEBPACK_RESOURCE_QUERIES = {
      edgeSSREntry: '__next_edge_ssr_entry__',
      metadata: '__next_metadata__',
      metadataRoute: '__next_metadata_route__',
      metadataImageMeta: '__next_metadata_image_meta__',
    };

    //# sourceMappingURL=constants.js.map
  },
  8308: function (__unused_webpack_module, exports) {
    'use strict';
    /**
     * A `Promise.withResolvers` implementation that exposes the `resolve` and `reject`
     * functions on a `Promise`.
     *
     * @see https://tc39.es/proposal-promise-with-resolvers/
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'DetachedPromise', {
      enumerable: true,
      get: function () {
        return DetachedPromise;
      },
    });
    class DetachedPromise {
      constructor() {
        let resolve;
        let reject;
        // Create the promise and assign the resolvers to the object.
        this.promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        // We know that resolvers is defined because the Promise constructor runs
        // synchronously.
        this.resolve = resolve;
        this.reject = reject;
      }
    }

    //# sourceMappingURL=detached-promise.js.map
  },
  9365: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      copyNextErrorCode: function () {
        return copyNextErrorCode;
      },
      createDigestWithErrorCode: function () {
        return createDigestWithErrorCode;
      },
      extractNextErrorCode: function () {
        return extractNextErrorCode;
      },
    });
    const ERROR_CODE_DELIMITER = '@';
    const createDigestWithErrorCode = (thrownValue, originalDigest) => {
      if (
        typeof thrownValue === 'object' &&
        thrownValue !== null &&
        '__NEXT_ERROR_CODE' in thrownValue
      ) {
        return `${originalDigest}${ERROR_CODE_DELIMITER}${thrownValue.__NEXT_ERROR_CODE}`;
      }
      return originalDigest;
    };
    const copyNextErrorCode = (source, target) => {
      const errorCode = extractNextErrorCode(source);
      if (errorCode && typeof target === 'object' && target !== null) {
        Object.defineProperty(target, '__NEXT_ERROR_CODE', {
          value: errorCode,
          enumerable: false,
          configurable: true,
        });
      }
    };
    const extractNextErrorCode = (error) => {
      if (
        typeof error === 'object' &&
        error !== null &&
        '__NEXT_ERROR_CODE' in error &&
        typeof error.__NEXT_ERROR_CODE === 'string'
      ) {
        return error.__NEXT_ERROR_CODE;
      }
      if (
        typeof error === 'object' &&
        error !== null &&
        'digest' in error &&
        typeof error.digest === 'string'
      ) {
        const segments = error.digest.split(ERROR_CODE_DELIMITER);
        const errorCode = segments.find((segment) => segment.startsWith('E'));
        return errorCode;
      }
      return undefined;
    };

    //# sourceMappingURL=error-telemetry-utils.js.map
  },
  9416: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      formatServerError: function () {
        return formatServerError;
      },
      getStackWithoutErrorMessage: function () {
        return getStackWithoutErrorMessage;
      },
    });
    const invalidServerComponentReactHooks = [
      'useDeferredValue',
      'useEffect',
      'useImperativeHandle',
      'useInsertionEffect',
      'useLayoutEffect',
      'useReducer',
      'useRef',
      'useState',
      'useSyncExternalStore',
      'useTransition',
      'experimental_useOptimistic',
      'useOptimistic',
    ];
    function setMessage(error, message) {
      error.message = message;
      if (error.stack) {
        const lines = error.stack.split('\n');
        lines[0] = message;
        error.stack = lines.join('\n');
      }
    }
    function getStackWithoutErrorMessage(error) {
      const stack = error.stack;
      if (!stack) return '';
      return stack.replace(/^[^\n]*\n/, '');
    }
    function formatServerError(error) {
      if (typeof (error == null ? void 0 : error.message) !== 'string') return;
      if (
        error.message.includes(
          'Class extends value undefined is not a constructor or null'
        )
      ) {
        const addedMessage =
          'This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component';
        // If this error instance already has the message, don't add it again
        if (error.message.includes(addedMessage)) return;
        setMessage(
          error,
          `${error.message}

${addedMessage}`
        );
        return;
      }
      if (error.message.includes('createContext is not a function')) {
        setMessage(
          error,
          'createContext only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component'
        );
        return;
      }
      for (const clientHook of invalidServerComponentReactHooks) {
        const regex = new RegExp(`\\b${clientHook}\\b.*is not a function`);
        if (regex.test(error.message)) {
          setMessage(
            error,
            `${clientHook} only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`
          );
          return;
        }
      }
    } //# sourceMappingURL=format-server-error.js.map
  },
  6374: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'interopDefault', {
      enumerable: true,
      get: function () {
        return interopDefault;
      },
    });
    function interopDefault(mod) {
      return mod.default || mod;
    }

    //# sourceMappingURL=interop-default.js.map
  },
  1506: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      /**
       * Checks whether the given value is a NextError. This can be used to print a more
       * detailed error message with properties like `code` & `digest`.
       */ default: function () {
        return isError;
      },
      getProperError: function () {
        return getProperError;
      },
    });
    const _isplainobject = __webpack_require__(6794);
    function isError(err) {
      return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;
    }
    function safeStringify(obj) {
      const seen = new WeakSet();
      return JSON.stringify(obj, (_key, value) => {
        // If value is an object and already seen, replace with "[Circular]"
        if (typeof value === 'object' && value !== null) {
          if (seen.has(value)) {
            return '[Circular]';
          }
          seen.add(value);
        }
        return value;
      });
    }
    function getProperError(err) {
      if (isError(err)) {
        return err;
      }
      if (true) {
        // provide better error for case where `throw undefined`
        // is called in development
        if (typeof err === 'undefined') {
          return Object.defineProperty(
            new Error(
              'An undefined error was thrown, ' +
                'see here for more info: https://nextjs.org/docs/messages/threw-undefined'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E98',
              enumerable: false,
              configurable: true,
            }
          );
        }
        if (err === null) {
          return Object.defineProperty(
            new Error(
              'A null error was thrown, ' +
                'see here for more info: https://nextjs.org/docs/messages/threw-undefined'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E336',
              enumerable: false,
              configurable: true,
            }
          );
        }
      }
      return Object.defineProperty(
        new Error((0, _isplainobject.isPlainObject)(err) ? safeStringify(err) : err + ''),
        '__NEXT_ERROR_CODE',
        {
          value: 'E394',
          enumerable: false,
          configurable: true,
        }
      );
    }

    //# sourceMappingURL=is-error.js.map
  },
  5659: function (__unused_webpack_module, exports) {
    'use strict';
    var __webpack_unused_export__;

    __webpack_unused_export__ = {
      value: true,
    };
    Object.defineProperty(exports, 'cloneMetadata', {
      enumerable: true,
      get: function () {
        return cloneMetadata;
      },
    });
    const TYPE_URL = '__METADATA_URL';
    function replacer(_key, val) {
      // clone URL as string but recover it as URL
      if (val instanceof URL) {
        return {
          _type: TYPE_URL,
          value: val.href,
        };
      }
      return val;
    }
    function reviver(_key, val) {
      if (typeof val === 'object' && val !== null && val._type === TYPE_URL) {
        return new URL(val.value);
      }
      return val;
    }
    function cloneMetadata(metadata) {
      const jsonString = JSON.stringify(metadata, replacer);
      return JSON.parse(jsonString, reviver);
    }

    //# sourceMappingURL=clone-metadata.js.map
  },
  4702: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      IconKeys: function () {
        return IconKeys;
      },
      ViewportMetaKeys: function () {
        return ViewportMetaKeys;
      },
    });
    const ViewportMetaKeys = {
      width: 'width',
      height: 'height',
      initialScale: 'initial-scale',
      minimumScale: 'minimum-scale',
      maximumScale: 'maximum-scale',
      viewportFit: 'viewport-fit',
      userScalable: 'user-scalable',
      interactiveWidget: 'interactive-widget',
    };
    const IconKeys = ['icon', 'shortcut', 'apple', 'other'];

    //# sourceMappingURL=constants.js.map
  },
  7057: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      createDefaultMetadata: function () {
        return createDefaultMetadata;
      },
      createDefaultViewport: function () {
        return createDefaultViewport;
      },
    });
    function createDefaultViewport() {
      return {
        // name=viewport
        width: 'device-width',
        initialScale: 1,
        // visual metadata
        themeColor: null,
        colorScheme: null,
      };
    }
    function createDefaultMetadata() {
      return {
        // Deprecated ones
        viewport: null,
        themeColor: null,
        colorScheme: null,
        metadataBase: null,
        // Other values are all null
        title: null,
        description: null,
        applicationName: null,
        authors: null,
        generator: null,
        keywords: null,
        referrer: null,
        creator: null,
        publisher: null,
        robots: null,
        manifest: null,
        alternates: {
          canonical: null,
          languages: null,
          media: null,
          types: null,
        },
        icons: null,
        openGraph: null,
        twitter: null,
        verification: {},
        appleWebApp: null,
        formatDetection: null,
        itunes: null,
        facebook: null,
        pinterest: null,
        abstract: null,
        appLinks: null,
        archives: null,
        assets: null,
        bookmarks: null,
        category: null,
        classification: null,
        pagination: {
          previous: null,
          next: null,
        },
        other: {},
      };
    }

    //# sourceMappingURL=default-metadata.js.map
  },
  7012: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'AlternatesMetadata', {
      enumerable: true,
      get: function () {
        return AlternatesMetadata;
      },
    });
    const _jsxruntime = __webpack_require__(9133);
    const _react = /*#__PURE__*/ _interop_require_default(__webpack_require__(8516));
    const _meta = __webpack_require__(3971);
    function _interop_require_default(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }
    function AlternateLink({ descriptor, ...props }) {
      if (!descriptor.url) return null;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
        ...props,
        ...(descriptor.title && {
          title: descriptor.title,
        }),
        href: descriptor.url.toString(),
      });
    }
    function AlternatesMetadata({ alternates }) {
      if (!alternates) return null;
      const { canonical, languages, media, types } = alternates;
      return (0, _meta.MetaFilter)([
        canonical
          ? AlternateLink({
              rel: 'canonical',
              descriptor: canonical,
            })
          : null,
        languages
          ? Object.entries(languages).flatMap(([locale, descriptors]) =>
              descriptors == null
                ? void 0
                : descriptors.map((descriptor) =>
                    AlternateLink({
                      rel: 'alternate',
                      hrefLang: locale,
                      descriptor,
                    })
                  )
            )
          : null,
        media
          ? Object.entries(media).flatMap(([mediaName, descriptors]) =>
              descriptors == null
                ? void 0
                : descriptors.map((descriptor) =>
                    AlternateLink({
                      rel: 'alternate',
                      media: mediaName,
                      descriptor,
                    })
                  )
            )
          : null,
        types
          ? Object.entries(types).flatMap(([type, descriptors]) =>
              descriptors == null
                ? void 0
                : descriptors.map((descriptor) =>
                    AlternateLink({
                      rel: 'alternate',
                      type,
                      descriptor,
                    })
                  )
            )
          : null,
      ]);
    }

    //# sourceMappingURL=alternate.js.map
  },
  5226: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      AppleWebAppMeta: function () {
        return AppleWebAppMeta;
      },
      BasicMeta: function () {
        return BasicMeta;
      },
      FacebookMeta: function () {
        return FacebookMeta;
      },
      FormatDetectionMeta: function () {
        return FormatDetectionMeta;
      },
      ItunesMeta: function () {
        return ItunesMeta;
      },
      PinterestMeta: function () {
        return PinterestMeta;
      },
      VerificationMeta: function () {
        return VerificationMeta;
      },
      ViewportMeta: function () {
        return ViewportMeta;
      },
    });
    const _jsxruntime = __webpack_require__(9133);
    const _meta = __webpack_require__(3971);
    const _constants = __webpack_require__(4702);
    const _utils = __webpack_require__(327);
    // convert viewport object to string for viewport meta tag
    function resolveViewportLayout(viewport) {
      let resolved = null;
      if (viewport && typeof viewport === 'object') {
        resolved = '';
        for (const viewportKey_ in _constants.ViewportMetaKeys) {
          const viewportKey = viewportKey_;
          if (viewportKey in viewport) {
            let value = viewport[viewportKey];
            if (typeof value === 'boolean') {
              value = value ? 'yes' : 'no';
            } else if (!value && viewportKey === 'initialScale') {
              value = undefined;
            }
            if (value) {
              if (resolved) resolved += ', ';
              resolved += `${_constants.ViewportMetaKeys[viewportKey]}=${value}`;
            }
          }
        }
      }
      return resolved;
    }
    function ViewportMeta({ viewport }) {
      return (0, _meta.MetaFilter)([
        /*#__PURE__*/ (0, _jsxruntime.jsx)('meta', {
          charSet: 'utf-8',
        }),
        (0, _meta.Meta)({
          name: 'viewport',
          content: resolveViewportLayout(viewport),
        }),
        ...(viewport.themeColor
          ? viewport.themeColor.map((themeColor) =>
              (0, _meta.Meta)({
                name: 'theme-color',
                content: themeColor.color,
                media: themeColor.media,
              })
            )
          : []),
        (0, _meta.Meta)({
          name: 'color-scheme',
          content: viewport.colorScheme,
        }),
      ]);
    }
    function BasicMeta({ metadata }) {
      var _metadata_keywords, _metadata_robots, _metadata_robots1;
      const manifestOrigin = metadata.manifest
        ? (0, _utils.getOrigin)(metadata.manifest)
        : undefined;
      return (0, _meta.MetaFilter)([
        metadata.title !== null && metadata.title.absolute
          ? /*#__PURE__*/ (0, _jsxruntime.jsx)('title', {
              children: metadata.title.absolute,
            })
          : null,
        (0, _meta.Meta)({
          name: 'description',
          content: metadata.description,
        }),
        (0, _meta.Meta)({
          name: 'application-name',
          content: metadata.applicationName,
        }),
        ...(metadata.authors
          ? metadata.authors.map((author) => [
              author.url
                ? /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
                    rel: 'author',
                    href: author.url.toString(),
                  })
                : null,
              (0, _meta.Meta)({
                name: 'author',
                content: author.name,
              }),
            ])
          : []),
        metadata.manifest
          ? /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
              rel: 'manifest',
              href: metadata.manifest.toString(),
              // If it's same origin, and it's a preview deployment,
              // including credentials for manifest request.
              crossOrigin:
                !manifestOrigin && process.env.VERCEL_ENV === 'preview'
                  ? 'use-credentials'
                  : undefined,
            })
          : null,
        (0, _meta.Meta)({
          name: 'generator',
          content: metadata.generator,
        }),
        (0, _meta.Meta)({
          name: 'keywords',
          content:
            (_metadata_keywords = metadata.keywords) == null
              ? void 0
              : _metadata_keywords.join(','),
        }),
        (0, _meta.Meta)({
          name: 'referrer',
          content: metadata.referrer,
        }),
        (0, _meta.Meta)({
          name: 'creator',
          content: metadata.creator,
        }),
        (0, _meta.Meta)({
          name: 'publisher',
          content: metadata.publisher,
        }),
        (0, _meta.Meta)({
          name: 'robots',
          content:
            (_metadata_robots = metadata.robots) == null
              ? void 0
              : _metadata_robots.basic,
        }),
        (0, _meta.Meta)({
          name: 'googlebot',
          content:
            (_metadata_robots1 = metadata.robots) == null
              ? void 0
              : _metadata_robots1.googleBot,
        }),
        (0, _meta.Meta)({
          name: 'abstract',
          content: metadata.abstract,
        }),
        ...(metadata.archives
          ? metadata.archives.map((archive) =>
              /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
                rel: 'archives',
                href: archive,
              })
            )
          : []),
        ...(metadata.assets
          ? metadata.assets.map((asset) =>
              /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
                rel: 'assets',
                href: asset,
              })
            )
          : []),
        ...(metadata.bookmarks
          ? metadata.bookmarks.map((bookmark) =>
              /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
                rel: 'bookmarks',
                href: bookmark,
              })
            )
          : []),
        ...(metadata.pagination
          ? [
              metadata.pagination.previous
                ? /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
                    rel: 'prev',
                    href: metadata.pagination.previous,
                  })
                : null,
              metadata.pagination.next
                ? /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
                    rel: 'next',
                    href: metadata.pagination.next,
                  })
                : null,
            ]
          : []),
        (0, _meta.Meta)({
          name: 'category',
          content: metadata.category,
        }),
        (0, _meta.Meta)({
          name: 'classification',
          content: metadata.classification,
        }),
        ...(metadata.other
          ? Object.entries(metadata.other).map(([name, content]) => {
              if (Array.isArray(content)) {
                return content.map((contentItem) =>
                  (0, _meta.Meta)({
                    name,
                    content: contentItem,
                  })
                );
              } else {
                return (0, _meta.Meta)({
                  name,
                  content,
                });
              }
            })
          : []),
      ]);
    }
    function ItunesMeta({ itunes }) {
      if (!itunes) return null;
      const { appId, appArgument } = itunes;
      let content = `app-id=${appId}`;
      if (appArgument) {
        content += `, app-argument=${appArgument}`;
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('meta', {
        name: 'apple-itunes-app',
        content: content,
      });
    }
    function FacebookMeta({ facebook }) {
      if (!facebook) return null;
      const { appId, admins } = facebook;
      return (0, _meta.MetaFilter)([
        appId
          ? /*#__PURE__*/ (0, _jsxruntime.jsx)('meta', {
              property: 'fb:app_id',
              content: appId,
            })
          : null,
        ...(admins
          ? admins.map((admin) =>
              /*#__PURE__*/ (0, _jsxruntime.jsx)('meta', {
                property: 'fb:admins',
                content: admin,
              })
            )
          : []),
      ]);
    }
    function PinterestMeta({ pinterest }) {
      if (!pinterest || !pinterest.richPin) return null;
      const { richPin } = pinterest;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('meta', {
        property: 'pinterest-rich-pin',
        content: richPin.toString(),
      });
    }
    const formatDetectionKeys = ['telephone', 'date', 'address', 'email', 'url'];
    function FormatDetectionMeta({ formatDetection }) {
      if (!formatDetection) return null;
      let content = '';
      for (const key of formatDetectionKeys) {
        if (key in formatDetection) {
          if (content) content += ', ';
          content += `${key}=no`;
        }
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('meta', {
        name: 'format-detection',
        content: content,
      });
    }
    function AppleWebAppMeta({ appleWebApp }) {
      if (!appleWebApp) return null;
      const { capable, title, startupImage, statusBarStyle } = appleWebApp;
      return (0, _meta.MetaFilter)([
        capable
          ? (0, _meta.Meta)({
              name: 'mobile-web-app-capable',
              content: 'yes',
            })
          : null,
        (0, _meta.Meta)({
          name: 'apple-mobile-web-app-title',
          content: title,
        }),
        startupImage
          ? startupImage.map((image) =>
              /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
                href: image.url,
                media: image.media,
                rel: 'apple-touch-startup-image',
              })
            )
          : null,
        statusBarStyle
          ? (0, _meta.Meta)({
              name: 'apple-mobile-web-app-status-bar-style',
              content: statusBarStyle,
            })
          : null,
      ]);
    }
    function VerificationMeta({ verification }) {
      if (!verification) return null;
      return (0, _meta.MetaFilter)([
        (0, _meta.MultiMeta)({
          namePrefix: 'google-site-verification',
          contents: verification.google,
        }),
        (0, _meta.MultiMeta)({
          namePrefix: 'y_key',
          contents: verification.yahoo,
        }),
        (0, _meta.MultiMeta)({
          namePrefix: 'yandex-verification',
          contents: verification.yandex,
        }),
        (0, _meta.MultiMeta)({
          namePrefix: 'me',
          contents: verification.me,
        }),
        ...(verification.other
          ? Object.entries(verification.other).map(([key, value]) =>
              (0, _meta.MultiMeta)({
                namePrefix: key,
                contents: value,
              })
            )
          : []),
      ]);
    }

    //# sourceMappingURL=basic.js.map
  },
  3054: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'IconsMetadata', {
      enumerable: true,
      get: function () {
        return IconsMetadata;
      },
    });
    const _jsxruntime = __webpack_require__(9133);
    const _meta = __webpack_require__(3971);
    function IconDescriptorLink({ icon }) {
      const { url, rel = 'icon', ...props } = icon;
      return /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
        rel: rel,
        href: url.toString(),
        ...props,
      });
    }
    function IconLink({ rel, icon }) {
      if (typeof icon === 'object' && !(icon instanceof URL)) {
        if (!icon.rel && rel) icon.rel = rel;
        return IconDescriptorLink({
          icon,
        });
      } else {
        const href = icon.toString();
        return /*#__PURE__*/ (0, _jsxruntime.jsx)('link', {
          rel: rel,
          href: href,
        });
      }
    }
    function IconsMetadata({ icons }) {
      if (!icons) return null;
      const shortcutList = icons.shortcut;
      const iconList = icons.icon;
      const appleList = icons.apple;
      const otherList = icons.other;
      return (0, _meta.MetaFilter)([
        shortcutList
          ? shortcutList.map((icon) =>
              IconLink({
                rel: 'shortcut icon',
                icon,
              })
            )
          : null,
        iconList
          ? iconList.map((icon) =>
              IconLink({
                rel: 'icon',
                icon,
              })
            )
          : null,
        appleList
          ? appleList.map((icon) =>
              IconLink({
                rel: 'apple-touch-icon',
                icon,
              })
            )
          : null,
        otherList
          ? otherList.map((icon) =>
              IconDescriptorLink({
                icon,
              })
            )
          : null,
      ]);
    }

    //# sourceMappingURL=icons.js.map
  },
  3971: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      Meta: function () {
        return Meta;
      },
      MetaFilter: function () {
        return MetaFilter;
      },
      MultiMeta: function () {
        return MultiMeta;
      },
    });
    const _jsxruntime = __webpack_require__(9133);
    const _react = /*#__PURE__*/ _interop_require_default(__webpack_require__(8516));
    const _nonnullable = __webpack_require__(3892);
    function _interop_require_default(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }
    function Meta({ name, property, content, media }) {
      if (typeof content !== 'undefined' && content !== null && content !== '') {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)('meta', {
          ...(name
            ? {
                name,
              }
            : {
                property,
              }),
          ...(media
            ? {
                media,
              }
            : undefined),
          content: typeof content === 'string' ? content : content.toString(),
        });
      }
      return null;
    }
    function MetaFilter(items) {
      const acc = [];
      for (const item of items) {
        if (Array.isArray(item)) {
          acc.push(...item.filter(_nonnullable.nonNullable));
        } else if ((0, _nonnullable.nonNullable)(item)) {
          acc.push(item);
        }
      }
      return acc;
    }
    function camelToSnake(camelCaseStr) {
      return camelCaseStr.replace(/([A-Z])/g, function (match) {
        return '_' + match.toLowerCase();
      });
    }
    const aliasPropPrefixes = new Set([
      'og:image',
      'twitter:image',
      'og:video',
      'og:audio',
    ]);
    function getMetaKey(prefix, key) {
      // Use `twitter:image` and `og:image` instead of `twitter:image:url` and `og:image:url`
      // to be more compatible as it's a more common format.
      // `og:video` & `og:audio` do not have a `:url` suffix alias
      if (aliasPropPrefixes.has(prefix) && key === 'url') {
        return prefix;
      }
      if (prefix.startsWith('og:') || prefix.startsWith('twitter:')) {
        key = camelToSnake(key);
      }
      return prefix + ':' + key;
    }
    function ExtendMeta({ content, namePrefix, propertyPrefix }) {
      if (!content) return null;
      return MetaFilter(
        Object.entries(content).map(([k, v]) => {
          return typeof v === 'undefined'
            ? null
            : Meta({
                ...(propertyPrefix && {
                  property: getMetaKey(propertyPrefix, k),
                }),
                ...(namePrefix && {
                  name: getMetaKey(namePrefix, k),
                }),
                content: typeof v === 'string' ? v : v == null ? void 0 : v.toString(),
              });
        })
      );
    }
    function MultiMeta({ propertyPrefix, namePrefix, contents }) {
      if (typeof contents === 'undefined' || contents === null) {
        return null;
      }
      return MetaFilter(
        contents.map((content) => {
          if (
            typeof content === 'string' ||
            typeof content === 'number' ||
            content instanceof URL
          ) {
            return Meta({
              ...(propertyPrefix
                ? {
                    property: propertyPrefix,
                  }
                : {
                    name: namePrefix,
                  }),
              content,
            });
          } else {
            return ExtendMeta({
              namePrefix,
              propertyPrefix,
              content,
            });
          }
        })
      );
    }

    //# sourceMappingURL=meta.js.map
  },
  2619: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      AppLinksMeta: function () {
        return AppLinksMeta;
      },
      OpenGraphMetadata: function () {
        return OpenGraphMetadata;
      },
      TwitterMetadata: function () {
        return TwitterMetadata;
      },
    });
    const _meta = __webpack_require__(3971);
    function OpenGraphMetadata({ openGraph }) {
      var _openGraph_title, _openGraph_url, _openGraph_ttl;
      if (!openGraph) {
        return null;
      }
      let typedOpenGraph;
      if ('type' in openGraph) {
        const openGraphType = openGraph.type;
        switch (openGraphType) {
          case 'website':
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'website',
              }),
            ];
            break;
          case 'article':
            var _openGraph_publishedTime,
              _openGraph_modifiedTime,
              _openGraph_expirationTime;
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'article',
              }),
              (0, _meta.Meta)({
                property: 'article:published_time',
                content:
                  (_openGraph_publishedTime = openGraph.publishedTime) == null
                    ? void 0
                    : _openGraph_publishedTime.toString(),
              }),
              (0, _meta.Meta)({
                property: 'article:modified_time',
                content:
                  (_openGraph_modifiedTime = openGraph.modifiedTime) == null
                    ? void 0
                    : _openGraph_modifiedTime.toString(),
              }),
              (0, _meta.Meta)({
                property: 'article:expiration_time',
                content:
                  (_openGraph_expirationTime = openGraph.expirationTime) == null
                    ? void 0
                    : _openGraph_expirationTime.toString(),
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'article:author',
                contents: openGraph.authors,
              }),
              (0, _meta.Meta)({
                property: 'article:section',
                content: openGraph.section,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'article:tag',
                contents: openGraph.tags,
              }),
            ];
            break;
          case 'book':
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'book',
              }),
              (0, _meta.Meta)({
                property: 'book:isbn',
                content: openGraph.isbn,
              }),
              (0, _meta.Meta)({
                property: 'book:release_date',
                content: openGraph.releaseDate,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'book:author',
                contents: openGraph.authors,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'book:tag',
                contents: openGraph.tags,
              }),
            ];
            break;
          case 'profile':
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'profile',
              }),
              (0, _meta.Meta)({
                property: 'profile:first_name',
                content: openGraph.firstName,
              }),
              (0, _meta.Meta)({
                property: 'profile:last_name',
                content: openGraph.lastName,
              }),
              (0, _meta.Meta)({
                property: 'profile:username',
                content: openGraph.username,
              }),
              (0, _meta.Meta)({
                property: 'profile:gender',
                content: openGraph.gender,
              }),
            ];
            break;
          case 'music.song':
            var _openGraph_duration;
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'music.song',
              }),
              (0, _meta.Meta)({
                property: 'music:duration',
                content:
                  (_openGraph_duration = openGraph.duration) == null
                    ? void 0
                    : _openGraph_duration.toString(),
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'music:album',
                contents: openGraph.albums,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'music:musician',
                contents: openGraph.musicians,
              }),
            ];
            break;
          case 'music.album':
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'music.album',
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'music:song',
                contents: openGraph.songs,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'music:musician',
                contents: openGraph.musicians,
              }),
              (0, _meta.Meta)({
                property: 'music:release_date',
                content: openGraph.releaseDate,
              }),
            ];
            break;
          case 'music.playlist':
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'music.playlist',
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'music:song',
                contents: openGraph.songs,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'music:creator',
                contents: openGraph.creators,
              }),
            ];
            break;
          case 'music.radio_station':
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'music.radio_station',
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'music:creator',
                contents: openGraph.creators,
              }),
            ];
            break;
          case 'video.movie':
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'video.movie',
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'video:actor',
                contents: openGraph.actors,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'video:director',
                contents: openGraph.directors,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'video:writer',
                contents: openGraph.writers,
              }),
              (0, _meta.Meta)({
                property: 'video:duration',
                content: openGraph.duration,
              }),
              (0, _meta.Meta)({
                property: 'video:release_date',
                content: openGraph.releaseDate,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'video:tag',
                contents: openGraph.tags,
              }),
            ];
            break;
          case 'video.episode':
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'video.episode',
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'video:actor',
                contents: openGraph.actors,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'video:director',
                contents: openGraph.directors,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'video:writer',
                contents: openGraph.writers,
              }),
              (0, _meta.Meta)({
                property: 'video:duration',
                content: openGraph.duration,
              }),
              (0, _meta.Meta)({
                property: 'video:release_date',
                content: openGraph.releaseDate,
              }),
              (0, _meta.MultiMeta)({
                propertyPrefix: 'video:tag',
                contents: openGraph.tags,
              }),
              (0, _meta.Meta)({
                property: 'video:series',
                content: openGraph.series,
              }),
            ];
            break;
          case 'video.tv_show':
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'video.tv_show',
              }),
            ];
            break;
          case 'video.other':
            typedOpenGraph = [
              (0, _meta.Meta)({
                property: 'og:type',
                content: 'video.other',
              }),
            ];
            break;
          default:
            const _exhaustiveCheck = openGraphType;
            throw Object.defineProperty(
              new Error(`Invalid OpenGraph type: ${_exhaustiveCheck}`),
              '__NEXT_ERROR_CODE',
              {
                value: 'E237',
                enumerable: false,
                configurable: true,
              }
            );
        }
      }
      return (0, _meta.MetaFilter)([
        (0, _meta.Meta)({
          property: 'og:determiner',
          content: openGraph.determiner,
        }),
        (0, _meta.Meta)({
          property: 'og:title',
          content:
            (_openGraph_title = openGraph.title) == null
              ? void 0
              : _openGraph_title.absolute,
        }),
        (0, _meta.Meta)({
          property: 'og:description',
          content: openGraph.description,
        }),
        (0, _meta.Meta)({
          property: 'og:url',
          content:
            (_openGraph_url = openGraph.url) == null ? void 0 : _openGraph_url.toString(),
        }),
        (0, _meta.Meta)({
          property: 'og:site_name',
          content: openGraph.siteName,
        }),
        (0, _meta.Meta)({
          property: 'og:locale',
          content: openGraph.locale,
        }),
        (0, _meta.Meta)({
          property: 'og:country_name',
          content: openGraph.countryName,
        }),
        (0, _meta.Meta)({
          property: 'og:ttl',
          content:
            (_openGraph_ttl = openGraph.ttl) == null ? void 0 : _openGraph_ttl.toString(),
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'og:image',
          contents: openGraph.images,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'og:video',
          contents: openGraph.videos,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'og:audio',
          contents: openGraph.audio,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'og:email',
          contents: openGraph.emails,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'og:phone_number',
          contents: openGraph.phoneNumbers,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'og:fax_number',
          contents: openGraph.faxNumbers,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'og:locale:alternate',
          contents: openGraph.alternateLocale,
        }),
        ...(typedOpenGraph ? typedOpenGraph : []),
      ]);
    }
    function TwitterAppItem({ app, type }) {
      var _app_url_type, _app_url;
      return [
        (0, _meta.Meta)({
          name: `twitter:app:name:${type}`,
          content: app.name,
        }),
        (0, _meta.Meta)({
          name: `twitter:app:id:${type}`,
          content: app.id[type],
        }),
        (0, _meta.Meta)({
          name: `twitter:app:url:${type}`,
          content:
            (_app_url = app.url) == null
              ? void 0
              : (_app_url_type = _app_url[type]) == null
                ? void 0
                : _app_url_type.toString(),
        }),
      ];
    }
    function TwitterMetadata({ twitter }) {
      var _twitter_title;
      if (!twitter) return null;
      const { card } = twitter;
      return (0, _meta.MetaFilter)([
        (0, _meta.Meta)({
          name: 'twitter:card',
          content: card,
        }),
        (0, _meta.Meta)({
          name: 'twitter:site',
          content: twitter.site,
        }),
        (0, _meta.Meta)({
          name: 'twitter:site:id',
          content: twitter.siteId,
        }),
        (0, _meta.Meta)({
          name: 'twitter:creator',
          content: twitter.creator,
        }),
        (0, _meta.Meta)({
          name: 'twitter:creator:id',
          content: twitter.creatorId,
        }),
        (0, _meta.Meta)({
          name: 'twitter:title',
          content:
            (_twitter_title = twitter.title) == null ? void 0 : _twitter_title.absolute,
        }),
        (0, _meta.Meta)({
          name: 'twitter:description',
          content: twitter.description,
        }),
        (0, _meta.MultiMeta)({
          namePrefix: 'twitter:image',
          contents: twitter.images,
        }),
        ...(card === 'player'
          ? twitter.players.flatMap((player) => [
              (0, _meta.Meta)({
                name: 'twitter:player',
                content: player.playerUrl.toString(),
              }),
              (0, _meta.Meta)({
                name: 'twitter:player:stream',
                content: player.streamUrl.toString(),
              }),
              (0, _meta.Meta)({
                name: 'twitter:player:width',
                content: player.width,
              }),
              (0, _meta.Meta)({
                name: 'twitter:player:height',
                content: player.height,
              }),
            ])
          : []),
        ...(card === 'app'
          ? [
              TwitterAppItem({
                app: twitter.app,
                type: 'iphone',
              }),
              TwitterAppItem({
                app: twitter.app,
                type: 'ipad',
              }),
              TwitterAppItem({
                app: twitter.app,
                type: 'googleplay',
              }),
            ]
          : []),
      ]);
    }
    function AppLinksMeta({ appLinks }) {
      if (!appLinks) return null;
      return (0, _meta.MetaFilter)([
        (0, _meta.MultiMeta)({
          propertyPrefix: 'al:ios',
          contents: appLinks.ios,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'al:iphone',
          contents: appLinks.iphone,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'al:ipad',
          contents: appLinks.ipad,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'al:android',
          contents: appLinks.android,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'al:windows_phone',
          contents: appLinks.windows_phone,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'al:windows',
          contents: appLinks.windows,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'al:windows_universal',
          contents: appLinks.windows_universal,
        }),
        (0, _meta.MultiMeta)({
          propertyPrefix: 'al:web',
          contents: appLinks.web,
        }),
      ]);
    }

    //# sourceMappingURL=opengraph.js.map
  },
  327: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getOrigin: function () {
        return getOrigin;
      },
      resolveArray: function () {
        return resolveArray;
      },
      resolveAsArrayOrUndefined: function () {
        return resolveAsArrayOrUndefined;
      },
    });
    function resolveArray(value) {
      if (Array.isArray(value)) {
        return value;
      }
      return [value];
    }
    function resolveAsArrayOrUndefined(value) {
      if (typeof value === 'undefined' || value === null) {
        return undefined;
      }
      return resolveArray(value);
    }
    function getOrigin(url) {
      let origin = undefined;
      if (typeof url === 'string') {
        try {
          url = new URL(url);
          origin = url.origin;
        } catch {}
      }
      return origin;
    }

    //# sourceMappingURL=utils.js.map
  },
  3288: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      METADATA_BOUNDARY_NAME: function () {
        return METADATA_BOUNDARY_NAME;
      },
      OUTLET_BOUNDARY_NAME: function () {
        return OUTLET_BOUNDARY_NAME;
      },
      VIEWPORT_BOUNDARY_NAME: function () {
        return VIEWPORT_BOUNDARY_NAME;
      },
    });
    const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';
    const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';
    const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__';

    //# sourceMappingURL=metadata-constants.js.map
  },
  9497: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'createMetadataComponents', {
      enumerable: true,
      get: function () {
        return createMetadataComponents;
      },
    });
    const _jsxruntime = __webpack_require__(9133);
    const _react = /*#__PURE__*/ _interop_require_wildcard(__webpack_require__(8516));
    const _basic = __webpack_require__(5226);
    const _alternate = __webpack_require__(7012);
    const _opengraph = __webpack_require__(2619);
    const _icons = __webpack_require__(3054);
    const _resolvemetadata = __webpack_require__(3769);
    const _meta = __webpack_require__(3971);
    const _httpaccessfallback = __webpack_require__(6750);
    const _metadataconstants = __webpack_require__(3288);
    const _asyncmetadata = __webpack_require__(7158);
    const _ispostpone = __webpack_require__(5480);
    const _searchparams = __webpack_require__(1611);
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== 'function') return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function (nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
        return {
          default: obj,
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null,
      };
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function createMetadataComponents({
      tree,
      parsedQuery,
      metadataContext,
      getDynamicParamFromSegment,
      appUsingSizeAdjustment,
      errorType,
      workStore,
      MetadataBoundary,
      ViewportBoundary,
      serveStreamingMetadata,
    }) {
      const searchParams = (0, _searchparams.createServerSearchParamsForMetadata)(
        parsedQuery,
        workStore
      );
      function ViewportTree() {
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
          children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(ViewportBoundary, {
              children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Viewport, {}),
            }),
            appUsingSizeAdjustment
              ? /*#__PURE__*/ (0, _jsxruntime.jsx)('meta', {
                  name: 'next-size-adjust',
                  content: '',
                })
              : null,
          ],
        });
      }
      function MetadataTree() {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(MetadataBoundary, {
          children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Metadata, {}),
        });
      }
      function viewport() {
        return getResolvedViewport(
          tree,
          searchParams,
          getDynamicParamFromSegment,
          workStore,
          errorType
        );
      }
      async function Viewport() {
        try {
          return await viewport();
        } catch (error) {
          if (!errorType && (0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {
            try {
              return await getNotFoundViewport(
                tree,
                searchParams,
                getDynamicParamFromSegment,
                workStore
              );
            } catch {}
          }
          // We don't actually want to error in this component. We will
          // also error in the MetadataOutlet which causes the error to
          // bubble from the right position in the page to be caught by the
          // appropriate boundaries
          return null;
        }
      }
      Viewport.displayName = _metadataconstants.VIEWPORT_BOUNDARY_NAME;
      function metadata() {
        return getResolvedMetadata(
          tree,
          searchParams,
          getDynamicParamFromSegment,
          metadataContext,
          workStore,
          errorType
        );
      }
      async function resolveFinalMetadata() {
        let result;
        let error = null;
        try {
          result = await metadata();
          return {
            metadata: result,
            error: null,
            digest: undefined,
          };
        } catch (metadataErr) {
          error = metadataErr;
          if (
            !errorType &&
            (0, _httpaccessfallback.isHTTPAccessFallbackError)(metadataErr)
          ) {
            try {
              result = await getNotFoundMetadata(
                tree,
                searchParams,
                getDynamicParamFromSegment,
                metadataContext,
                workStore
              );
              return {
                metadata: result,
                error,
                digest: error == null ? void 0 : error.digest,
              };
            } catch (notFoundMetadataErr) {
              error = notFoundMetadataErr;
              // In PPR rendering we still need to throw the postpone error.
              // If metadata is postponed, React needs to be aware of the location of error.
              if (
                serveStreamingMetadata &&
                (0, _ispostpone.isPostpone)(notFoundMetadataErr)
              ) {
                throw notFoundMetadataErr;
              }
            }
          }
          // In PPR rendering we still need to throw the postpone error.
          // If metadata is postponed, React needs to be aware of the location of error.
          if (serveStreamingMetadata && (0, _ispostpone.isPostpone)(metadataErr)) {
            throw metadataErr;
          }
          // We don't actually want to error in this component. We will
          // also error in the MetadataOutlet which causes the error to
          // bubble from the right position in the page to be caught by the
          // appropriate boundaries
          return {
            metadata: result,
            error,
            digest: error == null ? void 0 : error.digest,
          };
        }
      }
      async function Metadata() {
        const promise = resolveFinalMetadata();
        if (serveStreamingMetadata) {
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {
            fallback: null,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_asyncmetadata.AsyncMetadata, {
              promise: promise,
            }),
          });
        }
        const metadataState = await promise;
        return metadataState.metadata;
      }
      Metadata.displayName = _metadataconstants.METADATA_BOUNDARY_NAME;
      async function getMetadataReady() {
        // Only warm up metadata() call when it's blocking metadata,
        // otherwise it will be fully managed by AsyncMetadata component.
        if (!serveStreamingMetadata) {
          await metadata();
        }
        return undefined;
      }
      async function getViewportReady() {
        await viewport();
        return undefined;
      }
      function StreamingMetadataOutlet() {
        if (serveStreamingMetadata) {
          return /*#__PURE__*/ (0, _jsxruntime.jsx)(_asyncmetadata.AsyncMetadataOutlet, {
            promise: resolveFinalMetadata(),
          });
        }
        return null;
      }
      return {
        ViewportTree,
        MetadataTree,
        getViewportReady,
        getMetadataReady,
        StreamingMetadataOutlet,
      };
    }
    const getResolvedMetadata = (0, _react.cache)(getResolvedMetadataImpl);
    async function getResolvedMetadataImpl(
      tree,
      searchParams,
      getDynamicParamFromSegment,
      metadataContext,
      workStore,
      errorType
    ) {
      const errorConvention = errorType === 'redirect' ? undefined : errorType;
      return renderMetadata(
        tree,
        searchParams,
        getDynamicParamFromSegment,
        metadataContext,
        workStore,
        errorConvention
      );
    }
    const getNotFoundMetadata = (0, _react.cache)(getNotFoundMetadataImpl);
    async function getNotFoundMetadataImpl(
      tree,
      searchParams,
      getDynamicParamFromSegment,
      metadataContext,
      workStore
    ) {
      const notFoundErrorConvention = 'not-found';
      return renderMetadata(
        tree,
        searchParams,
        getDynamicParamFromSegment,
        metadataContext,
        workStore,
        notFoundErrorConvention
      );
    }
    const getResolvedViewport = (0, _react.cache)(getResolvedViewportImpl);
    async function getResolvedViewportImpl(
      tree,
      searchParams,
      getDynamicParamFromSegment,
      workStore,
      errorType
    ) {
      const errorConvention = errorType === 'redirect' ? undefined : errorType;
      return renderViewport(
        tree,
        searchParams,
        getDynamicParamFromSegment,
        workStore,
        errorConvention
      );
    }
    const getNotFoundViewport = (0, _react.cache)(getNotFoundViewportImpl);
    async function getNotFoundViewportImpl(
      tree,
      searchParams,
      getDynamicParamFromSegment,
      workStore
    ) {
      const notFoundErrorConvention = 'not-found';
      return renderViewport(
        tree,
        searchParams,
        getDynamicParamFromSegment,
        workStore,
        notFoundErrorConvention
      );
    }
    async function renderMetadata(
      tree,
      searchParams,
      getDynamicParamFromSegment,
      metadataContext,
      workStore,
      errorConvention
    ) {
      const resolvedMetadata = await (0, _resolvemetadata.resolveMetadata)(
        tree,
        searchParams,
        errorConvention,
        getDynamicParamFromSegment,
        workStore,
        metadataContext
      );
      const elements = createMetadataElements(resolvedMetadata);
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: elements.map((el, index) => {
          return /*#__PURE__*/ (0, _react.cloneElement)(el, {
            key: index,
          });
        }),
      });
    }
    async function renderViewport(
      tree,
      searchParams,
      getDynamicParamFromSegment,
      workStore,
      errorConvention
    ) {
      const resolvedViewport = await (0, _resolvemetadata.resolveViewport)(
        tree,
        searchParams,
        errorConvention,
        getDynamicParamFromSegment,
        workStore
      );
      const elements = createViewportElements(resolvedViewport);
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: elements.map((el, index) => {
          return /*#__PURE__*/ (0, _react.cloneElement)(el, {
            key: index,
          });
        }),
      });
    }
    function createMetadataElements(metadata) {
      return (0, _meta.MetaFilter)([
        (0, _basic.BasicMeta)({
          metadata,
        }),
        (0, _alternate.AlternatesMetadata)({
          alternates: metadata.alternates,
        }),
        (0, _basic.ItunesMeta)({
          itunes: metadata.itunes,
        }),
        (0, _basic.FacebookMeta)({
          facebook: metadata.facebook,
        }),
        (0, _basic.PinterestMeta)({
          pinterest: metadata.pinterest,
        }),
        (0, _basic.FormatDetectionMeta)({
          formatDetection: metadata.formatDetection,
        }),
        (0, _basic.VerificationMeta)({
          verification: metadata.verification,
        }),
        (0, _basic.AppleWebAppMeta)({
          appleWebApp: metadata.appleWebApp,
        }),
        (0, _opengraph.OpenGraphMetadata)({
          openGraph: metadata.openGraph,
        }),
        (0, _opengraph.TwitterMetadata)({
          twitter: metadata.twitter,
        }),
        (0, _opengraph.AppLinksMeta)({
          appLinks: metadata.appLinks,
        }),
        (0, _icons.IconsMetadata)({
          icons: metadata.icons,
        }),
      ]);
    }
    function createViewportElements(viewport) {
      return (0, _meta.MetaFilter)([
        (0, _basic.ViewportMeta)({
          viewport: viewport,
        }),
      ]);
    }

    //# sourceMappingURL=metadata.js.map
  },
  3769: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      accumulateMetadata: function () {
        return accumulateMetadata;
      },
      accumulateViewport: function () {
        return accumulateViewport;
      },
      resolveMetadata: function () {
        return resolveMetadata;
      },
      resolveViewport: function () {
        return resolveViewport;
      },
    });
    __webpack_require__(5760);
    const _react = __webpack_require__(8516);
    const _defaultmetadata = __webpack_require__(7057);
    const _resolveopengraph = __webpack_require__(1610);
    const _resolvetitle = __webpack_require__(553);
    const _utils = __webpack_require__(327);
    const _appdirmodule = __webpack_require__(6085);
    const _interopdefault = __webpack_require__(6374);
    const _resolvebasics = __webpack_require__(9764);
    const _resolveicons = __webpack_require__(934);
    const _tracer = __webpack_require__(9223);
    const _constants = __webpack_require__(2917);
    const _segment = __webpack_require__(7099);
    const _log = /*#__PURE__*/ _interop_require_wildcard(__webpack_require__(2139));
    const _params = __webpack_require__(5683);
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== 'function') return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function (nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
        return {
          default: obj,
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null,
      };
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function isFavicon(icon) {
      if (!icon) {
        return false;
      }
      // turbopack appends a hash to all images
      return (
        (icon.url === '/favicon.ico' ||
          icon.url.toString().startsWith('/favicon.ico?')) &&
        icon.type === 'image/x-icon'
      );
    }
    function mergeStaticMetadata(
      source,
      target,
      staticFilesMetadata,
      metadataContext,
      titleTemplates,
      leafSegmentStaticIcons
    ) {
      var _source_twitter, _source_openGraph;
      if (!staticFilesMetadata) return;
      const { icon, apple, openGraph, twitter, manifest } = staticFilesMetadata;
      // Keep updating the static icons in the most leaf node
      if (icon) {
        leafSegmentStaticIcons.icon = icon;
      }
      if (apple) {
        leafSegmentStaticIcons.apple = apple;
      }
      // file based metadata is specified and current level metadata twitter.images is not specified
      if (
        twitter &&
        !(source == null
          ? void 0
          : (_source_twitter = source.twitter) == null
            ? void 0
            : _source_twitter.hasOwnProperty('images'))
      ) {
        const resolvedTwitter = (0, _resolveopengraph.resolveTwitter)(
          {
            ...target.twitter,
            images: twitter,
          },
          target.metadataBase,
          {
            ...metadataContext,
            isStaticMetadataRouteFile: true,
          },
          titleTemplates.twitter
        );
        target.twitter = resolvedTwitter;
      }
      // file based metadata is specified and current level metadata openGraph.images is not specified
      if (
        openGraph &&
        !(source == null
          ? void 0
          : (_source_openGraph = source.openGraph) == null
            ? void 0
            : _source_openGraph.hasOwnProperty('images'))
      ) {
        const resolvedOpenGraph = (0, _resolveopengraph.resolveOpenGraph)(
          {
            ...target.openGraph,
            images: openGraph,
          },
          target.metadataBase,
          {
            ...metadataContext,
            isStaticMetadataRouteFile: true,
          },
          titleTemplates.openGraph
        );
        target.openGraph = resolvedOpenGraph;
      }
      if (manifest) {
        target.manifest = manifest;
      }
      return target;
    }
    // Merge the source metadata into the resolved target metadata.
    function mergeMetadata({
      source,
      target,
      staticFilesMetadata,
      titleTemplates,
      metadataContext,
      buildState,
      leafSegmentStaticIcons,
    }) {
      // If there's override metadata, prefer it otherwise fallback to the default metadata.
      const metadataBase =
        typeof (source == null ? void 0 : source.metadataBase) !== 'undefined'
          ? source.metadataBase
          : target.metadataBase;
      for (const key_ in source) {
        const key = key_;
        switch (key) {
          case 'title': {
            target.title = (0, _resolvetitle.resolveTitle)(
              source.title,
              titleTemplates.title
            );
            break;
          }
          case 'alternates': {
            target.alternates = (0, _resolvebasics.resolveAlternates)(
              source.alternates,
              metadataBase,
              metadataContext
            );
            break;
          }
          case 'openGraph': {
            target.openGraph = (0, _resolveopengraph.resolveOpenGraph)(
              source.openGraph,
              metadataBase,
              metadataContext,
              titleTemplates.openGraph
            );
            break;
          }
          case 'twitter': {
            target.twitter = (0, _resolveopengraph.resolveTwitter)(
              source.twitter,
              metadataBase,
              metadataContext,
              titleTemplates.twitter
            );
            break;
          }
          case 'facebook':
            target.facebook = (0, _resolvebasics.resolveFacebook)(source.facebook);
            break;
          case 'verification':
            target.verification = (0, _resolvebasics.resolveVerification)(
              source.verification
            );
            break;
          case 'icons': {
            target.icons = (0, _resolveicons.resolveIcons)(source.icons);
            break;
          }
          case 'appleWebApp':
            target.appleWebApp = (0, _resolvebasics.resolveAppleWebApp)(
              source.appleWebApp
            );
            break;
          case 'appLinks':
            target.appLinks = (0, _resolvebasics.resolveAppLinks)(source.appLinks);
            break;
          case 'robots': {
            target.robots = (0, _resolvebasics.resolveRobots)(source.robots);
            break;
          }
          case 'archives':
          case 'assets':
          case 'bookmarks':
          case 'keywords': {
            target[key] = (0, _utils.resolveAsArrayOrUndefined)(source[key]);
            break;
          }
          case 'authors': {
            target[key] = (0, _utils.resolveAsArrayOrUndefined)(source.authors);
            break;
          }
          case 'itunes': {
            target[key] = (0, _resolvebasics.resolveItunes)(
              source.itunes,
              metadataBase,
              metadataContext
            );
            break;
          }
          case 'pagination': {
            target.pagination = (0, _resolvebasics.resolvePagination)(
              source.pagination,
              metadataBase,
              metadataContext
            );
            break;
          }
          // directly assign fields that fallback to null
          case 'applicationName':
          case 'description':
          case 'generator':
          case 'creator':
          case 'publisher':
          case 'category':
          case 'classification':
          case 'referrer':
          case 'formatDetection':
          case 'manifest':
          case 'pinterest':
            // @ts-ignore TODO: support inferring
            target[key] = source[key] || null;
            break;
          case 'other':
            target.other = Object.assign({}, target.other, source.other);
            break;
          case 'metadataBase':
            target.metadataBase = metadataBase;
            break;
          default: {
            if (
              (key === 'viewport' || key === 'themeColor' || key === 'colorScheme') &&
              source[key] != null
            ) {
              buildState.warnings.add(
                `Unsupported metadata ${key} is configured in metadata export in ${metadataContext.pathname}. Please move it to viewport export instead.\nRead more: https://nextjs.org/docs/app/api-reference/functions/generate-viewport`
              );
            }
            break;
          }
        }
      }
      mergeStaticMetadata(
        source,
        target,
        staticFilesMetadata,
        metadataContext,
        titleTemplates,
        leafSegmentStaticIcons
      );
    }
    function mergeViewport({ target, source }) {
      if (!source) return;
      for (const key_ in source) {
        const key = key_;
        switch (key) {
          case 'themeColor': {
            target.themeColor = (0, _resolvebasics.resolveThemeColor)(source.themeColor);
            break;
          }
          case 'colorScheme':
            target.colorScheme = source.colorScheme || null;
            break;
          default:
            // always override the target with the source
            // @ts-ignore viewport properties
            target[key] = source[key];
            break;
        }
      }
    }
    function getDefinedViewport(mod, props, tracingProps) {
      if (typeof mod.generateViewport === 'function') {
        const { route } = tracingProps;
        return (parent) =>
          (0, _tracer.getTracer)().trace(
            _constants.ResolveMetadataSpan.generateViewport,
            {
              spanName: `generateViewport ${route}`,
              attributes: {
                'next.page': route,
              },
            },
            () => mod.generateViewport(props, parent)
          );
      }
      return mod.viewport || null;
    }
    function getDefinedMetadata(mod, props, tracingProps) {
      if (typeof mod.generateMetadata === 'function') {
        const { route } = tracingProps;
        return (parent) =>
          (0, _tracer.getTracer)().trace(
            _constants.ResolveMetadataSpan.generateMetadata,
            {
              spanName: `generateMetadata ${route}`,
              attributes: {
                'next.page': route,
              },
            },
            () => mod.generateMetadata(props, parent)
          );
      }
      return mod.metadata || null;
    }
    async function collectStaticImagesFiles(metadata, props, type) {
      var _this;
      if (!(metadata == null ? void 0 : metadata[type])) return undefined;
      const iconPromises = metadata[type].map(async (imageModule) =>
        (0, _interopdefault.interopDefault)(await imageModule(props))
      );
      return (iconPromises == null ? void 0 : iconPromises.length) > 0
        ? (_this = await Promise.all(iconPromises)) == null
          ? void 0
          : _this.flat()
        : undefined;
    }
    async function resolveStaticMetadata(modules, props) {
      const { metadata } = modules;
      if (!metadata) return null;
      const [icon, apple, openGraph, twitter] = await Promise.all([
        collectStaticImagesFiles(metadata, props, 'icon'),
        collectStaticImagesFiles(metadata, props, 'apple'),
        collectStaticImagesFiles(metadata, props, 'openGraph'),
        collectStaticImagesFiles(metadata, props, 'twitter'),
      ]);
      const staticMetadata = {
        icon,
        apple,
        openGraph,
        twitter,
        manifest: metadata.manifest,
      };
      return staticMetadata;
    }
    // [layout.metadata, static files metadata] -> ... -> [page.metadata, static files metadata]
    async function collectMetadata({
      tree,
      metadataItems,
      errorMetadataItem,
      props,
      route,
      errorConvention,
    }) {
      let mod;
      let modType;
      const hasErrorConventionComponent = Boolean(
        errorConvention && tree[2][errorConvention]
      );
      if (errorConvention) {
        mod = await (0, _appdirmodule.getComponentTypeModule)(tree, 'layout');
        modType = errorConvention;
      } else {
        const { mod: layoutOrPageMod, modType: layoutOrPageModType } = await (0,
        _appdirmodule.getLayoutOrPageModule)(tree);
        mod = layoutOrPageMod;
        modType = layoutOrPageModType;
      }
      if (modType) {
        route += `/${modType}`;
      }
      const staticFilesMetadata = await resolveStaticMetadata(tree[2], props);
      const metadataExport = mod
        ? getDefinedMetadata(mod, props, {
            route,
          })
        : null;
      metadataItems.push([metadataExport, staticFilesMetadata]);
      if (hasErrorConventionComponent && errorConvention) {
        const errorMod = await (0, _appdirmodule.getComponentTypeModule)(
          tree,
          errorConvention
        );
        const errorMetadataExport = errorMod
          ? getDefinedMetadata(errorMod, props, {
              route,
            })
          : null;
        errorMetadataItem[0] = errorMetadataExport;
        errorMetadataItem[1] = staticFilesMetadata;
      }
    }
    // [layout.metadata, static files metadata] -> ... -> [page.metadata, static files metadata]
    async function collectViewport({
      tree,
      viewportItems,
      errorViewportItemRef,
      props,
      route,
      errorConvention,
    }) {
      let mod;
      let modType;
      const hasErrorConventionComponent = Boolean(
        errorConvention && tree[2][errorConvention]
      );
      if (errorConvention) {
        mod = await (0, _appdirmodule.getComponentTypeModule)(tree, 'layout');
        modType = errorConvention;
      } else {
        const { mod: layoutOrPageMod, modType: layoutOrPageModType } = await (0,
        _appdirmodule.getLayoutOrPageModule)(tree);
        mod = layoutOrPageMod;
        modType = layoutOrPageModType;
      }
      if (modType) {
        route += `/${modType}`;
      }
      const viewportExport = mod
        ? getDefinedViewport(mod, props, {
            route,
          })
        : null;
      viewportItems.push(viewportExport);
      if (hasErrorConventionComponent && errorConvention) {
        const errorMod = await (0, _appdirmodule.getComponentTypeModule)(
          tree,
          errorConvention
        );
        const errorViewportExport = errorMod
          ? getDefinedViewport(errorMod, props, {
              route,
            })
          : null;
        errorViewportItemRef.current = errorViewportExport;
      }
    }
    const resolveMetadataItems = (0, _react.cache)(
      async function (
        tree,
        searchParams,
        errorConvention,
        getDynamicParamFromSegment,
        workStore
      ) {
        const parentParams = {};
        const metadataItems = [];
        const errorMetadataItem = [null, null];
        const treePrefix = undefined;
        return resolveMetadataItemsImpl(
          metadataItems,
          tree,
          treePrefix,
          parentParams,
          searchParams,
          errorConvention,
          errorMetadataItem,
          getDynamicParamFromSegment,
          workStore
        );
      }
    );
    async function resolveMetadataItemsImpl(
      metadataItems,
      tree,
      /**
       * Provided tree can be nested subtree, this argument says what is the path of such
       * subtree
       */ treePrefix,
      parentParams,
      searchParams,
      errorConvention,
      errorMetadataItem,
      getDynamicParamFromSegment,
      workStore
    ) {
      const [segment, parallelRoutes, { page }] = tree;
      const currentTreePrefix =
        treePrefix && treePrefix.length ? [...treePrefix, segment] : [segment];
      const isPage = typeof page !== 'undefined';
      // Handle dynamic segment params.
      const segmentParam = getDynamicParamFromSegment(segment);
      /** Create object holding the parent params and current params */ let currentParams =
        parentParams;
      if (segmentParam && segmentParam.value !== null) {
        currentParams = {
          ...parentParams,
          [segmentParam.param]: segmentParam.value,
        };
      }
      const params = (0, _params.createServerParamsForMetadata)(currentParams, workStore);
      let layerProps;
      if (isPage) {
        layerProps = {
          params,
          searchParams,
        };
      } else {
        layerProps = {
          params,
        };
      }
      await collectMetadata({
        tree,
        metadataItems,
        errorMetadataItem,
        errorConvention,
        props: layerProps,
        route: currentTreePrefix // __PAGE__ shouldn't be shown in a route
          .filter((s) => s !== _segment.PAGE_SEGMENT_KEY)
          .join('/'),
      });
      for (const key in parallelRoutes) {
        const childTree = parallelRoutes[key];
        await resolveMetadataItemsImpl(
          metadataItems,
          childTree,
          currentTreePrefix,
          currentParams,
          searchParams,
          errorConvention,
          errorMetadataItem,
          getDynamicParamFromSegment,
          workStore
        );
      }
      if (Object.keys(parallelRoutes).length === 0 && errorConvention) {
        // If there are no parallel routes, place error metadata as the last item.
        // e.g. layout -> layout -> not-found
        metadataItems.push(errorMetadataItem);
      }
      return metadataItems;
    }
    const resolveViewportItems = (0, _react.cache)(
      async function (
        tree,
        searchParams,
        errorConvention,
        getDynamicParamFromSegment,
        workStore
      ) {
        const parentParams = {};
        const viewportItems = [];
        const errorViewportItemRef = {
          current: null,
        };
        const treePrefix = undefined;
        return resolveViewportItemsImpl(
          viewportItems,
          tree,
          treePrefix,
          parentParams,
          searchParams,
          errorConvention,
          errorViewportItemRef,
          getDynamicParamFromSegment,
          workStore
        );
      }
    );
    async function resolveViewportItemsImpl(
      viewportItems,
      tree,
      /**
       * Provided tree can be nested subtree, this argument says what is the path of such
       * subtree
       */ treePrefix,
      parentParams,
      searchParams,
      errorConvention,
      errorViewportItemRef,
      getDynamicParamFromSegment,
      workStore
    ) {
      const [segment, parallelRoutes, { page }] = tree;
      const currentTreePrefix =
        treePrefix && treePrefix.length ? [...treePrefix, segment] : [segment];
      const isPage = typeof page !== 'undefined';
      // Handle dynamic segment params.
      const segmentParam = getDynamicParamFromSegment(segment);
      /** Create object holding the parent params and current params */ let currentParams =
        parentParams;
      if (segmentParam && segmentParam.value !== null) {
        currentParams = {
          ...parentParams,
          [segmentParam.param]: segmentParam.value,
        };
      }
      const params = (0, _params.createServerParamsForMetadata)(currentParams, workStore);
      let layerProps;
      if (isPage) {
        layerProps = {
          params,
          searchParams,
        };
      } else {
        layerProps = {
          params,
        };
      }
      await collectViewport({
        tree,
        viewportItems,
        errorViewportItemRef,
        errorConvention,
        props: layerProps,
        route: currentTreePrefix // __PAGE__ shouldn't be shown in a route
          .filter((s) => s !== _segment.PAGE_SEGMENT_KEY)
          .join('/'),
      });
      for (const key in parallelRoutes) {
        const childTree = parallelRoutes[key];
        await resolveViewportItemsImpl(
          viewportItems,
          childTree,
          currentTreePrefix,
          currentParams,
          searchParams,
          errorConvention,
          errorViewportItemRef,
          getDynamicParamFromSegment,
          workStore
        );
      }
      if (Object.keys(parallelRoutes).length === 0 && errorConvention) {
        // If there are no parallel routes, place error metadata as the last item.
        // e.g. layout -> layout -> not-found
        viewportItems.push(errorViewportItemRef.current);
      }
      return viewportItems;
    }
    const isTitleTruthy = (title) => !!(title == null ? void 0 : title.absolute);
    const hasTitle = (metadata) =>
      isTitleTruthy(metadata == null ? void 0 : metadata.title);
    function inheritFromMetadata(target, metadata) {
      if (target) {
        if (!hasTitle(target) && hasTitle(metadata)) {
          target.title = metadata.title;
        }
        if (!target.description && metadata.description) {
          target.description = metadata.description;
        }
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const commonOgKeys = /* unused pure expression or super */ null && [
      'title',
      'description',
      'images',
    ];
    function postProcessMetadata(metadata, favicon, titleTemplates, metadataContext) {
      const { openGraph, twitter } = metadata;
      if (openGraph) {
        // If there's openGraph information but not configured in twitter,
        // inherit them from openGraph metadata.
        let autoFillProps = {};
        const hasTwTitle = hasTitle(twitter);
        const hasTwDescription = twitter == null ? void 0 : twitter.description;
        const hasTwImages = Boolean(
          (twitter == null ? void 0 : twitter.hasOwnProperty('images')) && twitter.images
        );
        if (!hasTwTitle) {
          if (isTitleTruthy(openGraph.title)) {
            autoFillProps.title = openGraph.title;
          } else if (metadata.title && isTitleTruthy(metadata.title)) {
            autoFillProps.title = metadata.title;
          }
        }
        if (!hasTwDescription)
          autoFillProps.description =
            openGraph.description || metadata.description || undefined;
        if (!hasTwImages) autoFillProps.images = openGraph.images;
        if (Object.keys(autoFillProps).length > 0) {
          const partialTwitter = (0, _resolveopengraph.resolveTwitter)(
            autoFillProps,
            metadata.metadataBase,
            metadataContext,
            titleTemplates.twitter
          );
          if (metadata.twitter) {
            metadata.twitter = Object.assign({}, metadata.twitter, {
              ...(!hasTwTitle && {
                title: partialTwitter == null ? void 0 : partialTwitter.title,
              }),
              ...(!hasTwDescription && {
                description: partialTwitter == null ? void 0 : partialTwitter.description,
              }),
              ...(!hasTwImages && {
                images: partialTwitter == null ? void 0 : partialTwitter.images,
              }),
            });
          } else {
            metadata.twitter = partialTwitter;
          }
        }
      }
      // If there's no title and description configured in openGraph or twitter,
      // use the title and description from metadata.
      inheritFromMetadata(openGraph, metadata);
      inheritFromMetadata(twitter, metadata);
      if (favicon) {
        if (!metadata.icons) {
          metadata.icons = {
            icon: [],
            apple: [],
          };
        }
        metadata.icons.icon.unshift(favicon);
      }
      return metadata;
    }
    function prerenderMetadata(metadataItems) {
      // If the index is a function then it is a resolver and the next slot
      // is the corresponding result. If the index is not a function it is the result
      // itself.
      const resolversAndResults = [];
      for (let i = 0; i < metadataItems.length; i++) {
        const metadataExport = metadataItems[i][0];
        getResult(resolversAndResults, metadataExport);
      }
      return resolversAndResults;
    }
    function prerenderViewport(viewportItems) {
      // If the index is a function then it is a resolver and the next slot
      // is the corresponding result. If the index is not a function it is the result
      // itself.
      const resolversAndResults = [];
      for (let i = 0; i < viewportItems.length; i++) {
        const viewportExport = viewportItems[i];
        getResult(resolversAndResults, viewportExport);
      }
      return resolversAndResults;
    }
    function getResult(resolversAndResults, exportForResult) {
      if (typeof exportForResult === 'function') {
        const result = exportForResult(
          new Promise((resolve) => resolversAndResults.push(resolve))
        );
        resolversAndResults.push(result);
        if (result instanceof Promise) {
          // since we eager execute generateMetadata and
          // they can reject at anytime we need to ensure
          // we attach the catch handler right away to
          // prevent unhandled rejections crashing the process
          result.catch((err) => {
            return {
              __nextError: err,
            };
          });
        }
      } else if (typeof exportForResult === 'object') {
        resolversAndResults.push(exportForResult);
      } else {
        resolversAndResults.push(null);
      }
    }
    function resolvePendingResult(parentResult, resolveParentResult) {
      // In dev we clone and freeze to prevent relying on mutating resolvedMetadata directly.
      // In prod we just pass resolvedMetadata through without any copying.
      if (true) {
        parentResult = __webpack_require__(9986) /* .deepFreeze */
          .deepFreeze(
            __webpack_require__(5659) /* .cloneMetadata */
              .cloneMetadata(parentResult)
          );
      }
      resolveParentResult(parentResult);
    }
    async function accumulateMetadata(metadataItems, metadataContext) {
      const resolvedMetadata = (0, _defaultmetadata.createDefaultMetadata)();
      let titleTemplates = {
        title: null,
        twitter: null,
        openGraph: null,
      };
      const buildState = {
        warnings: new Set(),
      };
      let favicon;
      // Collect the static icons in the most leaf node,
      // since we don't collect all the static metadata icons in the parent segments.
      const leafSegmentStaticIcons = {
        icon: [],
        apple: [],
      };
      const resolversAndResults = prerenderMetadata(metadataItems);
      let resultIndex = 0;
      for (let i = 0; i < metadataItems.length; i++) {
        var _staticFilesMetadata_icon;
        const staticFilesMetadata = metadataItems[i][1];
        // Treat favicon as special case, it should be the first icon in the list
        // i <= 1 represents root layout, and if current page is also at root
        if (
          i <= 1 &&
          isFavicon(
            staticFilesMetadata == null
              ? void 0
              : (_staticFilesMetadata_icon = staticFilesMetadata.icon) == null
                ? void 0
                : _staticFilesMetadata_icon[0]
          )
        ) {
          var _staticFilesMetadata_icon1;
          const iconMod =
            staticFilesMetadata == null
              ? void 0
              : (_staticFilesMetadata_icon1 = staticFilesMetadata.icon) == null
                ? void 0
                : _staticFilesMetadata_icon1.shift();
          if (i === 0) favicon = iconMod;
        }
        let pendingMetadata = resolversAndResults[resultIndex++];
        if (typeof pendingMetadata === 'function') {
          // This metadata item had a `generateMetadata` and
          // we need to provide the currently resolved metadata
          // to it before we continue;
          const resolveParentMetadata = pendingMetadata;
          // we know that the next item is a result if this item
          // was a resolver
          pendingMetadata = resolversAndResults[resultIndex++];
          resolvePendingResult(resolvedMetadata, resolveParentMetadata);
        }
        // Otherwise the item was either null or a static export
        let metadata;
        if (isPromiseLike(pendingMetadata)) {
          metadata = await pendingMetadata;
        } else {
          metadata = pendingMetadata;
        }
        mergeMetadata({
          target: resolvedMetadata,
          source: metadata,
          metadataContext,
          staticFilesMetadata,
          titleTemplates,
          buildState,
          leafSegmentStaticIcons,
        });
        // If the layout is the same layer with page, skip the leaf layout and leaf page
        // The leaf layout and page are the last two items
        if (i < metadataItems.length - 2) {
          var _resolvedMetadata_title,
            _resolvedMetadata_openGraph,
            _resolvedMetadata_twitter;
          titleTemplates = {
            title:
              ((_resolvedMetadata_title = resolvedMetadata.title) == null
                ? void 0
                : _resolvedMetadata_title.template) || null,
            openGraph:
              ((_resolvedMetadata_openGraph = resolvedMetadata.openGraph) == null
                ? void 0
                : _resolvedMetadata_openGraph.title.template) || null,
            twitter:
              ((_resolvedMetadata_twitter = resolvedMetadata.twitter) == null
                ? void 0
                : _resolvedMetadata_twitter.title.template) || null,
          };
        }
      }
      if (
        leafSegmentStaticIcons.icon.length > 0 ||
        leafSegmentStaticIcons.apple.length > 0
      ) {
        if (!resolvedMetadata.icons) {
          resolvedMetadata.icons = {
            icon: [],
            apple: [],
          };
          if (leafSegmentStaticIcons.icon.length > 0) {
            resolvedMetadata.icons.icon.unshift(...leafSegmentStaticIcons.icon);
          }
          if (leafSegmentStaticIcons.apple.length > 0) {
            resolvedMetadata.icons.apple.unshift(...leafSegmentStaticIcons.apple);
          }
        }
      }
      // Only log warnings if there are any, and only once after the metadata resolving process is finished
      if (buildState.warnings.size > 0) {
        for (const warning of buildState.warnings) {
          _log.warn(warning);
        }
      }
      return postProcessMetadata(
        resolvedMetadata,
        favicon,
        titleTemplates,
        metadataContext
      );
    }
    async function accumulateViewport(viewportItems) {
      const resolvedViewport = (0, _defaultmetadata.createDefaultViewport)();
      const resolversAndResults = prerenderViewport(viewportItems);
      let i = 0;
      while (i < resolversAndResults.length) {
        let pendingViewport = resolversAndResults[i++];
        if (typeof pendingViewport === 'function') {
          // this viewport item had a `generateViewport` and
          // we need to provide the currently resolved viewport
          // to it before we continue;
          const resolveParentViewport = pendingViewport;
          // we know that the next item is a result if this item
          // was a resolver
          pendingViewport = resolversAndResults[i++];
          resolvePendingResult(resolvedViewport, resolveParentViewport);
        }
        // Otherwise the item was either null or a static export
        let viewport;
        if (isPromiseLike(pendingViewport)) {
          viewport = await pendingViewport;
        } else {
          viewport = pendingViewport;
        }
        mergeViewport({
          target: resolvedViewport,
          source: viewport,
        });
      }
      return resolvedViewport;
    }
    async function resolveMetadata(
      tree,
      searchParams,
      errorConvention,
      getDynamicParamFromSegment,
      workStore,
      metadataContext
    ) {
      const metadataItems = await resolveMetadataItems(
        tree,
        searchParams,
        errorConvention,
        getDynamicParamFromSegment,
        workStore
      );
      return accumulateMetadata(metadataItems, metadataContext);
    }
    async function resolveViewport(
      tree,
      searchParams,
      errorConvention,
      getDynamicParamFromSegment,
      workStore
    ) {
      const viewportItems = await resolveViewportItems(
        tree,
        searchParams,
        errorConvention,
        getDynamicParamFromSegment,
        workStore
      );
      return accumulateViewport(viewportItems);
    }
    function isPromiseLike(value) {
      return (
        typeof value === 'object' && value !== null && typeof value.then === 'function'
      );
    }

    //# sourceMappingURL=resolve-metadata.js.map
  },
  9764: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      resolveAlternates: function () {
        return resolveAlternates;
      },
      resolveAppLinks: function () {
        return resolveAppLinks;
      },
      resolveAppleWebApp: function () {
        return resolveAppleWebApp;
      },
      resolveFacebook: function () {
        return resolveFacebook;
      },
      resolveItunes: function () {
        return resolveItunes;
      },
      resolvePagination: function () {
        return resolvePagination;
      },
      resolveRobots: function () {
        return resolveRobots;
      },
      resolveThemeColor: function () {
        return resolveThemeColor;
      },
      resolveVerification: function () {
        return resolveVerification;
      },
    });
    const _utils = __webpack_require__(327);
    const _resolveurl = __webpack_require__(8661);
    function resolveAlternateUrl(url, metadataBase, metadataContext) {
      // If alter native url is an URL instance,
      // we treat it as a URL base and resolve with current pathname
      if (url instanceof URL) {
        const newUrl = new URL(metadataContext.pathname, url);
        url.searchParams.forEach((value, key) => newUrl.searchParams.set(key, value));
        url = newUrl;
      }
      return (0, _resolveurl.resolveAbsoluteUrlWithPathname)(
        url,
        metadataBase,
        metadataContext
      );
    }
    const resolveThemeColor = (themeColor) => {
      var _resolveAsArrayOrUndefined;
      if (!themeColor) return null;
      const themeColorDescriptors = [];
      (_resolveAsArrayOrUndefined = (0, _utils.resolveAsArrayOrUndefined)(themeColor)) ==
      null
        ? void 0
        : _resolveAsArrayOrUndefined.forEach((descriptor) => {
            if (typeof descriptor === 'string')
              themeColorDescriptors.push({
                color: descriptor,
              });
            else if (typeof descriptor === 'object')
              themeColorDescriptors.push({
                color: descriptor.color,
                media: descriptor.media,
              });
          });
      return themeColorDescriptors;
    };
    function resolveUrlValuesOfObject(obj, metadataBase, metadataContext) {
      if (!obj) return null;
      const result = {};
      for (const [key, value] of Object.entries(obj)) {
        if (typeof value === 'string' || value instanceof URL) {
          result[key] = [
            {
              url: resolveAlternateUrl(value, metadataBase, metadataContext),
            },
          ];
        } else {
          result[key] = [];
          value == null
            ? void 0
            : value.forEach((item, index) => {
                const url = resolveAlternateUrl(item.url, metadataBase, metadataContext);
                result[key][index] = {
                  url,
                  title: item.title,
                };
              });
        }
      }
      return result;
    }
    function resolveCanonicalUrl(urlOrDescriptor, metadataBase, metadataContext) {
      if (!urlOrDescriptor) return null;
      const url =
        typeof urlOrDescriptor === 'string' || urlOrDescriptor instanceof URL
          ? urlOrDescriptor
          : urlOrDescriptor.url;
      // Return string url because structureClone can't handle URL instance
      return {
        url: resolveAlternateUrl(url, metadataBase, metadataContext),
      };
    }
    const resolveAlternates = (alternates, metadataBase, context) => {
      if (!alternates) return null;
      const canonical = resolveCanonicalUrl(alternates.canonical, metadataBase, context);
      const languages = resolveUrlValuesOfObject(
        alternates.languages,
        metadataBase,
        context
      );
      const media = resolveUrlValuesOfObject(alternates.media, metadataBase, context);
      const types = resolveUrlValuesOfObject(alternates.types, metadataBase, context);
      const result = {
        canonical,
        languages,
        media,
        types,
      };
      return result;
    };
    const robotsKeys = [
      'noarchive',
      'nosnippet',
      'noimageindex',
      'nocache',
      'notranslate',
      'indexifembedded',
      'nositelinkssearchbox',
      'unavailable_after',
      'max-video-preview',
      'max-image-preview',
      'max-snippet',
    ];
    const resolveRobotsValue = (robots) => {
      if (!robots) return null;
      if (typeof robots === 'string') return robots;
      const values = [];
      if (robots.index) values.push('index');
      else if (typeof robots.index === 'boolean') values.push('noindex');
      if (robots.follow) values.push('follow');
      else if (typeof robots.follow === 'boolean') values.push('nofollow');
      for (const key of robotsKeys) {
        const value = robots[key];
        if (typeof value !== 'undefined' && value !== false) {
          values.push(typeof value === 'boolean' ? key : `${key}:${value}`);
        }
      }
      return values.join(', ');
    };
    const resolveRobots = (robots) => {
      if (!robots) return null;
      return {
        basic: resolveRobotsValue(robots),
        googleBot:
          typeof robots !== 'string' ? resolveRobotsValue(robots.googleBot) : null,
      };
    };
    const VerificationKeys = ['google', 'yahoo', 'yandex', 'me', 'other'];
    const resolveVerification = (verification) => {
      if (!verification) return null;
      const res = {};
      for (const key of VerificationKeys) {
        const value = verification[key];
        if (value) {
          if (key === 'other') {
            res.other = {};
            for (const otherKey in verification.other) {
              const otherValue = (0, _utils.resolveAsArrayOrUndefined)(
                verification.other[otherKey]
              );
              if (otherValue) res.other[otherKey] = otherValue;
            }
          } else res[key] = (0, _utils.resolveAsArrayOrUndefined)(value);
        }
      }
      return res;
    };
    const resolveAppleWebApp = (appWebApp) => {
      var _resolveAsArrayOrUndefined;
      if (!appWebApp) return null;
      if (appWebApp === true) {
        return {
          capable: true,
        };
      }
      const startupImages = appWebApp.startupImage
        ? (_resolveAsArrayOrUndefined = (0, _utils.resolveAsArrayOrUndefined)(
            appWebApp.startupImage
          )) == null
          ? void 0
          : _resolveAsArrayOrUndefined.map((item) =>
              typeof item === 'string'
                ? {
                    url: item,
                  }
                : item
            )
        : null;
      return {
        capable: 'capable' in appWebApp ? !!appWebApp.capable : true,
        title: appWebApp.title || null,
        startupImage: startupImages,
        statusBarStyle: appWebApp.statusBarStyle || 'default',
      };
    };
    const resolveAppLinks = (appLinks) => {
      if (!appLinks) return null;
      for (const key in appLinks) {
        // @ts-ignore // TODO: type infer
        appLinks[key] = (0, _utils.resolveAsArrayOrUndefined)(appLinks[key]);
      }
      return appLinks;
    };
    const resolveItunes = (itunes, metadataBase, context) => {
      if (!itunes) return null;
      return {
        appId: itunes.appId,
        appArgument: itunes.appArgument
          ? resolveAlternateUrl(itunes.appArgument, metadataBase, context)
          : undefined,
      };
    };
    const resolveFacebook = (facebook) => {
      if (!facebook) return null;
      return {
        appId: facebook.appId,
        admins: (0, _utils.resolveAsArrayOrUndefined)(facebook.admins),
      };
    };
    const resolvePagination = (pagination, metadataBase, context) => {
      return {
        previous: (pagination == null ? void 0 : pagination.previous)
          ? resolveAlternateUrl(pagination.previous, metadataBase, context)
          : null,
        next: (pagination == null ? void 0 : pagination.next)
          ? resolveAlternateUrl(pagination.next, metadataBase, context)
          : null,
      };
    };

    //# sourceMappingURL=resolve-basics.js.map
  },
  934: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      resolveIcon: function () {
        return resolveIcon;
      },
      resolveIcons: function () {
        return resolveIcons;
      },
    });
    const _utils = __webpack_require__(327);
    const _resolveurl = __webpack_require__(8661);
    const _constants = __webpack_require__(4702);
    function resolveIcon(icon) {
      if ((0, _resolveurl.isStringOrURL)(icon))
        return {
          url: icon,
        };
      else if (Array.isArray(icon)) return icon;
      return icon;
    }
    const resolveIcons = (icons) => {
      if (!icons) {
        return null;
      }
      const resolved = {
        icon: [],
        apple: [],
      };
      if (Array.isArray(icons)) {
        resolved.icon = icons.map(resolveIcon).filter(Boolean);
      } else if ((0, _resolveurl.isStringOrURL)(icons)) {
        resolved.icon = [resolveIcon(icons)];
      } else {
        for (const key of _constants.IconKeys) {
          const values = (0, _utils.resolveAsArrayOrUndefined)(icons[key]);
          if (values) resolved[key] = values.map(resolveIcon);
        }
      }
      return resolved;
    };

    //# sourceMappingURL=resolve-icons.js.map
  },
  1610: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      resolveImages: function () {
        return resolveImages;
      },
      resolveOpenGraph: function () {
        return resolveOpenGraph;
      },
      resolveTwitter: function () {
        return resolveTwitter;
      },
    });
    const _utils = __webpack_require__(327);
    const _resolveurl = __webpack_require__(8661);
    const _resolvetitle = __webpack_require__(553);
    const _url = __webpack_require__(83);
    const _log = __webpack_require__(2139);
    const OgTypeFields = {
      article: ['authors', 'tags'],
      song: ['albums', 'musicians'],
      playlist: ['albums', 'musicians'],
      radio: ['creators'],
      video: ['actors', 'directors', 'writers', 'tags'],
      basic: [
        'emails',
        'phoneNumbers',
        'faxNumbers',
        'alternateLocale',
        'audio',
        'videos',
      ],
    };
    function resolveAndValidateImage(item, metadataBase, isStaticMetadataRouteFile) {
      if (!item) return undefined;
      const isItemUrl = (0, _resolveurl.isStringOrURL)(item);
      const inputUrl = isItemUrl ? item : item.url;
      if (!inputUrl) return undefined;
      // process.env.VERCEL is set to "1" when System Environment Variables are
      // exposed. When exposed, validation is not necessary since we are falling back to
      // process.env.VERCEL_PROJECT_PRODUCTION_URL, process.env.VERCEL_BRANCH_URL, or
      // process.env.VERCEL_URL for the `metadataBase`. process.env.VERCEL is undefined
      // when System Environment Variables are not exposed. When not exposed, we cannot
      // detect in the build environment if the deployment is a Vercel deployment or not.
      //
      // x-ref: https://vercel.com/docs/projects/environment-variables/system-environment-variables#system-environment-variables
      const isUsingVercelSystemEnvironmentVariables = Boolean(process.env.VERCEL);
      const isRelativeUrl =
        typeof inputUrl === 'string' && !(0, _url.isFullStringUrl)(inputUrl);
      // When no explicit metadataBase is specified by the user, we'll override it with the fallback metadata
      // under the following conditions:
      // - The provided URL is relative (ie ./og-image).
      // - The image is statically generated by Next.js (such as the special `opengraph-image` route)
      // In both cases, we want to ensure that across all environments, the ogImage is a fully qualified URL.
      // In the `opengraph-image` case, since the user isn't explicitly passing a relative path, this ensures
      // the ogImage will be properly discovered across different environments without the user needing to
      // have a bunch of `process.env` checks when defining their `metadataBase`.
      if (isRelativeUrl && (!metadataBase || isStaticMetadataRouteFile)) {
        const fallbackMetadataBase = (0, _resolveurl.getSocialImageMetadataBaseFallback)(
          metadataBase
        );
        // When not using Vercel environment variables for URL injection, we aren't able to determine
        // a fallback value for `metadataBase`. For self-hosted setups, we want to warn
        // about this since the only fallback we'll be able to generate is `localhost`.
        // In development, we'll only warn for relative metadata that isn't part of the static
        // metadata conventions (eg `opengraph-image`), as otherwise it's currently very noisy
        // for common cases. Eventually we should remove this warning all together in favor of
        // devtools.
        const shouldWarn =
          !isUsingVercelSystemEnvironmentVariables &&
          !metadataBase &&
          (false || !isStaticMetadataRouteFile);
        if (shouldWarn) {
          (0, _log.warnOnce)(
            `metadataBase property in metadata export is not set for resolving social open graph or twitter images, using "${fallbackMetadataBase.origin}". See https://nextjs.org/docs/app/api-reference/functions/generate-metadata#metadatabase`
          );
        }
        metadataBase = fallbackMetadataBase;
      }
      return isItemUrl
        ? {
            url: (0, _resolveurl.resolveUrl)(inputUrl, metadataBase),
          }
        : {
            ...item,
            // Update image descriptor url
            url: (0, _resolveurl.resolveUrl)(inputUrl, metadataBase),
          };
    }
    function resolveImages(images, metadataBase, isStaticMetadataRouteFile) {
      const resolvedImages = (0, _utils.resolveAsArrayOrUndefined)(images);
      if (!resolvedImages) return resolvedImages;
      const nonNullableImages = [];
      for (const item of resolvedImages) {
        const resolvedItem = resolveAndValidateImage(
          item,
          metadataBase,
          isStaticMetadataRouteFile
        );
        if (!resolvedItem) continue;
        nonNullableImages.push(resolvedItem);
      }
      return nonNullableImages;
    }
    const ogTypeToFields = {
      article: OgTypeFields.article,
      book: OgTypeFields.article,
      'music.song': OgTypeFields.song,
      'music.album': OgTypeFields.song,
      'music.playlist': OgTypeFields.playlist,
      'music.radio_station': OgTypeFields.radio,
      'video.movie': OgTypeFields.video,
      'video.episode': OgTypeFields.video,
    };
    function getFieldsByOgType(ogType) {
      if (!ogType || !(ogType in ogTypeToFields)) return OgTypeFields.basic;
      return ogTypeToFields[ogType].concat(OgTypeFields.basic);
    }
    const resolveOpenGraph = (
      openGraph,
      metadataBase,
      metadataContext,
      titleTemplate
    ) => {
      if (!openGraph) return null;
      function resolveProps(target, og) {
        const ogType = og && 'type' in og ? og.type : undefined;
        const keys = getFieldsByOgType(ogType);
        for (const k of keys) {
          const key = k;
          if (key in og && key !== 'url') {
            const value = og[key];
            target[key] = value ? (0, _utils.resolveArray)(value) : null;
          }
        }
        target.images = resolveImages(
          og.images,
          metadataBase,
          metadataContext.isStaticMetadataRouteFile
        );
      }
      const resolved = {
        ...openGraph,
        title: (0, _resolvetitle.resolveTitle)(openGraph.title, titleTemplate),
      };
      resolveProps(resolved, openGraph);
      resolved.url = openGraph.url
        ? (0, _resolveurl.resolveAbsoluteUrlWithPathname)(
            openGraph.url,
            metadataBase,
            metadataContext
          )
        : null;
      return resolved;
    };
    const TwitterBasicInfoKeys = [
      'site',
      'siteId',
      'creator',
      'creatorId',
      'description',
    ];
    const resolveTwitter = (twitter, metadataBase, metadataContext, titleTemplate) => {
      var _resolved_images;
      if (!twitter) return null;
      let card = 'card' in twitter ? twitter.card : undefined;
      const resolved = {
        ...twitter,
        title: (0, _resolvetitle.resolveTitle)(twitter.title, titleTemplate),
      };
      for (const infoKey of TwitterBasicInfoKeys) {
        resolved[infoKey] = twitter[infoKey] || null;
      }
      resolved.images = resolveImages(
        twitter.images,
        metadataBase,
        metadataContext.isStaticMetadataRouteFile
      );
      card =
        card ||
        (((_resolved_images = resolved.images) == null ? void 0 : _resolved_images.length)
          ? 'summary_large_image'
          : 'summary');
      resolved.card = card;
      if ('card' in resolved) {
        switch (resolved.card) {
          case 'player': {
            resolved.players =
              (0, _utils.resolveAsArrayOrUndefined)(resolved.players) || [];
            break;
          }
          case 'app': {
            resolved.app = resolved.app || {};
            break;
          }
          default:
            break;
        }
      }
      return resolved;
    };

    //# sourceMappingURL=resolve-opengraph.js.map
  },
  553: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'resolveTitle', {
      enumerable: true,
      get: function () {
        return resolveTitle;
      },
    });
    function resolveTitleTemplate(template, title) {
      return template ? template.replace(/%s/g, title) : title;
    }
    function resolveTitle(title, stashedTemplate) {
      let resolved;
      const template =
        typeof title !== 'string' && title && 'template' in title ? title.template : null;
      if (typeof title === 'string') {
        resolved = resolveTitleTemplate(stashedTemplate, title);
      } else if (title) {
        if ('default' in title) {
          resolved = resolveTitleTemplate(stashedTemplate, title.default);
        }
        if ('absolute' in title && title.absolute) {
          resolved = title.absolute;
        }
      }
      if (title && typeof title !== 'string') {
        return {
          template,
          absolute: resolved || '',
        };
      } else {
        return {
          absolute: resolved || title || '',
          template,
        };
      }
    }

    //# sourceMappingURL=resolve-title.js.map
  },
  8661: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getSocialImageMetadataBaseFallback: function () {
        return getSocialImageMetadataBaseFallback;
      },
      isStringOrURL: function () {
        return isStringOrURL;
      },
      resolveAbsoluteUrlWithPathname: function () {
        return resolveAbsoluteUrlWithPathname;
      },
      resolveRelativeUrl: function () {
        return resolveRelativeUrl;
      },
      resolveUrl: function () {
        return resolveUrl;
      },
    });
    const _path = /*#__PURE__*/ _interop_require_default(__webpack_require__(2203));
    function _interop_require_default(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }
    function isStringOrURL(icon) {
      return typeof icon === 'string' || icon instanceof URL;
    }
    function createLocalMetadataBase() {
      return new URL(`http://localhost:${process.env.PORT || 3000}`);
    }
    function getPreviewDeploymentUrl() {
      const origin = process.env.VERCEL_BRANCH_URL || process.env.VERCEL_URL;
      return origin ? new URL(`https://${origin}`) : undefined;
    }
    function getProductionDeploymentUrl() {
      const origin = process.env.VERCEL_PROJECT_PRODUCTION_URL;
      return origin ? new URL(`https://${origin}`) : undefined;
    }
    function getSocialImageMetadataBaseFallback(metadataBase) {
      const defaultMetadataBase = createLocalMetadataBase();
      const previewDeploymentUrl = getPreviewDeploymentUrl();
      const productionDeploymentUrl = getProductionDeploymentUrl();
      let fallbackMetadataBase;
      if (true) {
        fallbackMetadataBase = defaultMetadataBase;
      } else {
      }
      return fallbackMetadataBase;
    }
    function resolveUrl(url, metadataBase) {
      if (url instanceof URL) return url;
      if (!url) return null;
      try {
        // If we can construct a URL instance from url, ignore metadataBase
        const parsedUrl = new URL(url);
        return parsedUrl;
      } catch {}
      if (!metadataBase) {
        metadataBase = createLocalMetadataBase();
      }
      // Handle relative or absolute paths
      const pathname = metadataBase.pathname || '';
      const joinedPath = _path.default.posix.join(pathname, url);
      return new URL(joinedPath, metadataBase);
    }
    // Resolve with `pathname` if `url` is a relative path.
    function resolveRelativeUrl(url, pathname) {
      if (typeof url === 'string' && url.startsWith('./')) {
        return _path.default.posix.resolve(pathname, url);
      }
      return url;
    }
    // The regex is matching logic from packages/next/src/lib/load-custom-routes.ts
    const FILE_REGEX = /^(?:\/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+))(\/?|$)/i;
    function isFilePattern(pathname) {
      return FILE_REGEX.test(pathname);
    }
    // Resolve `pathname` if `url` is a relative path the compose with `metadataBase`.
    function resolveAbsoluteUrlWithPathname(
      url,
      metadataBase,
      { trailingSlash, pathname }
    ) {
      // Resolve url with pathname that always starts with `/`
      url = resolveRelativeUrl(url, pathname);
      // Convert string url or URL instance to absolute url string,
      // if there's case needs to be resolved with metadataBase
      let resolvedUrl = '';
      const result = metadataBase ? resolveUrl(url, metadataBase) : url;
      if (typeof result === 'string') {
        resolvedUrl = result;
      } else {
        resolvedUrl = result.pathname === '/' ? result.origin : result.href;
      }
      // Add trailing slash if it's enabled for urls matches the condition
      // - Not external, same origin with metadataBase
      // - Doesn't have query
      if (trailingSlash && !resolvedUrl.endsWith('/')) {
        let isRelative = resolvedUrl.startsWith('/');
        let hasQuery = resolvedUrl.includes('?');
        let isExternal = false;
        let isFileUrl = false;
        if (!isRelative) {
          try {
            const parsedUrl = new URL(resolvedUrl);
            isExternal = metadataBase != null && parsedUrl.origin !== metadataBase.origin;
            isFileUrl = isFilePattern(parsedUrl.pathname);
          } catch {
            // If it's not a valid URL, treat it as external
            isExternal = true;
          }
          if (
            // Do not apply trailing slash for file like urls, aligning with the behavior with `trailingSlash`
            !isFileUrl &&
            !isExternal &&
            !hasQuery
          )
            return `${resolvedUrl}/`;
        }
      }
      return resolvedUrl;
    }

    //# sourceMappingURL=resolve-url.js.map
  },
  3892: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'nonNullable', {
      enumerable: true,
      get: function () {
        return nonNullable;
      },
    });
    function nonNullable(value) {
      return value !== null && value !== undefined;
    }

    //# sourceMappingURL=non-nullable.js.map
  },
  9018: function (__unused_webpack_module, exports) {
    'use strict';
    // ISC License
    // Copyright (c) 2021 Alexey Raspopov, Kostiantyn Denysov, Anton Verinov
    // Permission to use, copy, modify, and/or distribute this software for any
    // purpose with or without fee is hereby granted, provided that the above
    // copyright notice and this permission notice appear in all copies.
    // THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    // WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    // MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    // ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    // WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    // ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    // OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
    //
    // https://github.com/alexeyraspopov/picocolors/blob/b6261487e7b81aaab2440e397a356732cad9e342/picocolors.js#L1

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      bgBlack: function () {
        return bgBlack;
      },
      bgBlue: function () {
        return bgBlue;
      },
      bgCyan: function () {
        return bgCyan;
      },
      bgGreen: function () {
        return bgGreen;
      },
      bgMagenta: function () {
        return bgMagenta;
      },
      bgRed: function () {
        return bgRed;
      },
      bgWhite: function () {
        return bgWhite;
      },
      bgYellow: function () {
        return bgYellow;
      },
      black: function () {
        return black;
      },
      blue: function () {
        return blue;
      },
      bold: function () {
        return bold;
      },
      cyan: function () {
        return cyan;
      },
      dim: function () {
        return dim;
      },
      gray: function () {
        return gray;
      },
      green: function () {
        return green;
      },
      hidden: function () {
        return hidden;
      },
      inverse: function () {
        return inverse;
      },
      italic: function () {
        return italic;
      },
      magenta: function () {
        return magenta;
      },
      purple: function () {
        return purple;
      },
      red: function () {
        return red;
      },
      reset: function () {
        return reset;
      },
      strikethrough: function () {
        return strikethrough;
      },
      underline: function () {
        return underline;
      },
      white: function () {
        return white;
      },
      yellow: function () {
        return yellow;
      },
    });
    var _globalThis;
    const { env, stdout } =
      ((_globalThis = globalThis) == null ? void 0 : _globalThis.process) ?? {};
    const enabled =
      env &&
      !env.NO_COLOR &&
      (env.FORCE_COLOR ||
        ((stdout == null ? void 0 : stdout.isTTY) && !env.CI && env.TERM !== 'dumb'));
    const replaceClose = (str, close, replace, index) => {
      const start = str.substring(0, index) + replace;
      const end = str.substring(index + close.length);
      const nextIndex = end.indexOf(close);
      return ~nextIndex
        ? start + replaceClose(end, close, replace, nextIndex)
        : start + end;
    };
    const formatter = (open, close, replace = open) => {
      if (!enabled) return String;
      return (input) => {
        const string = '' + input;
        const index = string.indexOf(close, open.length);
        return ~index
          ? open + replaceClose(string, close, replace, index) + close
          : open + string + close;
      };
    };
    const reset = enabled ? (s) => `\x1b[0m${s}\x1b[0m` : String;
    const bold = formatter('\x1b[1m', '\x1b[22m', '\x1b[22m\x1b[1m');
    const dim = formatter('\x1b[2m', '\x1b[22m', '\x1b[22m\x1b[2m');
    const italic = formatter('\x1b[3m', '\x1b[23m');
    const underline = formatter('\x1b[4m', '\x1b[24m');
    const inverse = formatter('\x1b[7m', '\x1b[27m');
    const hidden = formatter('\x1b[8m', '\x1b[28m');
    const strikethrough = formatter('\x1b[9m', '\x1b[29m');
    const black = formatter('\x1b[30m', '\x1b[39m');
    const red = formatter('\x1b[31m', '\x1b[39m');
    const green = formatter('\x1b[32m', '\x1b[39m');
    const yellow = formatter('\x1b[33m', '\x1b[39m');
    const blue = formatter('\x1b[34m', '\x1b[39m');
    const magenta = formatter('\x1b[35m', '\x1b[39m');
    const purple = formatter('\x1b[38;2;173;127;168m', '\x1b[39m');
    const cyan = formatter('\x1b[36m', '\x1b[39m');
    const white = formatter('\x1b[37m', '\x1b[39m');
    const gray = formatter('\x1b[90m', '\x1b[39m');
    const bgBlack = formatter('\x1b[40m', '\x1b[49m');
    const bgRed = formatter('\x1b[41m', '\x1b[49m');
    const bgGreen = formatter('\x1b[42m', '\x1b[49m');
    const bgYellow = formatter('\x1b[43m', '\x1b[49m');
    const bgBlue = formatter('\x1b[44m', '\x1b[49m');
    const bgMagenta = formatter('\x1b[45m', '\x1b[49m');
    const bgCyan = formatter('\x1b[46m', '\x1b[49m');
    const bgWhite = formatter('\x1b[47m', '\x1b[49m');

    //# sourceMappingURL=picocolors.js.map
  },
  4230: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      atLeastOneTask: function () {
        return atLeastOneTask;
      },
      scheduleImmediate: function () {
        return scheduleImmediate;
      },
      scheduleOnNextTick: function () {
        return scheduleOnNextTick;
      },
      waitAtLeastOneReactRenderTask: function () {
        return waitAtLeastOneReactRenderTask;
      },
    });
    const scheduleOnNextTick = (cb) => {
      // We use Promise.resolve().then() here so that the operation is scheduled at
      // the end of the promise job queue, we then add it to the next process tick
      // to ensure it's evaluated afterwards.
      //
      // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255
      //
      Promise.resolve().then(() => {
        if (false) {
        } else {
          process.nextTick(cb);
        }
      });
    };
    const scheduleImmediate = (cb) => {
      if (false) {
      } else {
        setImmediate(cb);
      }
    };
    function atLeastOneTask() {
      return new Promise((resolve) => scheduleImmediate(resolve));
    }
    function waitAtLeastOneReactRenderTask() {
      if (false) {
      } else {
        return new Promise((r) => setImmediate(r));
      }
    }

    //# sourceMappingURL=scheduler.js.map
  },
  83: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      isFullStringUrl: function () {
        return isFullStringUrl;
      },
      parseUrl: function () {
        return parseUrl;
      },
      stripNextRscUnionQuery: function () {
        return stripNextRscUnionQuery;
      },
    });
    const _approuterheaders = __webpack_require__(137);
    const DUMMY_ORIGIN = 'http://n';
    function isFullStringUrl(url) {
      return /https?:\/\//.test(url);
    }
    function parseUrl(url) {
      let parsed = undefined;
      try {
        parsed = new URL(url, DUMMY_ORIGIN);
      } catch {}
      return parsed;
    }
    function stripNextRscUnionQuery(relativeUrl) {
      const urlInstance = new URL(relativeUrl, DUMMY_ORIGIN);
      urlInstance.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);
      return urlInstance.pathname + urlInstance.search;
    }

    //# sourceMappingURL=url.js.map
  },
  7316: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'collectSegmentData', {
      enumerable: true,
      get: function () {
        return collectSegmentData;
      },
    });
    const _jsxruntime = __webpack_require__(9133);
    const _clientedge = __webpack_require__(4999);
    const _staticedge = __webpack_require__(4176);
    const _nodewebstreamshelper = __webpack_require__(227);
    const _scheduler = __webpack_require__(4230);
    const _segmentvalueencoding = __webpack_require__(9021);
    const _createerrorhandler = __webpack_require__(3805);
    function onSegmentPrerenderError(error) {
      const digest = (0, _createerrorhandler.getDigestForWellKnownError)(error);
      if (digest) {
        return digest;
      }
      // We don't need to log the errors because we would have already done that
      // when generating the original Flight stream for the whole page.
    }
    async function collectSegmentData(
      shouldAssumePartialData,
      fullPageDataBuffer,
      staleTime,
      clientModules,
      serverConsumerManifest,
      fallbackRouteParams
    ) {
      // Traverse the router tree and generate a prefetch response for each segment.
      // A mutable map to collect the results as we traverse the route tree.
      const resultMap = new Map();
      // Before we start, warm up the module cache by decoding the page data once.
      // Then we can assume that any remaining async tasks that occur the next time
      // are due to hanging promises caused by dynamic data access. Note we only
      // have to do this once per page, not per individual segment.
      //
      try {
        await (0, _clientedge.createFromReadableStream)(
          (0, _nodewebstreamshelper.streamFromBuffer)(fullPageDataBuffer),
          {
            serverConsumerManifest,
          }
        );
        await (0, _scheduler.waitAtLeastOneReactRenderTask)();
      } catch {}
      // Create an abort controller that we'll use to stop the stream.
      const abortController = new AbortController();
      const onCompletedProcessingRouteTree = async () => {
        // Since all we're doing is decoding and re-encoding a cached prerender, if
        // serializing the stream takes longer than a microtask, it must because of
        // hanging promises caused by dynamic data.
        await (0, _scheduler.waitAtLeastOneReactRenderTask)();
        abortController.abort();
      };
      // Generate a stream for the route tree prefetch. While we're walking the
      // tree, we'll also spawn additional tasks to generate the segment prefetches.
      // The promises for these tasks are pushed to a mutable array that we will
      // await once the route tree is fully rendered.
      const segmentTasks = [];
      const { prelude: treeStream } = await (0, _staticedge.unstable_prerender)(
        // RootTreePrefetch is not a valid return type for a React component, but
        // we need to use a component so that when we decode the original stream
        // inside of it, the side effects are transferred to the new stream.
        // @ts-expect-error
        /*#__PURE__*/ (0, _jsxruntime.jsx)(PrefetchTreeData, {
          shouldAssumePartialData: shouldAssumePartialData,
          fullPageDataBuffer: fullPageDataBuffer,
          fallbackRouteParams: fallbackRouteParams,
          serverConsumerManifest: serverConsumerManifest,
          clientModules: clientModules,
          staleTime: staleTime,
          segmentTasks: segmentTasks,
          onCompletedProcessingRouteTree: onCompletedProcessingRouteTree,
        }),
        clientModules,
        {
          signal: abortController.signal,
          onError: onSegmentPrerenderError,
        }
      );
      // Write the route tree to a special `/_tree` segment.
      const treeBuffer = await (0, _nodewebstreamshelper.streamToBuffer)(treeStream);
      resultMap.set('/_tree', treeBuffer);
      // Now that we've finished rendering the route tree, all the segment tasks
      // should have been spawned. Await them in parallel and write the segment
      // prefetches to the result map.
      for (const [segmentPath, buffer] of await Promise.all(segmentTasks)) {
        resultMap.set(segmentPath, buffer);
      }
      return resultMap;
    }
    async function PrefetchTreeData({
      shouldAssumePartialData,
      fullPageDataBuffer,
      fallbackRouteParams,
      serverConsumerManifest,
      clientModules,
      staleTime,
      segmentTasks,
      onCompletedProcessingRouteTree,
    }) {
      // We're currently rendering a Flight response for the route tree prefetch.
      // Inside this component, decode the Flight stream for the whole page. This is
      // a hack to transfer the side effects from the original Flight stream (e.g.
      // Float preloads) onto the Flight stream for the tree prefetch.
      // TODO: React needs a better way to do this. Needed for Server Actions, too.
      const initialRSCPayload = await (0, _clientedge.createFromReadableStream)(
        createUnclosingPrefetchStream(
          (0, _nodewebstreamshelper.streamFromBuffer)(fullPageDataBuffer)
        ),
        {
          serverConsumerManifest,
        }
      );
      const buildId = initialRSCPayload.b;
      // FlightDataPath is an unsound type, hence the additional checks.
      const flightDataPaths = initialRSCPayload.f;
      if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {
        console.error(
          'Internal Next.js error: InitialRSCPayload does not match the expected ' +
            'shape for a prerendered page during segment prefetch generation.'
        );
        return null;
      }
      const flightRouterState = flightDataPaths[0][0];
      const seedData = flightDataPaths[0][1];
      const head = flightDataPaths[0][2];
      // Compute the route metadata tree by traversing the FlightRouterState. As we
      // walk the tree, we will also spawn a task to produce a prefetch response for
      // each segment.
      const tree = collectSegmentDataImpl(
        shouldAssumePartialData,
        flightRouterState,
        buildId,
        seedData,
        fallbackRouteParams,
        fullPageDataBuffer,
        clientModules,
        serverConsumerManifest,
        _segmentvalueencoding.ROOT_SEGMENT_KEY,
        segmentTasks
      );
      const isHeadPartial =
        shouldAssumePartialData || (await isPartialRSCData(head, clientModules));
      // Notify the abort controller that we're done processing the route tree.
      // Anything async that happens after this point must be due to hanging
      // promises in the original stream.
      onCompletedProcessingRouteTree();
      // Render the route tree to a special `/_tree` segment.
      const treePrefetch = {
        buildId,
        tree,
        head,
        isHeadPartial,
        staleTime,
      };
      return treePrefetch;
    }
    function collectSegmentDataImpl(
      shouldAssumePartialData,
      route,
      buildId,
      seedData,
      fallbackRouteParams,
      fullPageDataBuffer,
      clientModules,
      serverConsumerManifest,
      key,
      segmentTasks
    ) {
      // Metadata about the segment. Sent as part of the tree prefetch. Null if
      // there are no children.
      let slotMetadata = null;
      const children = route[1];
      const seedDataChildren = seedData !== null ? seedData[2] : null;
      for (const parallelRouteKey in children) {
        const childRoute = children[parallelRouteKey];
        const childSegment = childRoute[0];
        const childSeedData =
          seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null;
        const childKey = (0, _segmentvalueencoding.encodeChildSegmentKey)(
          key,
          parallelRouteKey,
          Array.isArray(childSegment) && fallbackRouteParams !== null
            ? encodeSegmentWithPossibleFallbackParam(childSegment, fallbackRouteParams)
            : (0, _segmentvalueencoding.encodeSegment)(childSegment)
        );
        const childTree = collectSegmentDataImpl(
          shouldAssumePartialData,
          childRoute,
          buildId,
          childSeedData,
          fallbackRouteParams,
          fullPageDataBuffer,
          clientModules,
          serverConsumerManifest,
          childKey,
          segmentTasks
        );
        if (slotMetadata === null) {
          slotMetadata = {};
        }
        slotMetadata[parallelRouteKey] = childTree;
      }
      if (seedData !== null) {
        // Spawn a task to write the segment data to a new Flight stream.
        segmentTasks.push(
          // Since we're already in the middle of a render, wait until after the
          // current task to escape the current rendering context.
          (0, _scheduler.waitAtLeastOneReactRenderTask)().then(() =>
            renderSegmentPrefetch(
              shouldAssumePartialData,
              buildId,
              seedData,
              key,
              clientModules
            )
          )
        );
      } else {
        // This segment does not have any seed data. Skip generating a prefetch
        // response for it. We'll still include it in the route tree, though.
        // TODO: We should encode in the route tree whether a segment is missing
        // so we don't attempt to fetch it for no reason. As of now this shouldn't
        // ever happen in practice, though.
      }
      // Metadata about the segment. Sent to the client as part of the
      // tree prefetch.
      return {
        segment: route[0],
        slots: slotMetadata,
        isRootLayout: route[4] === true,
      };
    }
    function encodeSegmentWithPossibleFallbackParam(segment, fallbackRouteParams) {
      const name = segment[0];
      if (!fallbackRouteParams.has(name)) {
        // Normal case. No matching fallback parameter.
        return (0, _segmentvalueencoding.encodeSegment)(segment);
      }
      // This segment includes a fallback parameter. During prerendering, a random
      // placeholder value was used; however, for segment prefetches, we need the
      // segment path to be predictable so the server can create a rewrite for it.
      // So, replace the placeholder segment value with a "template" string,
      // e.g. `[name]`.
      // TODO: This will become a bit cleaner once remove route parameters from the
      // server response, and instead add them to the segment keys on the client.
      // Instead of a string replacement, like we do here, route params will always
      // be encoded in separate step from the rest of the segment, not just in the
      // case of fallback params.
      const encodedSegment = (0, _segmentvalueencoding.encodeSegment)(segment);
      const lastIndex = encodedSegment.lastIndexOf('$');
      const encodedFallbackSegment = // NOTE: This is guaranteed not to clash with the rest of the segment
        // because non-simple characters (including [ and ]) trigger a base
        // 64 encoding.
        encodedSegment.substring(0, lastIndex + 1) + `[${name}]`;
      return encodedFallbackSegment;
    }
    async function renderSegmentPrefetch(
      shouldAssumePartialData,
      buildId,
      seedData,
      key,
      clientModules
    ) {
      // Render the segment data to a stream.
      // In the future, this is where we can include additional metadata, like the
      // stale time and cache tags.
      const rsc = seedData[1];
      const loading = seedData[3];
      const segmentPrefetch = {
        buildId,
        rsc,
        loading,
        isPartial:
          shouldAssumePartialData || (await isPartialRSCData(rsc, clientModules)),
      };
      // Since all we're doing is decoding and re-encoding a cached prerender, if
      // it takes longer than a microtask, it must because of hanging promises
      // caused by dynamic data. Abort the stream at the end of the current task.
      const abortController = new AbortController();
      (0, _scheduler.waitAtLeastOneReactRenderTask)().then(() => abortController.abort());
      const { prelude: segmentStream } = await (0, _staticedge.unstable_prerender)(
        segmentPrefetch,
        clientModules,
        {
          signal: abortController.signal,
          onError: onSegmentPrerenderError,
        }
      );
      const segmentBuffer = await (0, _nodewebstreamshelper.streamToBuffer)(
        segmentStream
      );
      if (key === _segmentvalueencoding.ROOT_SEGMENT_KEY) {
        return ['/_index', segmentBuffer];
      } else {
        return [key, segmentBuffer];
      }
    }
    async function isPartialRSCData(rsc, clientModules) {
      // We can determine if a segment contains only partial data if it takes longer
      // than a task to encode, because dynamic data is encoded as an infinite
      // promise. We must do this in a separate Flight prerender from the one that
      // actually generates the prefetch stream because we need to include
      // `isPartial` in the stream itself.
      let isPartial = false;
      const abortController = new AbortController();
      (0, _scheduler.waitAtLeastOneReactRenderTask)().then(() => {
        // If we haven't yet finished the outer task, then it must be because we
        // accessed dynamic data.
        isPartial = true;
        abortController.abort();
      });
      await (0, _staticedge.unstable_prerender)(rsc, clientModules, {
        signal: abortController.signal,
        onError() {},
      });
      return isPartial;
    }
    function createUnclosingPrefetchStream(originalFlightStream) {
      // When PPR is enabled, prefetch streams may contain references that never
      // resolve, because that's how we encode dynamic data access. In the decoded
      // object returned by the Flight client, these are reified into hanging
      // promises that suspend during render, which is effectively what we want.
      // The UI resolves when it switches to the dynamic data stream
      // (via useDeferredValue(dynamic, static)).
      //
      // However, the Flight implementation currently errors if the server closes
      // the response before all the references are resolved. As a cheat to work
      // around this, we wrap the original stream in a new stream that never closes,
      // and therefore doesn't error.
      const reader = originalFlightStream.getReader();
      return new ReadableStream({
        async pull(controller) {
          while (true) {
            const { done, value } = await reader.read();
            if (!done) {
              // Pass to the target stream and keep consuming the Flight response
              // from the server.
              controller.enqueue(value);
              continue;
            }
            // The server stream has closed. Exit, but intentionally do not close
            // the target stream.
            return;
          }
        },
      });
    }

    //# sourceMappingURL=collect-segment-data.js.map
  },
  3805: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      createFlightReactServerErrorHandler: function () {
        return createFlightReactServerErrorHandler;
      },
      createHTMLErrorHandler: function () {
        return createHTMLErrorHandler;
      },
      createHTMLReactServerErrorHandler: function () {
        return createHTMLReactServerErrorHandler;
      },
      getDigestForWellKnownError: function () {
        return getDigestForWellKnownError;
      },
      isUserLandError: function () {
        return isUserLandError;
      },
    });
    const _stringhash = /*#__PURE__*/ _interop_require_default(__webpack_require__(2618));
    const _formatservererror = __webpack_require__(9416);
    const _tracer = __webpack_require__(9223);
    const _pipereadable = __webpack_require__(2166);
    const _bailouttocsr = __webpack_require__(7940);
    const _hooksservercontext = __webpack_require__(1696);
    const _isnextroutererror = __webpack_require__(7394);
    const _iserror = __webpack_require__(1506);
    const _errortelemetryutils = __webpack_require__(9365);
    function _interop_require_default(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }
    function getDigestForWellKnownError(error) {
      // If we're bailing out to CSR, we don't need to log the error.
      if ((0, _bailouttocsr.isBailoutToCSRError)(error)) return error.digest;
      // If this is a navigation error, we don't need to log the error.
      if ((0, _isnextroutererror.isNextRouterError)(error)) return error.digest;
      // If this error occurs, we know that we should be stopping the static
      // render. This is only thrown in static generation when PPR is not enabled,
      // which causes the whole page to be marked as dynamic. We don't need to
      // tell the user about this error, as it's not actionable.
      if ((0, _hooksservercontext.isDynamicServerError)(error)) return error.digest;
      return undefined;
    }
    function createFlightReactServerErrorHandler(
      shouldFormatError,
      onReactServerRenderError
    ) {
      return (thrownValue) => {
        if (typeof thrownValue === 'string') {
          // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
          return (0, _stringhash.default)(thrownValue).toString();
        }
        // If the response was closed, we don't need to log the error.
        if ((0, _pipereadable.isAbortError)(thrownValue)) return;
        const digest = getDigestForWellKnownError(thrownValue);
        if (digest) {
          return digest;
        }
        const err = (0, _iserror.getProperError)(thrownValue);
        // If the error already has a digest, respect the original digest,
        // so it won't get re-generated into another new error.
        if (!err.digest) {
          // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
          err.digest = (0, _stringhash.default)(err.message + err.stack || '').toString();
        }
        // Format server errors in development to add more helpful error messages
        if (shouldFormatError) {
          (0, _formatservererror.formatServerError)(err);
        }
        // Record exception in an active span, if available.
        const span = (0, _tracer.getTracer)().getActiveScopeSpan();
        if (span) {
          span.recordException(err);
          span.setStatus({
            code: _tracer.SpanStatusCode.ERROR,
            message: err.message,
          });
        }
        onReactServerRenderError(err);
        return (0, _errortelemetryutils.createDigestWithErrorCode)(
          thrownValue,
          err.digest
        );
      };
    }
    function createHTMLReactServerErrorHandler(
      shouldFormatError,
      isNextExport,
      reactServerErrors,
      silenceLogger,
      onReactServerRenderError
    ) {
      return (thrownValue) => {
        var _err_message;
        if (typeof thrownValue === 'string') {
          // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
          return (0, _stringhash.default)(thrownValue).toString();
        }
        // If the response was closed, we don't need to log the error.
        if ((0, _pipereadable.isAbortError)(thrownValue)) return;
        const digest = getDigestForWellKnownError(thrownValue);
        if (digest) {
          return digest;
        }
        const err = (0, _iserror.getProperError)(thrownValue);
        // If the error already has a digest, respect the original digest,
        // so it won't get re-generated into another new error.
        if (!err.digest) {
          // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
          err.digest = (0, _stringhash.default)(
            err.message + (err.stack || '')
          ).toString();
        }
        // @TODO by putting this here and not at the top it is possible that
        // we don't error the build in places we actually expect to
        if (!reactServerErrors.has(err.digest)) {
          reactServerErrors.set(err.digest, err);
        }
        // Format server errors in development to add more helpful error messages
        if (shouldFormatError) {
          (0, _formatservererror.formatServerError)(err);
        }
        // Don't log the suppressed error during export
        if (
          !(
            isNextExport &&
            (err == null
              ? void 0
              : (_err_message = err.message) == null
                ? void 0
                : _err_message.includes(
                    'The specific message is omitted in production builds to avoid leaking sensitive details.'
                  ))
          )
        ) {
          // Record exception in an active span, if available.
          const span = (0, _tracer.getTracer)().getActiveScopeSpan();
          if (span) {
            span.recordException(err);
            span.setStatus({
              code: _tracer.SpanStatusCode.ERROR,
              message: err.message,
            });
          }
          if (!silenceLogger) {
            onReactServerRenderError == null ? void 0 : onReactServerRenderError(err);
          }
        }
        return (0, _errortelemetryutils.createDigestWithErrorCode)(
          thrownValue,
          err.digest
        );
      };
    }
    function createHTMLErrorHandler(
      shouldFormatError,
      isNextExport,
      reactServerErrors,
      allCapturedErrors,
      silenceLogger,
      onHTMLRenderSSRError
    ) {
      return (thrownValue, errorInfo) => {
        var _err_message;
        let isSSRError = true;
        allCapturedErrors.push(thrownValue);
        // If the response was closed, we don't need to log the error.
        if ((0, _pipereadable.isAbortError)(thrownValue)) return;
        const digest = getDigestForWellKnownError(thrownValue);
        if (digest) {
          return digest;
        }
        const err = (0, _iserror.getProperError)(thrownValue);
        // If the error already has a digest, respect the original digest,
        // so it won't get re-generated into another new error.
        if (err.digest) {
          if (reactServerErrors.has(err.digest)) {
            // This error is likely an obfuscated error from react-server.
            // We recover the original error here.
            thrownValue = reactServerErrors.get(err.digest);
            isSSRError = false;
          } else {
            // The error is not from react-server but has a digest
            // from other means so we don't need to produce a new one
          }
        } else {
          err.digest = (0, _stringhash.default)(
            err.message +
              ((errorInfo == null ? void 0 : errorInfo.componentStack) || err.stack || '')
          ).toString();
        }
        // Format server errors in development to add more helpful error messages
        if (shouldFormatError) {
          (0, _formatservererror.formatServerError)(err);
        }
        // Don't log the suppressed error during export
        if (
          !(
            isNextExport &&
            (err == null
              ? void 0
              : (_err_message = err.message) == null
                ? void 0
                : _err_message.includes(
                    'The specific message is omitted in production builds to avoid leaking sensitive details.'
                  ))
          )
        ) {
          // Record exception in an active span, if available.
          const span = (0, _tracer.getTracer)().getActiveScopeSpan();
          if (span) {
            span.recordException(err);
            span.setStatus({
              code: _tracer.SpanStatusCode.ERROR,
              message: err.message,
            });
          }
          if (
            !silenceLogger && // HTML errors contain RSC errors as well, filter them out before reporting
            isSSRError
          ) {
            onHTMLRenderSSRError(err, errorInfo);
          }
        }
        return (0, _errortelemetryutils.createDigestWithErrorCode)(
          thrownValue,
          err.digest
        );
      };
    }
    function isUserLandError(err) {
      return (
        !(0, _pipereadable.isAbortError)(err) &&
        !(0, _bailouttocsr.isBailoutToCSRError)(err) &&
        !(0, _isnextroutererror.isNextRouterError)(err)
      );
    }

    //# sourceMappingURL=create-error-handler.js.map
  },
  7811: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';
    /**
     * The functions provided by this module are used to communicate certain properties about
     * the currently running code so that Next.js can make decisions on how to handle the
     * current execution in different rendering modes such as pre-rendering, resuming, and
     * SSR.
     *
     * Today Next.js treats all code as potentially static. Certain APIs may only make sense
     * when dynamically rendering. Traditionally this meant deopting the entire render to
     * dynamic however with PPR we can now deopt parts of a React tree as dynamic while still
     * keeping other parts static. There are really two different kinds of Dynamic
     * indications.
     *
     * The first is simply an intention to be dynamic. unstable_noStore is an example of this
     * where the currently executing code simply declares that the current scope is dynamic
     * but if you use it inside unstable_cache it can still be cached. This type of indication
     * can be removed if we ever make the default dynamic to begin with because the only way
     * you would ever be static is inside a cache scope which this indication does not
     * affect.
     *
     * The second is an indication that a dynamic data source was read. This is a stronger
     * form of dynamic because it means that it is inappropriate to cache this at all. using a
     * dynamic data source inside unstable_cache should error. If you want to use some dynamic
     * data inside unstable_cache you should read that data outside the cache and pass it in
     * as an argument to the cached function.
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      Postpone: function () {
        return Postpone;
      },
      abortAndThrowOnSynchronousRequestDataAccess: function () {
        return abortAndThrowOnSynchronousRequestDataAccess;
      },
      abortOnSynchronousPlatformIOAccess: function () {
        return abortOnSynchronousPlatformIOAccess;
      },
      accessedDynamicData: function () {
        return accessedDynamicData;
      },
      annotateDynamicAccess: function () {
        return annotateDynamicAccess;
      },
      consumeDynamicAccess: function () {
        return consumeDynamicAccess;
      },
      createDynamicTrackingState: function () {
        return createDynamicTrackingState;
      },
      createDynamicValidationState: function () {
        return createDynamicValidationState;
      },
      createHangingInputAbortSignal: function () {
        return createHangingInputAbortSignal;
      },
      createPostponedAbortSignal: function () {
        return createPostponedAbortSignal;
      },
      formatDynamicAPIAccesses: function () {
        return formatDynamicAPIAccesses;
      },
      getFirstDynamicReason: function () {
        return getFirstDynamicReason;
      },
      isDynamicPostpone: function () {
        return isDynamicPostpone;
      },
      isPrerenderInterruptedError: function () {
        return isPrerenderInterruptedError;
      },
      markCurrentScopeAsDynamic: function () {
        return markCurrentScopeAsDynamic;
      },
      postponeWithTracking: function () {
        return postponeWithTracking;
      },
      throwIfDisallowedDynamic: function () {
        return throwIfDisallowedDynamic;
      },
      throwToInterruptStaticGeneration: function () {
        return throwToInterruptStaticGeneration;
      },
      trackAllowedDynamicAccess: function () {
        return trackAllowedDynamicAccess;
      },
      trackDynamicDataInDynamicRender: function () {
        return trackDynamicDataInDynamicRender;
      },
      trackFallbackParamAccessed: function () {
        return trackFallbackParamAccessed;
      },
      trackSynchronousPlatformIOAccessInDev: function () {
        return trackSynchronousPlatformIOAccessInDev;
      },
      trackSynchronousRequestDataAccessInDev: function () {
        return trackSynchronousRequestDataAccessInDev;
      },
      useDynamicRouteParams: function () {
        return useDynamicRouteParams;
      },
    });
    const _react = /*#__PURE__*/ _interop_require_default(__webpack_require__(8516));
    const _hooksservercontext = __webpack_require__(1696);
    const _staticgenerationbailout = __webpack_require__(8489);
    const _workunitasyncstorageexternal = __webpack_require__(412);
    const _workasyncstorageexternal = __webpack_require__(9348);
    const _dynamicrenderingutils = __webpack_require__(8458);
    const _metadataconstants = __webpack_require__(3288);
    const _scheduler = __webpack_require__(4230);
    function _interop_require_default(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }
    const hasPostpone = typeof _react.default.unstable_postpone === 'function';
    function createDynamicTrackingState(isDebugDynamicAccesses) {
      return {
        isDebugDynamicAccesses,
        dynamicAccesses: [],
        syncDynamicExpression: undefined,
        syncDynamicErrorWithStack: null,
      };
    }
    function createDynamicValidationState() {
      return {
        hasSuspendedDynamic: false,
        hasDynamicMetadata: false,
        hasDynamicViewport: false,
        hasSyncDynamicErrors: false,
        dynamicErrors: [],
      };
    }
    function getFirstDynamicReason(trackingState) {
      var _trackingState_dynamicAccesses_;
      return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null
        ? void 0
        : _trackingState_dynamicAccesses_.expression;
    }
    function markCurrentScopeAsDynamic(store, workUnitStore, expression) {
      if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
          // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
          // creates a cache boundary. This is subtly different from reading a dynamic data source which is
          // forbidden inside a cache scope.
          return;
        }
      }
      // If we're forcing dynamic rendering or we're forcing static rendering, we
      // don't need to do anything here because the entire page is already dynamic
      // or it's static and it should not throw or postpone here.
      if (store.forceDynamic || store.forceStatic) return;
      if (store.dynamicShouldError) {
        throw Object.defineProperty(
          new _staticgenerationbailout.StaticGenBailoutError(
            `Route ${store.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
          ),
          '__NEXT_ERROR_CODE',
          {
            value: 'E553',
            enumerable: false,
            configurable: true,
          }
        );
      }
      if (workUnitStore) {
        if (workUnitStore.type === 'prerender-ppr') {
          postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);
        } else if (workUnitStore.type === 'prerender-legacy') {
          workUnitStore.revalidate = 0;
          // We aren't prerendering but we are generating a static page. We need to bail out of static generation
          const err = Object.defineProperty(
            new _hooksservercontext.DynamicServerError(
              `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E550',
              enumerable: false,
              configurable: true,
            }
          );
          store.dynamicUsageDescription = expression;
          store.dynamicUsageStack = err.stack;
          throw err;
        } else if (true && workUnitStore && workUnitStore.type === 'request') {
          workUnitStore.usedDynamic = true;
        }
      }
    }
    function trackFallbackParamAccessed(store, expression) {
      const prerenderStore =
        _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return;
      postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking);
    }
    function throwToInterruptStaticGeneration(expression, store, prerenderStore) {
      // We aren't prerendering but we are generating a static page. We need to bail out of static generation
      const err = Object.defineProperty(
        new _hooksservercontext.DynamicServerError(
          `Route ${store.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E558',
          enumerable: false,
          configurable: true,
        }
      );
      prerenderStore.revalidate = 0;
      store.dynamicUsageDescription = expression;
      store.dynamicUsageStack = err.stack;
      throw err;
    }
    function trackDynamicDataInDynamicRender(_store, workUnitStore) {
      if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
          // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
          // creates a cache boundary. This is subtly different from reading a dynamic data source which is
          // forbidden inside a cache scope.
          return;
        }
        if (
          workUnitStore.type === 'prerender' ||
          workUnitStore.type === 'prerender-legacy'
        ) {
          workUnitStore.revalidate = 0;
        }
        if (true && workUnitStore.type === 'request') {
          workUnitStore.usedDynamic = true;
        }
      }
    }
    // Despite it's name we don't actually abort unless we have a controller to call abort on
    // There are times when we let a prerender run long to discover caches where we want the semantics
    // of tracking dynamic access without terminating the prerender early
    function abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {
      const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;
      const error = createPrerenderInterruptedError(reason);
      prerenderStore.controller.abort(error);
      const dynamicTracking = prerenderStore.dynamicTracking;
      if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
          // When we aren't debugging, we don't need to create another error for the
          // stack trace.
          stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
          expression,
        });
      }
    }
    function abortOnSynchronousPlatformIOAccess(
      route,
      expression,
      errorWithStack,
      prerenderStore
    ) {
      const dynamicTracking = prerenderStore.dynamicTracking;
      if (dynamicTracking) {
        if (dynamicTracking.syncDynamicErrorWithStack === null) {
          dynamicTracking.syncDynamicExpression = expression;
          dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
        }
      }
      abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
    }
    function trackSynchronousPlatformIOAccessInDev(requestStore) {
      // We don't actually have a controller to abort but we do the semantic equivalent by
      // advancing the request store out of prerender mode
      requestStore.prerenderPhase = false;
    }
    function abortAndThrowOnSynchronousRequestDataAccess(
      route,
      expression,
      errorWithStack,
      prerenderStore
    ) {
      const prerenderSignal = prerenderStore.controller.signal;
      if (prerenderSignal.aborted === false) {
        // TODO it would be better to move this aborted check into the callsite so we can avoid making
        // the error object when it isn't relevant to the aborting of the prerender however
        // since we need the throw semantics regardless of whether we abort it is easier to land
        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer
        // to ideal implementation
        const dynamicTracking = prerenderStore.dynamicTracking;
        if (dynamicTracking) {
          if (dynamicTracking.syncDynamicErrorWithStack === null) {
            dynamicTracking.syncDynamicExpression = expression;
            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
            if (prerenderStore.validating === true) {
              // We always log Request Access in dev at the point of calling the function
              // So we mark the dynamic validation as not requiring it to be printed
              dynamicTracking.syncDynamicLogged = true;
            }
          }
        }
        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
      }
      throw createPrerenderInterruptedError(
        `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`
      );
    }
    const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;
    function Postpone({ reason, route }) {
      const prerenderStore =
        _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      const dynamicTracking =
        prerenderStore && prerenderStore.type === 'prerender-ppr'
          ? prerenderStore.dynamicTracking
          : null;
      postponeWithTracking(route, reason, dynamicTracking);
    }
    function postponeWithTracking(route, expression, dynamicTracking) {
      assertPostpone();
      if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
          // When we aren't debugging, we don't need to create another error for the
          // stack trace.
          stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
          expression,
        });
      }
      _react.default.unstable_postpone(createPostponeReason(route, expression));
    }
    function createPostponeReason(route, expression) {
      return (
        `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +
        `React throws this special object to indicate where. It should not be caught by ` +
        `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`
      );
    }
    function isDynamicPostpone(err) {
      if (typeof err === 'object' && err !== null && typeof err.message === 'string') {
        return isDynamicPostponeReason(err.message);
      }
      return false;
    }
    function isDynamicPostponeReason(reason) {
      return (
        reason.includes(
          'needs to bail out of prerendering at this point because it used'
        ) &&
        reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error')
      );
    }
    if (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {
      throw Object.defineProperty(
        new Error(
          'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E296',
          enumerable: false,
          configurable: true,
        }
      );
    }
    const NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';
    function createPrerenderInterruptedError(message) {
      const error = Object.defineProperty(new Error(message), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: false,
        configurable: true,
      });
      error.digest = NEXT_PRERENDER_INTERRUPTED;
      return error;
    }
    function isPrerenderInterruptedError(error) {
      return (
        typeof error === 'object' &&
        error !== null &&
        error.digest === NEXT_PRERENDER_INTERRUPTED &&
        'name' in error &&
        'message' in error &&
        error instanceof Error
      );
    }
    function accessedDynamicData(dynamicAccesses) {
      return dynamicAccesses.length > 0;
    }
    function consumeDynamicAccess(serverDynamic, clientDynamic) {
      // We mutate because we only call this once we are no longer writing
      // to the dynamicTrackingState and it's more efficient than creating a new
      // array.
      serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);
      return serverDynamic.dynamicAccesses;
    }
    function formatDynamicAPIAccesses(dynamicAccesses) {
      return dynamicAccesses
        .filter((access) => typeof access.stack === 'string' && access.stack.length > 0)
        .map(({ expression, stack }) => {
          stack = stack
            .split('\n') // Remove the "Error: " prefix from the first line of the stack trace as
            // well as the first 4 lines of the stack trace which is the distance
            // from the user code and the `new Error().stack` call.
            .slice(4)
            .filter((line) => {
              // Exclude Next.js internals from the stack trace.
              if (line.includes('node_modules/next/')) {
                return false;
              }
              // Exclude anonymous functions from the stack trace.
              if (line.includes(' (<anonymous>)')) {
                return false;
              }
              // Exclude Node.js internals from the stack trace.
              if (line.includes(' (node:')) {
                return false;
              }
              return true;
            })
            .join('\n');
          return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
        });
    }
    function assertPostpone() {
      if (!hasPostpone) {
        throw Object.defineProperty(
          new Error(
            `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`
          ),
          '__NEXT_ERROR_CODE',
          {
            value: 'E224',
            enumerable: false,
            configurable: true,
          }
        );
      }
    }
    function createPostponedAbortSignal(reason) {
      assertPostpone();
      const controller = new AbortController();
      // We get our hands on a postpone instance by calling postpone and catching the throw
      try {
        _react.default.unstable_postpone(reason);
      } catch (x) {
        controller.abort(x);
      }
      return controller.signal;
    }
    function createHangingInputAbortSignal(workUnitStore) {
      const controller = new AbortController();
      if (workUnitStore.cacheSignal) {
        // If we have a cacheSignal it means we're in a prospective render. If the input
        // we're waiting on is coming from another cache, we do want to wait for it so that
        // we can resolve this cache entry too.
        workUnitStore.cacheSignal.inputReady().then(() => {
          controller.abort();
        });
      } else {
        // Otherwise we're in the final render and we should already have all our caches
        // filled. We might still be waiting on some microtasks so we wait one tick before
        // giving up. When we give up, we still want to render the content of this cache
        // as deeply as we can so that we can suspend as deeply as possible in the tree
        // or not at all if we don't end up waiting for the input.
        (0, _scheduler.scheduleOnNextTick)(() => controller.abort());
      }
      return controller.signal;
    }
    function annotateDynamicAccess(expression, prerenderStore) {
      const dynamicTracking = prerenderStore.dynamicTracking;
      if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
          stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
          expression,
        });
      }
    }
    function useDynamicRouteParams(expression) {
      const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
      if (
        workStore &&
        workStore.isStaticGeneration &&
        workStore.fallbackRouteParams &&
        workStore.fallbackRouteParams.size > 0
      ) {
        // There are fallback route params, we should track these as dynamic
        // accesses.
        const workUnitStore =
          _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
        if (workUnitStore) {
          // We're prerendering with dynamicIO or PPR or both
          if (workUnitStore.type === 'prerender') {
            // We are in a prerender with dynamicIO semantics
            // We are going to hang here and never resolve. This will cause the currently
            // rendering component to effectively be a dynamic hole
            _react.default.use(
              (0, _dynamicrenderingutils.makeHangingPromise)(
                workUnitStore.renderSignal,
                expression
              )
            );
          } else if (workUnitStore.type === 'prerender-ppr') {
            // We're prerendering with PPR
            postponeWithTracking(
              workStore.route,
              expression,
              workUnitStore.dynamicTracking
            );
          } else if (workUnitStore.type === 'prerender-legacy') {
            throwToInterruptStaticGeneration(expression, workStore, workUnitStore);
          }
        }
      }
    }
    const hasSuspenseRegex = /\n\s+at Suspense \(<anonymous>\)/;
    const hasMetadataRegex = new RegExp(
      `\\n\\s+at ${_metadataconstants.METADATA_BOUNDARY_NAME}[\\n\\s]`
    );
    const hasViewportRegex = new RegExp(
      `\\n\\s+at ${_metadataconstants.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`
    );
    const hasOutletRegex = new RegExp(
      `\\n\\s+at ${_metadataconstants.OUTLET_BOUNDARY_NAME}[\\n\\s]`
    );
    function trackAllowedDynamicAccess(
      route,
      componentStack,
      dynamicValidation,
      serverDynamic,
      clientDynamic
    ) {
      if (hasOutletRegex.test(componentStack)) {
        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.
        return;
      } else if (hasMetadataRegex.test(componentStack)) {
        dynamicValidation.hasDynamicMetadata = true;
        return;
      } else if (hasViewportRegex.test(componentStack)) {
        dynamicValidation.hasDynamicViewport = true;
        return;
      } else if (hasSuspenseRegex.test(componentStack)) {
        dynamicValidation.hasSuspendedDynamic = true;
        return;
      } else if (
        serverDynamic.syncDynamicErrorWithStack ||
        clientDynamic.syncDynamicErrorWithStack
      ) {
        dynamicValidation.hasSyncDynamicErrors = true;
        return;
      } else {
        const message = `Route "${route}": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;
        const error = createErrorWithComponentStack(message, componentStack);
        dynamicValidation.dynamicErrors.push(error);
        return;
      }
    }
    function createErrorWithComponentStack(message, componentStack) {
      const error = Object.defineProperty(new Error(message), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: false,
        configurable: true,
      });
      error.stack = 'Error: ' + message + componentStack;
      return error;
    }
    function throwIfDisallowedDynamic(
      route,
      dynamicValidation,
      serverDynamic,
      clientDynamic
    ) {
      let syncError;
      let syncExpression;
      let syncLogged;
      if (serverDynamic.syncDynamicErrorWithStack) {
        syncError = serverDynamic.syncDynamicErrorWithStack;
        syncExpression = serverDynamic.syncDynamicExpression;
        syncLogged = serverDynamic.syncDynamicLogged === true;
      } else if (clientDynamic.syncDynamicErrorWithStack) {
        syncError = clientDynamic.syncDynamicErrorWithStack;
        syncExpression = clientDynamic.syncDynamicExpression;
        syncLogged = clientDynamic.syncDynamicLogged === true;
      } else {
        syncError = null;
        syncExpression = undefined;
        syncLogged = false;
      }
      if (dynamicValidation.hasSyncDynamicErrors && syncError) {
        if (!syncLogged) {
          // In dev we already log errors about sync dynamic access. But during builds we need to ensure
          // the offending sync error is logged before we exit the build
          console.error(syncError);
        }
        // The actual error should have been logged when the sync access ocurred
        throw new _staticgenerationbailout.StaticGenBailoutError();
      }
      const dynamicErrors = dynamicValidation.dynamicErrors;
      if (dynamicErrors.length) {
        for (let i = 0; i < dynamicErrors.length; i++) {
          console.error(dynamicErrors[i]);
        }
        throw new _staticgenerationbailout.StaticGenBailoutError();
      }
      if (!dynamicValidation.hasSuspendedDynamic) {
        if (dynamicValidation.hasDynamicMetadata) {
          if (syncError) {
            console.error(syncError);
            throw Object.defineProperty(
              new _staticgenerationbailout.StaticGenBailoutError(
                `Route "${route}" has a \`generateMetadata\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`
              ),
              '__NEXT_ERROR_CODE',
              {
                value: 'E608',
                enumerable: false,
                configurable: true,
              }
            );
          }
          throw Object.defineProperty(
            new _staticgenerationbailout.StaticGenBailoutError(
              `Route "${route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or external data (\`fetch(...)\`, etc...) but the rest of the route was static or only used cached data (\`"use cache"\`). If you expected this route to be prerenderable update your \`generateMetadata\` to not use Request data and only use cached external data. Otherwise, add \`await connection()\` somewhere within this route to indicate explicitly it should not be prerendered.`
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E534',
              enumerable: false,
              configurable: true,
            }
          );
        } else if (dynamicValidation.hasDynamicViewport) {
          if (syncError) {
            console.error(syncError);
            throw Object.defineProperty(
              new _staticgenerationbailout.StaticGenBailoutError(
                `Route "${route}" has a \`generateViewport\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`
              ),
              '__NEXT_ERROR_CODE',
              {
                value: 'E573',
                enumerable: false,
                configurable: true,
              }
            );
          }
          throw Object.defineProperty(
            new _staticgenerationbailout.StaticGenBailoutError(
              `Route "${route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or external data (\`fetch(...)\`, etc...) but the rest of the route was static or only used cached data (\`"use cache"\`). If you expected this route to be prerenderable update your \`generateViewport\` to not use Request data and only use cached external data. Otherwise, add \`await connection()\` somewhere within this route to indicate explicitly it should not be prerendered.`
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E590',
              enumerable: false,
              configurable: true,
            }
          );
        }
      }
    }

    //# sourceMappingURL=dynamic-rendering.js.map
  },
  6925: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';
    // eslint-disable-next-line import/no-extraneous-dependencies

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ClientPageRoot: function () {
        return _clientpage.ClientPageRoot;
      },
      ClientSegmentRoot: function () {
        return _clientsegment.ClientSegmentRoot;
      },
      HTTPAccessFallbackBoundary: function () {
        return _errorboundary.HTTPAccessFallbackBoundary;
      },
      LayoutRouter: function () {
        return _layoutrouter.default;
      },
      MetadataBoundary: function () {
        return _metadataboundary.MetadataBoundary;
      },
      OutletBoundary: function () {
        return _metadataboundary.OutletBoundary;
      },
      Postpone: function () {
        return _postpone.Postpone;
      },
      RenderFromTemplateContext: function () {
        return _renderfromtemplatecontext.default;
      },
      ViewportBoundary: function () {
        return _metadataboundary.ViewportBoundary;
      },
      actionAsyncStorage: function () {
        return _actionasyncstorageexternal.actionAsyncStorage;
      },
      collectSegmentData: function () {
        return _collectsegmentdata.collectSegmentData;
      },
      createMetadataComponents: function () {
        return _metadata.createMetadataComponents;
      },
      createPrerenderParamsForClientSegment: function () {
        return _params.createPrerenderParamsForClientSegment;
      },
      createPrerenderSearchParamsForClientPage: function () {
        return _searchparams.createPrerenderSearchParamsForClientPage;
      },
      createServerParamsForServerSegment: function () {
        return _params.createServerParamsForServerSegment;
      },
      createServerSearchParamsForServerPage: function () {
        return _searchparams.createServerSearchParamsForServerPage;
      },
      createTemporaryReferenceSet: function () {
        return _serveredge.createTemporaryReferenceSet;
      },
      decodeAction: function () {
        return _serveredge.decodeAction;
      },
      decodeFormState: function () {
        return _serveredge.decodeFormState;
      },
      decodeReply: function () {
        return _serveredge.decodeReply;
      },
      patchFetch: function () {
        return patchFetch;
      },
      preconnect: function () {
        return _preloads.preconnect;
      },
      preloadFont: function () {
        return _preloads.preloadFont;
      },
      preloadStyle: function () {
        return _preloads.preloadStyle;
      },
      prerender: function () {
        return _staticedge.unstable_prerender;
      },
      renderToReadableStream: function () {
        return _serveredge.renderToReadableStream;
      },
      serverHooks: function () {
        return _hooksservercontext;
      },
      taintObjectReference: function () {
        return _taint.taintObjectReference;
      },
      workAsyncStorage: function () {
        return _workasyncstorageexternal.workAsyncStorage;
      },
      workUnitAsyncStorage: function () {
        return _workunitasyncstorageexternal.workUnitAsyncStorage;
      },
    });
    const _serveredge = __webpack_require__(7322);
    const _staticedge = __webpack_require__(4176);
    const _layoutrouter = /*#__PURE__*/ _interop_require_default(
      __webpack_require__(6662)
    );
    const _renderfromtemplatecontext = /*#__PURE__*/ _interop_require_default(
      __webpack_require__(147)
    );
    const _workasyncstorageexternal = __webpack_require__(9348);
    const _workunitasyncstorageexternal = __webpack_require__(412);
    const _actionasyncstorageexternal = __webpack_require__(209);
    const _clientpage = __webpack_require__(5940);
    const _clientsegment = __webpack_require__(2326);
    const _searchparams = __webpack_require__(1611);
    const _params = __webpack_require__(5683);
    const _hooksservercontext = /*#__PURE__*/ _interop_require_wildcard(
      __webpack_require__(1696)
    );
    const _errorboundary = __webpack_require__(1285);
    const _metadata = __webpack_require__(9497);
    const _patchfetch = __webpack_require__(89);
    __webpack_require__(1985);
    const _metadataboundary = __webpack_require__(9967);
    const _preloads = __webpack_require__(644);
    const _postpone = __webpack_require__(9771);
    const _taint = __webpack_require__(2349);
    const _collectsegmentdata = __webpack_require__(7316);
    function _interop_require_default(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== 'function') return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function (nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
        return {
          default: obj,
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null,
      };
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    // patchFetch makes use of APIs such as `React.unstable_postpone` which are only available
    // in the experimental channel of React, so export it from here so that it comes from the bundled runtime
    function patchFetch() {
      return (0, _patchfetch.patchFetch)({
        workAsyncStorage: _workasyncstorageexternal.workAsyncStorage,
        workUnitAsyncStorage: _workunitasyncstorageexternal.workUnitAsyncStorage,
      });
    }

    //# sourceMappingURL=entry-base.js.map
  },
  9771: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';
    /*

Files in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.

*/ // When postpone is available in canary React we can switch to importing it directly

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'Postpone', {
      enumerable: true,
      get: function () {
        return _dynamicrendering.Postpone;
      },
    });
    const _dynamicrendering = __webpack_require__(7811);

    //# sourceMappingURL=postpone.js.map
  },
  644: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';
    /*

Files in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.

*/
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      preconnect: function () {
        return preconnect;
      },
      preloadFont: function () {
        return preloadFont;
      },
      preloadStyle: function () {
        return preloadStyle;
      },
    });
    const _reactdom = /*#__PURE__*/ _interop_require_default(__webpack_require__(1405));
    function _interop_require_default(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }
    function preloadStyle(href, crossOrigin, nonce) {
      const opts = {
        as: 'style',
      };
      if (typeof crossOrigin === 'string') {
        opts.crossOrigin = crossOrigin;
      }
      if (typeof nonce === 'string') {
        opts.nonce = nonce;
      }
      _reactdom.default.preload(href, opts);
    }
    function preloadFont(href, type, crossOrigin, nonce) {
      const opts = {
        as: 'font',
        type,
      };
      if (typeof crossOrigin === 'string') {
        opts.crossOrigin = crossOrigin;
      }
      if (typeof nonce === 'string') {
        opts.nonce = nonce;
      }
      _reactdom.default.preload(href, opts);
    }
    function preconnect(href, crossOrigin, nonce) {
      const opts = {};
      if (typeof crossOrigin === 'string') {
        opts.crossOrigin = crossOrigin;
      }
      if (typeof nonce === 'string') {
        opts.nonce = nonce;
      }
      _reactdom.default.preconnect(href, opts);
    }

    //# sourceMappingURL=preloads.js.map
  },
  2349: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';
    /*

Files in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.

*/
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      taintObjectReference: function () {
        return taintObjectReference;
      },
      taintUniqueValue: function () {
        return taintUniqueValue;
      },
    });
    const _react = /*#__PURE__*/ _interop_require_wildcard(__webpack_require__(8516));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== 'function') return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function (nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
        return {
          default: obj,
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null,
      };
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function notImplemented() {
      throw Object.defineProperty(
        new Error('Taint can only be used with the taint flag.'),
        '__NEXT_ERROR_CODE',
        {
          value: 'E354',
          enumerable: false,
          configurable: true,
        }
      );
    }
    const taintObjectReference = false ? 0 : notImplemented;
    const taintUniqueValue = false ? 0 : notImplemented;

    //# sourceMappingURL=taint.js.map
  },
  5871: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      isNodeNextRequest: function () {
        return isNodeNextRequest;
      },
      isNodeNextResponse: function () {
        return isNodeNextResponse;
      },
      isWebNextRequest: function () {
        return isWebNextRequest;
      },
      isWebNextResponse: function () {
        return isWebNextResponse;
      },
    });
    const isWebNextRequest = (req) => 'nodejs' === 'edge';
    const isWebNextResponse = (res) => 'nodejs' === 'edge';
    const isNodeNextRequest = (req) => 'nodejs' !== 'edge';
    const isNodeNextResponse = (res) => 'nodejs' !== 'edge';

    //# sourceMappingURL=helpers.js.map
  },
  2738: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getClientComponentLoaderMetrics: function () {
        return getClientComponentLoaderMetrics;
      },
      wrapClientComponentLoader: function () {
        return wrapClientComponentLoader;
      },
    });
    // Combined load times for loading client components
    let clientComponentLoadStart = 0;
    let clientComponentLoadTimes = 0;
    let clientComponentLoadCount = 0;
    function wrapClientComponentLoader(ComponentMod) {
      if (!('performance' in globalThis)) {
        return ComponentMod.__next_app__;
      }
      return {
        require: (...args) => {
          const startTime = performance.now();
          if (clientComponentLoadStart === 0) {
            clientComponentLoadStart = startTime;
          }
          try {
            clientComponentLoadCount += 1;
            return ComponentMod.__next_app__.require(...args);
          } finally {
            clientComponentLoadTimes += performance.now() - startTime;
          }
        },
        loadChunk: (...args) => {
          const startTime = performance.now();
          const result = ComponentMod.__next_app__.loadChunk(...args);
          // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.
          // We only need to know when it's settled.
          result.finally(() => {
            clientComponentLoadTimes += performance.now() - startTime;
          });
          return result;
        },
      };
    }
    function getClientComponentLoaderMetrics(options = {}) {
      const metrics =
        clientComponentLoadStart === 0
          ? undefined
          : {
              clientComponentLoadStart,
              clientComponentLoadTimes,
              clientComponentLoadCount,
            };
      if (options.reset) {
        clientComponentLoadStart = 0;
        clientComponentLoadTimes = 0;
        clientComponentLoadCount = 0;
      }
      return metrics;
    }

    //# sourceMappingURL=client-component-renderer-logger.js.map
  },
  8298: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'createDedupedByCallsiteServerErrorLoggerDev', {
      enumerable: true,
      get: function () {
        return createDedupedByCallsiteServerErrorLoggerDev;
      },
    });
    const _react = /*#__PURE__*/ _interop_require_wildcard(__webpack_require__(8516));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== 'function') return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function (nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
        return {
          default: obj,
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null,
      };
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    const errorRef = {
      current: null,
    };
    // React.cache is currently only available in canary/experimental React channels.
    const cache = typeof _react.cache === 'function' ? _react.cache : (fn) => fn;
    // When Dynamic IO is enabled, we record these as errors so that they
    // are captured by the dev overlay as it's more critical to fix these
    // when enabled.
    const logErrorOrWarn = false ? 0 : console.warn;
    // We don't want to dedupe across requests.
    // The developer might've just attempted to fix the warning so we should warn again if it still happens.
    const flushCurrentErrorIfNew = cache(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key
      (key) => {
        try {
          logErrorOrWarn(errorRef.current);
        } finally {
          errorRef.current = null;
        }
      }
    );
    function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {
      return function logDedupedError(...args) {
        const message = getMessage(...args);
        if (true) {
          var _stack;
          const callStackFrames =
            (_stack = new Error().stack) == null ? void 0 : _stack.split('\n');
          if (callStackFrames === undefined || callStackFrames.length < 4) {
            logErrorOrWarn(message);
          } else {
            // Error:
            //   logDedupedError
            //   asyncApiBeingAccessedSynchronously
            //   <userland callsite>
            // TODO: This breaks if sourcemaps with ignore lists are enabled.
            const key = callStackFrames[4];
            errorRef.current = message;
            flushCurrentErrorIfNew(key);
          }
        } else {
        }
      };
    }

    //# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map
  },
  8458: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      isHangingPromiseRejectionError: function () {
        return isHangingPromiseRejectionError;
      },
      makeHangingPromise: function () {
        return makeHangingPromise;
      },
    });
    function isHangingPromiseRejectionError(err) {
      if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
      }
      return err.digest === HANGING_PROMISE_REJECTION;
    }
    const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';
    class HangingPromiseRejectionError extends Error {
      constructor(expression) {
        super(
          `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \`setTimeout\`, \`after\`, or similar functions you may observe this error and you should handle it in that context.`
        ),
          (this.expression = expression),
          (this.digest = HANGING_PROMISE_REJECTION);
      }
    }
    const abortListenersBySignal = new WeakMap();
    function makeHangingPromise(signal, expression) {
      if (signal.aborted) {
        return Promise.reject(new HangingPromiseRejectionError(expression));
      } else {
        const hangingPromise = new Promise((_, reject) => {
          const boundRejection = reject.bind(
            null,
            new HangingPromiseRejectionError(expression)
          );
          let currentListeners = abortListenersBySignal.get(signal);
          if (currentListeners) {
            currentListeners.push(boundRejection);
          } else {
            const listeners = [boundRejection];
            abortListenersBySignal.set(signal, listeners);
            signal.addEventListener(
              'abort',
              () => {
                for (let i = 0; i < listeners.length; i++) {
                  listeners[i]();
                }
              },
              {
                once: true,
              }
            );
          }
        });
        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so
        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct
        // your own promise out of it you'll need to ensure you handle the error when it rejects.
        hangingPromise.catch(ignoreReject);
        return hangingPromise;
      }
    }
    function ignoreReject() {}

    //# sourceMappingURL=dynamic-rendering-utils.js.map
  },
  6085: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getComponentTypeModule: function () {
        return getComponentTypeModule;
      },
      getLayoutOrPageModule: function () {
        return getLayoutOrPageModule;
      },
    });
    const _segment = __webpack_require__(7099);
    async function getLayoutOrPageModule(loaderTree) {
      const { layout, page, defaultPage } = loaderTree[2];
      const isLayout = typeof layout !== 'undefined';
      const isPage = typeof page !== 'undefined';
      const isDefaultPage =
        typeof defaultPage !== 'undefined' &&
        loaderTree[0] === _segment.DEFAULT_SEGMENT_KEY;
      let mod = undefined;
      let modType = undefined;
      let filePath = undefined;
      if (isLayout) {
        mod = await layout[0]();
        modType = 'layout';
        filePath = layout[1];
      } else if (isPage) {
        mod = await page[0]();
        modType = 'page';
        filePath = page[1];
      } else if (isDefaultPage) {
        mod = await defaultPage[0]();
        modType = 'page';
        filePath = defaultPage[1];
      }
      return {
        mod,
        modType,
        filePath,
      };
    }
    async function getComponentTypeModule(loaderTree, moduleType) {
      const { [moduleType]: module1 } = loaderTree[2];
      if (typeof module1 !== 'undefined') {
        return await module1[0]();
      }
      return undefined;
    }

    //# sourceMappingURL=app-dir-module.js.map
  },
  9176: function (__unused_webpack_module, exports) {
    'use strict';
    /**
     * Clones a response by teeing the body so we can return two independent ReadableStreams
     * from it. This avoids the bug in the undici library around response cloning.
     *
     * After cloning, the original response's body will be consumed and closed.
     *
     * @param original - The original response to clone.
     * @returns A tuple containing two independent clones of the original response.
     * @see https://github.com/vercel/next.js/pull/73274
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'cloneResponse', {
      enumerable: true,
      get: function () {
        return cloneResponse;
      },
    });
    function cloneResponse(original) {
      // If the response has no body, then we can just return the original response
      // twice because it's immutable.
      if (!original.body) {
        return [original, original];
      }
      const [body1, body2] = original.body.tee();
      const cloned1 = new Response(body1, {
        status: original.status,
        statusText: original.statusText,
        headers: original.headers,
      });
      Object.defineProperty(cloned1, 'url', {
        value: original.url,
      });
      const cloned2 = new Response(body2, {
        status: original.status,
        statusText: original.statusText,
        headers: original.headers,
      });
      Object.defineProperty(cloned2, 'url', {
        value: original.url,
      });
      return [cloned1, cloned2];
    }

    //# sourceMappingURL=clone-response.js.map
  },
  9493: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';
    /**
     * Based on
     * https://github.com/facebook/react/blob/d4e78c42a94be027b4dc7ed2659a5fddfbf9bd4e/packages/react/src/ReactFetch.js
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'createDedupeFetch', {
      enumerable: true,
      get: function () {
        return createDedupeFetch;
      },
    });
    const _react = /*#__PURE__*/ _interop_require_wildcard(__webpack_require__(8516));
    const _cloneresponse = __webpack_require__(9176);
    const _invarianterror = __webpack_require__(9288);
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== 'function') return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function (nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
        return {
          default: obj,
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null,
      };
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    const simpleCacheKey = '["GET",[],null,"follow",null,null,null,null]'; // generateCacheKey(new Request('https://blank'));
    function generateCacheKey(request) {
      // We pick the fields that goes into the key used to dedupe requests.
      // We don't include the `cache` field, because we end up using whatever
      // caching resulted from the first request.
      // Notably we currently don't consider non-standard (or future) options.
      // This might not be safe. TODO: warn for non-standard extensions differing.
      // IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.
      return JSON.stringify([
        request.method,
        Array.from(request.headers.entries()),
        request.mode,
        request.redirect,
        request.credentials,
        request.referrer,
        request.referrerPolicy,
        request.integrity,
      ]);
    }
    function createDedupeFetch(originalFetch) {
      const getCacheEntries = _react.cache(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars -- url is the cache key
        (url) => []
      );
      return function dedupeFetch(resource, options) {
        if (options && options.signal) {
          // If we're passed a signal, then we assume that
          // someone else controls the lifetime of this object and opts out of
          // caching. It's effectively the opt-out mechanism.
          // Ideally we should be able to check this on the Request but
          // it always gets initialized with its own signal so we don't
          // know if it's supposed to override - unless we also override the
          // Request constructor.
          return originalFetch(resource, options);
        }
        // Normalize the Request
        let url;
        let cacheKey;
        if (typeof resource === 'string' && !options) {
          // Fast path.
          cacheKey = simpleCacheKey;
          url = resource;
        } else {
          // Normalize the request.
          // if resource is not a string or a URL (its an instance of Request)
          // then do not instantiate a new Request but instead
          // reuse the request as to not disturb the body in the event it's a ReadableStream.
          const request =
            typeof resource === 'string' || resource instanceof URL
              ? new Request(resource, options)
              : resource;
          if (
            (request.method !== 'GET' && request.method !== 'HEAD') ||
            request.keepalive
          ) {
            // We currently don't dedupe requests that might have side-effects. Those
            // have to be explicitly cached. We assume that the request doesn't have a
            // body if it's GET or HEAD.
            // keepalive gets treated the same as if you passed a custom cache signal.
            return originalFetch(resource, options);
          }
          cacheKey = generateCacheKey(request);
          url = request.url;
        }
        const cacheEntries = getCacheEntries(url);
        for (let i = 0, j = cacheEntries.length; i < j; i += 1) {
          const [key, promise] = cacheEntries[i];
          if (key === cacheKey) {
            return promise.then(() => {
              const response = cacheEntries[i][2];
              if (!response)
                throw Object.defineProperty(
                  new _invarianterror.InvariantError('No cached response'),
                  '__NEXT_ERROR_CODE',
                  {
                    value: 'E579',
                    enumerable: false,
                    configurable: true,
                  }
                );
              // We're cloning the response using this utility because there exists
              // a bug in the undici library around response cloning. See the
              // following pull request for more details:
              // https://github.com/vercel/next.js/pull/73274
              const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(response);
              cacheEntries[i][2] = cloned2;
              return cloned1;
            });
          }
        }
        // We pass the original arguments here in case normalizing the Request
        // doesn't include all the options in this environment.
        const promise = originalFetch(resource, options);
        const entry = [cacheKey, promise, null];
        cacheEntries.push(entry);
        return promise.then((response) => {
          // We're cloning the response using this utility because there exists
          // a bug in the undici library around response cloning. See the
          // following pull request for more details:
          // https://github.com/vercel/next.js/pull/73274
          const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(response);
          entry[2] = cloned2;
          return cloned1;
        });
      };
    }

    //# sourceMappingURL=dedupe-fetch.js.map
  },
  9: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'LRUCache', {
      enumerable: true,
      get: function () {
        return LRUCache;
      },
    });
    class LRUCache {
      constructor(maxSize, calculateSize) {
        this.cache = new Map();
        this.sizes = new Map();
        this.totalSize = 0;
        this.maxSize = maxSize;
        this.calculateSize = calculateSize || (() => 1);
      }
      set(key, value) {
        if (!key || !value) return;
        const size = this.calculateSize(value);
        if (size > this.maxSize) {
          console.warn('Single item size exceeds maxSize');
          return;
        }
        if (this.cache.has(key)) {
          this.totalSize -= this.sizes.get(key) || 0;
        }
        this.cache.set(key, value);
        this.sizes.set(key, size);
        this.totalSize += size;
        this.touch(key);
      }
      has(key) {
        if (!key) return false;
        this.touch(key);
        return Boolean(this.cache.get(key));
      }
      get(key) {
        if (!key) return;
        const value = this.cache.get(key);
        if (value === undefined) {
          return undefined;
        }
        this.touch(key);
        return value;
      }
      touch(key) {
        const value = this.cache.get(key);
        if (value !== undefined) {
          this.cache.delete(key);
          this.cache.set(key, value);
          this.evictIfNecessary();
        }
      }
      evictIfNecessary() {
        while (this.totalSize > this.maxSize && this.cache.size > 0) {
          this.evictLeastRecentlyUsed();
        }
      }
      evictLeastRecentlyUsed() {
        const lruKey = this.cache.keys().next().value;
        if (lruKey !== undefined) {
          const lruSize = this.sizes.get(lruKey) || 0;
          this.totalSize -= lruSize;
          this.cache.delete(lruKey);
          this.sizes.delete(lruKey);
        }
      }
      reset() {
        this.cache.clear();
        this.sizes.clear();
        this.totalSize = 0;
      }
      keys() {
        return [...this.cache.keys()];
      }
      remove(key) {
        if (this.cache.has(key)) {
          this.totalSize -= this.sizes.get(key) || 0;
          this.cache.delete(key);
          this.sizes.delete(key);
        }
      }
      clear() {
        this.cache.clear();
        this.sizes.clear();
        this.totalSize = 0;
      }
      get size() {
        return this.cache.size;
      }
      get currentSize() {
        return this.totalSize;
      }
    }

    //# sourceMappingURL=lru-cache.js.map
  },
  89: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      NEXT_PATCH_SYMBOL: function () {
        return NEXT_PATCH_SYMBOL;
      },
      createPatchedFetcher: function () {
        return createPatchedFetcher;
      },
      patchFetch: function () {
        return patchFetch;
      },
      validateRevalidate: function () {
        return validateRevalidate;
      },
      validateTags: function () {
        return validateTags;
      },
    });
    const _constants = __webpack_require__(2917);
    const _tracer = __webpack_require__(9223);
    const _constants1 = __webpack_require__(6914);
    const _dynamicrendering = __webpack_require__(7811);
    const _dynamicrenderingutils = __webpack_require__(8458);
    const _dedupefetch = __webpack_require__(9493);
    const _responsecache = __webpack_require__(7339);
    const _scheduler = __webpack_require__(4230);
    const _cloneresponse = __webpack_require__(9176);
    const isEdgeRuntime = 'nodejs' === 'edge';
    const NEXT_PATCH_SYMBOL = Symbol.for('next-patch');
    function isFetchPatched() {
      return globalThis[NEXT_PATCH_SYMBOL] === true;
    }
    function validateRevalidate(revalidateVal, route) {
      try {
        let normalizedRevalidate = undefined;
        if (revalidateVal === false) {
          normalizedRevalidate = _constants1.INFINITE_CACHE;
        } else if (
          typeof revalidateVal === 'number' &&
          !isNaN(revalidateVal) &&
          revalidateVal > -1
        ) {
          normalizedRevalidate = revalidateVal;
        } else if (typeof revalidateVal !== 'undefined') {
          throw Object.defineProperty(
            new Error(
              `Invalid revalidate value "${revalidateVal}" on "${route}", must be a non-negative number or false`
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E179',
              enumerable: false,
              configurable: true,
            }
          );
        }
        return normalizedRevalidate;
      } catch (err) {
        // handle client component error from attempting to check revalidate value
        if (err instanceof Error && err.message.includes('Invalid revalidate')) {
          throw err;
        }
        return undefined;
      }
    }
    function validateTags(tags, description) {
      const validTags = [];
      const invalidTags = [];
      for (let i = 0; i < tags.length; i++) {
        const tag = tags[i];
        if (typeof tag !== 'string') {
          invalidTags.push({
            tag,
            reason: 'invalid type, must be a string',
          });
        } else if (tag.length > _constants1.NEXT_CACHE_TAG_MAX_LENGTH) {
          invalidTags.push({
            tag,
            reason: `exceeded max length of ${_constants1.NEXT_CACHE_TAG_MAX_LENGTH}`,
          });
        } else {
          validTags.push(tag);
        }
        if (validTags.length > _constants1.NEXT_CACHE_TAG_MAX_ITEMS) {
          console.warn(
            `Warning: exceeded max tag count for ${description}, dropped tags:`,
            tags.slice(i).join(', ')
          );
          break;
        }
      }
      if (invalidTags.length > 0) {
        console.warn(`Warning: invalid tags passed to ${description}: `);
        for (const { tag, reason } of invalidTags) {
          console.log(`tag: "${tag}" ${reason}`);
        }
      }
      return validTags;
    }
    function trackFetchMetric(workStore, ctx) {
      var _workStore_requestEndedState;
      // If the static generation store is not available, we can't track the fetch
      if (!workStore) return;
      if (
        (_workStore_requestEndedState = workStore.requestEndedState) == null
          ? void 0
          : _workStore_requestEndedState.ended
      )
        return;
      const isDebugBuild =
        (!!process.env.NEXT_DEBUG_BUILD || process.env.NEXT_SSG_FETCH_METRICS === '1') &&
        workStore.isStaticGeneration;
      const isDevelopment = 'development' === 'development';
      if (
        // The only time we want to track fetch metrics outside of development is when
        // we are performing a static generation & we are in debug mode.
        !isDebugBuild &&
        !isDevelopment
      ) {
        return;
      }
      workStore.fetchMetrics ??= [];
      workStore.fetchMetrics.push({
        ...ctx,
        end: performance.timeOrigin + performance.now(),
        idx: workStore.nextFetchId || 0,
      });
    }
    function createPatchedFetcher(
      originFetch,
      { workAsyncStorage, workUnitAsyncStorage }
    ) {
      // Create the patched fetch function. We don't set the type here, as it's
      // verified as the return value of this function.
      const patched = async (input, init) => {
        var _init_method, _init_next;
        let url;
        try {
          url = new URL(input instanceof Request ? input.url : input);
          url.username = '';
          url.password = '';
        } catch {
          // Error caused by malformed URL should be handled by native fetch
          url = undefined;
        }
        const fetchUrl = (url == null ? void 0 : url.href) ?? '';
        const method =
          (init == null
            ? void 0
            : (_init_method = init.method) == null
              ? void 0
              : _init_method.toUpperCase()) || 'GET';
        // Do create a new span trace for internal fetches in the
        // non-verbose mode.
        const isInternal =
          (init == null
            ? void 0
            : (_init_next = init.next) == null
              ? void 0
              : _init_next.internal) === true;
        const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === '1';
        // We don't track fetch metrics for internal fetches
        // so it's not critical that we have a start time, as it won't be recorded.
        // This is to workaround a flaky issue where performance APIs might
        // not be available and will require follow-up investigation.
        const fetchStart = isInternal
          ? undefined
          : performance.timeOrigin + performance.now();
        const workStore = workAsyncStorage.getStore();
        const workUnitStore = workUnitAsyncStorage.getStore();
        // During static generation we track cache reads so we can reason about when they fill
        let cacheSignal =
          workUnitStore && workUnitStore.type === 'prerender'
            ? workUnitStore.cacheSignal
            : null;
        if (cacheSignal) {
          cacheSignal.beginRead();
        }
        const result = (0, _tracer.getTracer)().trace(
          isInternal
            ? _constants.NextNodeServerSpan.internalFetch
            : _constants.AppRenderSpan.fetch,
          {
            hideSpan,
            kind: _tracer.SpanKind.CLIENT,
            spanName: ['fetch', method, fetchUrl].filter(Boolean).join(' '),
            attributes: {
              'http.url': fetchUrl,
              'http.method': method,
              'net.peer.name': url == null ? void 0 : url.hostname,
              'net.peer.port': (url == null ? void 0 : url.port) || undefined,
            },
          },
          async () => {
            var _getRequestMeta;
            // If this is an internal fetch, we should not do any special treatment.
            if (isInternal) {
              return originFetch(input, init);
            }
            // If the workStore is not available, we can't do any
            // special treatment of fetch, therefore fallback to the original
            // fetch implementation.
            if (!workStore) {
              return originFetch(input, init);
            }
            // We should also fallback to the original fetch implementation if we
            // are in draft mode, it does not constitute a static generation.
            if (workStore.isDraftMode) {
              return originFetch(input, init);
            }
            const isRequestInput =
              input && typeof input === 'object' && typeof input.method === 'string';
            const getRequestMeta = (field) => {
              // If request input is present but init is not, retrieve from input first.
              const value = init == null ? void 0 : init[field];
              return value || (isRequestInput ? input[field] : null);
            };
            let finalRevalidate = undefined;
            const getNextField = (field) => {
              var _init_next, _init_next1, _input_next;
              return typeof (init == null
                ? void 0
                : (_init_next = init.next) == null
                  ? void 0
                  : _init_next[field]) !== 'undefined'
                ? init == null
                  ? void 0
                  : (_init_next1 = init.next) == null
                    ? void 0
                    : _init_next1[field]
                : isRequestInput
                  ? (_input_next = input.next) == null
                    ? void 0
                    : _input_next[field]
                  : undefined;
            };
            // RequestInit doesn't keep extra fields e.g. next so it's
            // only available if init is used separate
            let currentFetchRevalidate = getNextField('revalidate');
            const tags = validateTags(
              getNextField('tags') || [],
              `fetch ${input.toString()}`
            );
            const revalidateStore =
              workUnitStore &&
              (workUnitStore.type === 'cache' ||
                workUnitStore.type === 'prerender' ||
                workUnitStore.type === 'prerender-ppr' ||
                workUnitStore.type === 'prerender-legacy')
                ? workUnitStore
                : undefined;
            if (revalidateStore) {
              if (Array.isArray(tags)) {
                // Collect tags onto parent caches or parent prerenders.
                const collectedTags = revalidateStore.tags ?? (revalidateStore.tags = []);
                for (const tag of tags) {
                  if (!collectedTags.includes(tag)) {
                    collectedTags.push(tag);
                  }
                }
              }
            }
            const implicitTags =
              workUnitStore == null ? void 0 : workUnitStore.implicitTags;
            // Inside unstable-cache we treat it the same as force-no-store on the
            // page.
            const pageFetchCacheMode =
              workUnitStore && workUnitStore.type === 'unstable-cache'
                ? 'force-no-store'
                : workStore.fetchCache;
            const isUsingNoStore = !!workStore.isUnstableNoStore;
            let currentFetchCacheConfig = getRequestMeta('cache');
            let cacheReason = '';
            let cacheWarning;
            if (
              typeof currentFetchCacheConfig === 'string' &&
              typeof currentFetchRevalidate !== 'undefined'
            ) {
              // If the revalidate value conflicts with the cache value, we should warn the user and unset the conflicting values.
              const isConflictingRevalidate = // revalidate: 0 and cache: force-cache
                (currentFetchCacheConfig === 'force-cache' &&
                  currentFetchRevalidate === 0) || // revalidate: >0 or revalidate: false and cache: no-store
                (currentFetchCacheConfig === 'no-store' &&
                  (currentFetchRevalidate > 0 || currentFetchRevalidate === false));
              if (isConflictingRevalidate) {
                cacheWarning = `Specified "cache: ${currentFetchCacheConfig}" and "revalidate: ${currentFetchRevalidate}", only one should be specified.`;
                currentFetchCacheConfig = undefined;
                currentFetchRevalidate = undefined;
              }
            }
            const hasExplicitFetchCacheOptOut = // fetch config itself signals not to cache
              currentFetchCacheConfig === 'no-cache' ||
              currentFetchCacheConfig === 'no-store' || // the fetch isn't explicitly caching and the segment level cache config signals not to cache
              // note: `pageFetchCacheMode` is also set by being in an unstable_cache context.
              pageFetchCacheMode === 'force-no-store' ||
              pageFetchCacheMode === 'only-no-store';
            // If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,
            // we shouldn't consider caching the fetch. This is because the `dynamic` cache
            // is considered a "top-level" cache mode, whereas something like `fetchCache` is more
            // fine-grained. Top-level modes are responsible for setting reasonable defaults for the
            // other configurations.
            const noFetchConfigAndForceDynamic =
              !pageFetchCacheMode &&
              !currentFetchCacheConfig &&
              !currentFetchRevalidate &&
              workStore.forceDynamic;
            if (
              // force-cache was specified without a revalidate value. We set the revalidate value to false
              // which will signal the cache to not revalidate
              currentFetchCacheConfig === 'force-cache' &&
              typeof currentFetchRevalidate === 'undefined'
            ) {
              currentFetchRevalidate = false;
            } else if (
              // if we are inside of "use cache"/"unstable_cache"
              // we shouldn't set the revalidate to 0 as it's overridden
              // by the cache context
              (workUnitStore == null ? void 0 : workUnitStore.type) !== 'cache' &&
              (hasExplicitFetchCacheOptOut || noFetchConfigAndForceDynamic)
            ) {
              currentFetchRevalidate = 0;
            }
            if (
              currentFetchCacheConfig === 'no-cache' ||
              currentFetchCacheConfig === 'no-store'
            ) {
              cacheReason = `cache: ${currentFetchCacheConfig}`;
            }
            finalRevalidate = validateRevalidate(currentFetchRevalidate, workStore.route);
            const _headers = getRequestMeta('headers');
            const initHeaders =
              typeof (_headers == null ? void 0 : _headers.get) === 'function'
                ? _headers
                : new Headers(_headers || {});
            const hasUnCacheableHeader =
              initHeaders.get('authorization') || initHeaders.get('cookie');
            const isUnCacheableMethod = !['get', 'head'].includes(
              ((_getRequestMeta = getRequestMeta('method')) == null
                ? void 0
                : _getRequestMeta.toLowerCase()) || 'get'
            );
            /**
             * We automatically disable fetch caching under the following conditions:
             *
             * - Fetch cache configs are not set. Specifically:
             *
             *   - A page fetch cache mode is not set (export const fetchCache=...)
             *   - A fetch cache mode is not set in the fetch call (fetch(url, { cache: ...
             *       })) or the fetch cache mode is set to 'default'
             *   - A fetch revalidate value is not set in the fetch call (fetch(url, {
             *       revalidate: ... }))
             * - OR the fetch comes after a configuration that triggered dynamic rendering
             *   (e.g., reading cookies()) and the fetch was considered uncacheable (e.g.,
             *   POST method or has authorization headers)
             */ const hasNoExplicitCacheConfig = // eslint-disable-next-line eqeqeq
              pageFetchCacheMode == undefined && // eslint-disable-next-line eqeqeq
              (currentFetchCacheConfig == undefined || // when considering whether to opt into the default "no-cache" fetch semantics,
                // a "default" cache config should be treated the same as no cache config
                currentFetchCacheConfig === 'default') && // eslint-disable-next-line eqeqeq
              currentFetchRevalidate == undefined;
            const autoNoCache = // this condition is hit for null/undefined
              // eslint-disable-next-line eqeqeq
              (hasNoExplicitCacheConfig && // we disable automatic no caching behavior during build time SSG so that we can still
                // leverage the fetch cache between SSG workers
                !workStore.isPrerendering) ||
              ((hasUnCacheableHeader || isUnCacheableMethod) &&
                revalidateStore &&
                revalidateStore.revalidate === 0);
            if (
              hasNoExplicitCacheConfig &&
              workUnitStore !== undefined &&
              workUnitStore.type === 'prerender'
            ) {
              // If we have no cache config, and we're in Dynamic I/O prerendering, it'll be a dynamic call.
              // We don't have to issue that dynamic call.
              if (cacheSignal) {
                cacheSignal.endRead();
                cacheSignal = null;
              }
              return (0, _dynamicrenderingutils.makeHangingPromise)(
                workUnitStore.renderSignal,
                'fetch()'
              );
            }
            switch (pageFetchCacheMode) {
              case 'force-no-store': {
                cacheReason = 'fetchCache = force-no-store';
                break;
              }
              case 'only-no-store': {
                if (
                  currentFetchCacheConfig === 'force-cache' ||
                  (typeof finalRevalidate !== 'undefined' && finalRevalidate > 0)
                ) {
                  throw Object.defineProperty(
                    new Error(
                      `cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`
                    ),
                    '__NEXT_ERROR_CODE',
                    {
                      value: 'E448',
                      enumerable: false,
                      configurable: true,
                    }
                  );
                }
                cacheReason = 'fetchCache = only-no-store';
                break;
              }
              case 'only-cache': {
                if (currentFetchCacheConfig === 'no-store') {
                  throw Object.defineProperty(
                    new Error(
                      `cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`
                    ),
                    '__NEXT_ERROR_CODE',
                    {
                      value: 'E521',
                      enumerable: false,
                      configurable: true,
                    }
                  );
                }
                break;
              }
              case 'force-cache': {
                if (
                  typeof currentFetchRevalidate === 'undefined' ||
                  currentFetchRevalidate === 0
                ) {
                  cacheReason = 'fetchCache = force-cache';
                  finalRevalidate = _constants1.INFINITE_CACHE;
                }
                break;
              }
              default:
            }
            if (typeof finalRevalidate === 'undefined') {
              if (pageFetchCacheMode === 'default-cache' && !isUsingNoStore) {
                finalRevalidate = _constants1.INFINITE_CACHE;
                cacheReason = 'fetchCache = default-cache';
              } else if (pageFetchCacheMode === 'default-no-store') {
                finalRevalidate = 0;
                cacheReason = 'fetchCache = default-no-store';
              } else if (isUsingNoStore) {
                finalRevalidate = 0;
                cacheReason = 'noStore call';
              } else if (autoNoCache) {
                finalRevalidate = 0;
                cacheReason = 'auto no cache';
              } else {
                // TODO: should we consider this case an invariant?
                cacheReason = 'auto cache';
                finalRevalidate = revalidateStore
                  ? revalidateStore.revalidate
                  : _constants1.INFINITE_CACHE;
              }
            } else if (!cacheReason) {
              cacheReason = `revalidate: ${finalRevalidate}`;
            }
            if (
              // when force static is configured we don't bail from
              // `revalidate: 0` values
              !(workStore.forceStatic && finalRevalidate === 0) && // we don't consider autoNoCache to switch to dynamic for ISR
              !autoNoCache && // If the revalidate value isn't currently set or the value is less
              // than the current revalidate value, we should update the revalidate
              // value.
              revalidateStore &&
              finalRevalidate < revalidateStore.revalidate
            ) {
              // If we were setting the revalidate value to 0, we should try to
              // postpone instead first.
              if (finalRevalidate === 0) {
                if (workUnitStore && workUnitStore.type === 'prerender') {
                  if (cacheSignal) {
                    cacheSignal.endRead();
                    cacheSignal = null;
                  }
                  return (0, _dynamicrenderingutils.makeHangingPromise)(
                    workUnitStore.renderSignal,
                    'fetch()'
                  );
                } else {
                  (0, _dynamicrendering.markCurrentScopeAsDynamic)(
                    workStore,
                    workUnitStore,
                    `revalidate: 0 fetch ${input} ${workStore.route}`
                  );
                }
              }
              // We only want to set the revalidate store's revalidate time if it
              // was explicitly set for the fetch call, i.e. currentFetchRevalidate.
              if (revalidateStore && currentFetchRevalidate === finalRevalidate) {
                revalidateStore.revalidate = finalRevalidate;
              }
            }
            const isCacheableRevalidate =
              typeof finalRevalidate === 'number' && finalRevalidate > 0;
            let cacheKey;
            const { incrementalCache } = workStore;
            const useCacheOrRequestStore =
              (workUnitStore == null ? void 0 : workUnitStore.type) === 'request' ||
              (workUnitStore == null ? void 0 : workUnitStore.type) === 'cache'
                ? workUnitStore
                : undefined;
            if (
              incrementalCache &&
              (isCacheableRevalidate ||
                (useCacheOrRequestStore == null
                  ? void 0
                  : useCacheOrRequestStore.serverComponentsHmrCache))
            ) {
              try {
                cacheKey = await incrementalCache.generateCacheKey(
                  fetchUrl,
                  isRequestInput ? input : init
                );
              } catch (err) {
                console.error(`Failed to generate cache key for`, input);
              }
            }
            const fetchIdx = workStore.nextFetchId ?? 1;
            workStore.nextFetchId = fetchIdx + 1;
            let handleUnlock = () => Promise.resolve();
            const doOriginalFetch = async (isStale, cacheReasonOverride) => {
              const requestInputFields = [
                'cache',
                'credentials',
                'headers',
                'integrity',
                'keepalive',
                'method',
                'mode',
                'redirect',
                'referrer',
                'referrerPolicy',
                'window',
                'duplex',
                // don't pass through signal when revalidating
                ...(isStale ? [] : ['signal']),
              ];
              if (isRequestInput) {
                const reqInput = input;
                const reqOptions = {
                  body: reqInput._ogBody || reqInput.body,
                };
                for (const field of requestInputFields) {
                  // @ts-expect-error custom fields
                  reqOptions[field] = reqInput[field];
                }
                input = new Request(reqInput.url, reqOptions);
              } else if (init) {
                const { _ogBody, body, signal, ...otherInput } = init;
                init = {
                  ...otherInput,
                  body: _ogBody || body,
                  signal: isStale ? undefined : signal,
                };
              }
              // add metadata to init without editing the original
              const clonedInit = {
                ...init,
                next: {
                  ...(init == null ? void 0 : init.next),
                  fetchType: 'origin',
                  fetchIdx,
                },
              };
              return originFetch(input, clonedInit)
                .then(async (res) => {
                  if (!isStale && fetchStart) {
                    trackFetchMetric(workStore, {
                      start: fetchStart,
                      url: fetchUrl,
                      cacheReason: cacheReasonOverride || cacheReason,
                      cacheStatus:
                        finalRevalidate === 0 || cacheReasonOverride ? 'skip' : 'miss',
                      cacheWarning,
                      status: res.status,
                      method: clonedInit.method || 'GET',
                    });
                  }
                  if (
                    res.status === 200 &&
                    incrementalCache &&
                    cacheKey &&
                    (isCacheableRevalidate ||
                      (useCacheOrRequestStore == null
                        ? void 0
                        : useCacheOrRequestStore.serverComponentsHmrCache))
                  ) {
                    const normalizedRevalidate =
                      finalRevalidate >= _constants1.INFINITE_CACHE
                        ? _constants1.CACHE_ONE_YEAR
                        : finalRevalidate;
                    if (workUnitStore && workUnitStore.type === 'prerender') {
                      // We are prerendering at build time or revalidate time with dynamicIO so we need to
                      // buffer the response so we can guarantee it can be read in a microtask
                      const bodyBuffer = await res.arrayBuffer();
                      const fetchedData = {
                        headers: Object.fromEntries(res.headers.entries()),
                        body: Buffer.from(bodyBuffer).toString('base64'),
                        status: res.status,
                        url: res.url,
                      };
                      // We can skip checking the serverComponentsHmrCache because we aren't in
                      // dev mode.
                      await incrementalCache.set(
                        cacheKey,
                        {
                          kind: _responsecache.CachedRouteKind.FETCH,
                          data: fetchedData,
                          revalidate: normalizedRevalidate,
                        },
                        {
                          fetchCache: true,
                          fetchUrl,
                          fetchIdx,
                          tags,
                        }
                      );
                      await handleUnlock();
                      // We return a new Response to the caller.
                      return new Response(bodyBuffer, {
                        headers: res.headers,
                        status: res.status,
                        statusText: res.statusText,
                      });
                    } else {
                      // We're cloning the response using this utility because there
                      // exists a bug in the undici library around response cloning.
                      // See the following pull request for more details:
                      // https://github.com/vercel/next.js/pull/73274
                      const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(res);
                      // We are dynamically rendering including dev mode. We want to return
                      // the response to the caller as soon as possible because it might stream
                      // over a very long time.
                      cloned1
                        .arrayBuffer()
                        .then(async (arrayBuffer) => {
                          var _useCacheOrRequestStore_serverComponentsHmrCache;
                          const bodyBuffer = Buffer.from(arrayBuffer);
                          const fetchedData = {
                            headers: Object.fromEntries(cloned1.headers.entries()),
                            body: bodyBuffer.toString('base64'),
                            status: cloned1.status,
                            url: cloned1.url,
                          };
                          useCacheOrRequestStore == null
                            ? void 0
                            : (_useCacheOrRequestStore_serverComponentsHmrCache =
                                  useCacheOrRequestStore.serverComponentsHmrCache) == null
                              ? void 0
                              : _useCacheOrRequestStore_serverComponentsHmrCache.set(
                                  cacheKey,
                                  fetchedData
                                );
                          if (isCacheableRevalidate) {
                            await incrementalCache.set(
                              cacheKey,
                              {
                                kind: _responsecache.CachedRouteKind.FETCH,
                                data: fetchedData,
                                revalidate: normalizedRevalidate,
                              },
                              {
                                fetchCache: true,
                                fetchUrl,
                                fetchIdx,
                                tags,
                              }
                            );
                          }
                        })
                        .catch((error) =>
                          console.warn(`Failed to set fetch cache`, input, error)
                        )
                        .finally(handleUnlock);
                      return cloned2;
                    }
                  }
                  // we had response that we determined shouldn't be cached so we return it
                  // and don't cache it. This also needs to unlock the cache lock we acquired.
                  await handleUnlock();
                  return res;
                })
                .catch((error) => {
                  handleUnlock();
                  throw error;
                });
            };
            let cacheReasonOverride;
            let isForegroundRevalidate = false;
            let isHmrRefreshCache = false;
            if (cacheKey && incrementalCache) {
              let cachedFetchData;
              if (
                (useCacheOrRequestStore == null
                  ? void 0
                  : useCacheOrRequestStore.isHmrRefresh) &&
                useCacheOrRequestStore.serverComponentsHmrCache
              ) {
                cachedFetchData =
                  useCacheOrRequestStore.serverComponentsHmrCache.get(cacheKey);
                isHmrRefreshCache = true;
              }
              if (isCacheableRevalidate && !cachedFetchData) {
                handleUnlock = await incrementalCache.lock(cacheKey);
                const entry = workStore.isOnDemandRevalidate
                  ? null
                  : await incrementalCache.get(cacheKey, {
                      kind: _responsecache.IncrementalCacheKind.FETCH,
                      revalidate: finalRevalidate,
                      fetchUrl,
                      fetchIdx,
                      tags,
                      softTags: implicitTags == null ? void 0 : implicitTags.tags,
                    });
                if (hasNoExplicitCacheConfig) {
                  // We sometimes use the cache to dedupe fetches that do not specify a cache configuration
                  // In these cases we want to make sure we still exclude them from prerenders if dynamicIO is on
                  // so we introduce an artificial Task boundary here.
                  if (workUnitStore && workUnitStore.type === 'prerender') {
                    await (0, _scheduler.waitAtLeastOneReactRenderTask)();
                  }
                }
                if (entry) {
                  await handleUnlock();
                } else {
                  // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers
                  cacheReasonOverride = 'cache-control: no-cache (hard refresh)';
                }
                if (
                  (entry == null ? void 0 : entry.value) &&
                  entry.value.kind === _responsecache.CachedRouteKind.FETCH
                ) {
                  // when stale and is revalidating we wait for fresh data
                  // so the revalidated entry has the updated data
                  if (workStore.isRevalidate && entry.isStale) {
                    isForegroundRevalidate = true;
                  } else {
                    if (entry.isStale) {
                      workStore.pendingRevalidates ??= {};
                      if (!workStore.pendingRevalidates[cacheKey]) {
                        const pendingRevalidate = doOriginalFetch(true)
                          .then(async (response) => ({
                            body: await response.arrayBuffer(),
                            headers: response.headers,
                            status: response.status,
                            statusText: response.statusText,
                          }))
                          .finally(() => {
                            workStore.pendingRevalidates ??= {};
                            delete workStore.pendingRevalidates[cacheKey || ''];
                          });
                        // Attach the empty catch here so we don't get a "unhandled
                        // promise rejection" warning.
                        pendingRevalidate.catch(console.error);
                        workStore.pendingRevalidates[cacheKey] = pendingRevalidate;
                      }
                    }
                    cachedFetchData = entry.value.data;
                  }
                }
              }
              if (cachedFetchData) {
                if (fetchStart) {
                  trackFetchMetric(workStore, {
                    start: fetchStart,
                    url: fetchUrl,
                    cacheReason,
                    cacheStatus: isHmrRefreshCache ? 'hmr' : 'hit',
                    cacheWarning,
                    status: cachedFetchData.status || 200,
                    method: (init == null ? void 0 : init.method) || 'GET',
                  });
                }
                const response = new Response(
                  Buffer.from(cachedFetchData.body, 'base64'),
                  {
                    headers: cachedFetchData.headers,
                    status: cachedFetchData.status,
                  }
                );
                Object.defineProperty(response, 'url', {
                  value: cachedFetchData.url,
                });
                return response;
              }
            }
            if (workStore.isStaticGeneration && init && typeof init === 'object') {
              const { cache } = init;
              // Delete `cache` property as Cloudflare Workers will throw an error
              if (isEdgeRuntime) delete init.cache;
              if (cache === 'no-store') {
                // If enabled, we should bail out of static generation.
                if (workUnitStore && workUnitStore.type === 'prerender') {
                  if (cacheSignal) {
                    cacheSignal.endRead();
                    cacheSignal = null;
                  }
                  return (0, _dynamicrenderingutils.makeHangingPromise)(
                    workUnitStore.renderSignal,
                    'fetch()'
                  );
                } else {
                  (0, _dynamicrendering.markCurrentScopeAsDynamic)(
                    workStore,
                    workUnitStore,
                    `no-store fetch ${input} ${workStore.route}`
                  );
                }
              }
              const hasNextConfig = 'next' in init;
              const { next = {} } = init;
              if (
                typeof next.revalidate === 'number' &&
                revalidateStore &&
                next.revalidate < revalidateStore.revalidate
              ) {
                if (next.revalidate === 0) {
                  // If enabled, we should bail out of static generation.
                  if (workUnitStore && workUnitStore.type === 'prerender') {
                    return (0, _dynamicrenderingutils.makeHangingPromise)(
                      workUnitStore.renderSignal,
                      'fetch()'
                    );
                  } else {
                    (0, _dynamicrendering.markCurrentScopeAsDynamic)(
                      workStore,
                      workUnitStore,
                      `revalidate: 0 fetch ${input} ${workStore.route}`
                    );
                  }
                }
                if (!workStore.forceStatic || next.revalidate !== 0) {
                  revalidateStore.revalidate = next.revalidate;
                }
              }
              if (hasNextConfig) delete init.next;
            }
            // if we are revalidating the whole page via time or on-demand and
            // the fetch cache entry is stale we should still de-dupe the
            // origin hit if it's a cache-able entry
            if (cacheKey && isForegroundRevalidate) {
              const pendingRevalidateKey = cacheKey;
              workStore.pendingRevalidates ??= {};
              let pendingRevalidate = workStore.pendingRevalidates[pendingRevalidateKey];
              if (pendingRevalidate) {
                const revalidatedResult = await pendingRevalidate;
                return new Response(revalidatedResult.body, {
                  headers: revalidatedResult.headers,
                  status: revalidatedResult.status,
                  statusText: revalidatedResult.statusText,
                });
              }
              // We used to just resolve the Response and clone it however for
              // static generation with dynamicIO we need the response to be able to
              // be resolved in a microtask and cloning the response will never have
              // a body that can resolve in a microtask in node (as observed through
              // experimentation) So instead we await the body and then when it is
              // available we construct manually cloned Response objects with the
              // body as an ArrayBuffer. This will be resolvable in a microtask
              // making it compatible with dynamicIO.
              const pendingResponse = doOriginalFetch(true, cacheReasonOverride) // We're cloning the response using this utility because there
                // exists a bug in the undici library around response cloning.
                // See the following pull request for more details:
                // https://github.com/vercel/next.js/pull/73274
                .then(_cloneresponse.cloneResponse);
              pendingRevalidate = pendingResponse
                .then(async (responses) => {
                  const response = responses[0];
                  return {
                    body: await response.arrayBuffer(),
                    headers: response.headers,
                    status: response.status,
                    statusText: response.statusText,
                  };
                })
                .finally(() => {
                  var _workStore_pendingRevalidates;
                  // If the pending revalidate is not present in the store, then
                  // we have nothing to delete.
                  if (
                    !((_workStore_pendingRevalidates = workStore.pendingRevalidates) ==
                    null
                      ? void 0
                      : _workStore_pendingRevalidates[pendingRevalidateKey])
                  ) {
                    return;
                  }
                  delete workStore.pendingRevalidates[pendingRevalidateKey];
                });
              // Attach the empty catch here so we don't get a "unhandled promise
              // rejection" warning
              pendingRevalidate.catch(() => {});
              workStore.pendingRevalidates[pendingRevalidateKey] = pendingRevalidate;
              return pendingResponse.then((responses) => responses[1]);
            } else {
              return doOriginalFetch(false, cacheReasonOverride);
            }
          }
        );
        if (cacheSignal) {
          try {
            return await result;
          } finally {
            if (cacheSignal) {
              cacheSignal.endRead();
            }
          }
        }
        return result;
      };
      // Attach the necessary properties to the patched fetch function.
      // We don't use this to determine if the fetch function has been patched,
      // but for external consumers to determine if the fetch function has been
      // patched.
      patched.__nextPatched = true;
      patched.__nextGetStaticStore = () => workAsyncStorage;
      patched._nextOriginalFetch = originFetch;
      globalThis[NEXT_PATCH_SYMBOL] = true;
      return patched;
    }
    function patchFetch(options) {
      // If we've already patched fetch, we should not patch it again.
      if (isFetchPatched()) return;
      // Grab the original fetch function. We'll attach this so we can use it in
      // the patched fetch function.
      const original = (0, _dedupefetch.createDedupeFetch)(globalThis.fetch);
      // Set the global fetch to the patched fetch.
      globalThis.fetch = createPatchedFetcher(original, options);
    }

    //# sourceMappingURL=patch-fetch.js.map
  },
  5480: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'isPostpone', {
      enumerable: true,
      get: function () {
        return isPostpone;
      },
    });
    const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
    function isPostpone(error) {
      return (
        typeof error === 'object' &&
        error !== null &&
        error.$$typeof === REACT_POSTPONE_TYPE
      );
    }

    //# sourceMappingURL=is-postpone.js.map
  },
  2917: function (__unused_webpack_module, exports) {
    'use strict';
    /**
     * Contains predefined constants for the trace span name in next/server.
     *
     * Currently, next/server/tracer is internal implementation only for tracking next.js's
     * implementation only with known span names defined here.
     */ // eslint typescript has a bug with TS enums
    /* eslint-disable no-shadow */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      AppRenderSpan: function () {
        return AppRenderSpan;
      },
      AppRouteRouteHandlersSpan: function () {
        return AppRouteRouteHandlersSpan;
      },
      BaseServerSpan: function () {
        return BaseServerSpan;
      },
      LoadComponentsSpan: function () {
        return LoadComponentsSpan;
      },
      LogSpanAllowList: function () {
        return LogSpanAllowList;
      },
      MiddlewareSpan: function () {
        return MiddlewareSpan;
      },
      NextNodeServerSpan: function () {
        return NextNodeServerSpan;
      },
      NextServerSpan: function () {
        return NextServerSpan;
      },
      NextVanillaSpanAllowlist: function () {
        return NextVanillaSpanAllowlist;
      },
      NodeSpan: function () {
        return NodeSpan;
      },
      RenderSpan: function () {
        return RenderSpan;
      },
      ResolveMetadataSpan: function () {
        return ResolveMetadataSpan;
      },
      RouterSpan: function () {
        return RouterSpan;
      },
      StartServerSpan: function () {
        return StartServerSpan;
      },
    });
    var BaseServerSpan = /*#__PURE__*/ (function (BaseServerSpan) {
      BaseServerSpan['handleRequest'] = 'BaseServer.handleRequest';
      BaseServerSpan['run'] = 'BaseServer.run';
      BaseServerSpan['pipe'] = 'BaseServer.pipe';
      BaseServerSpan['getStaticHTML'] = 'BaseServer.getStaticHTML';
      BaseServerSpan['render'] = 'BaseServer.render';
      BaseServerSpan['renderToResponseWithComponents'] =
        'BaseServer.renderToResponseWithComponents';
      BaseServerSpan['renderToResponse'] = 'BaseServer.renderToResponse';
      BaseServerSpan['renderToHTML'] = 'BaseServer.renderToHTML';
      BaseServerSpan['renderError'] = 'BaseServer.renderError';
      BaseServerSpan['renderErrorToResponse'] = 'BaseServer.renderErrorToResponse';
      BaseServerSpan['renderErrorToHTML'] = 'BaseServer.renderErrorToHTML';
      BaseServerSpan['render404'] = 'BaseServer.render404';
      return BaseServerSpan;
    })(BaseServerSpan || {});
    var LoadComponentsSpan = /*#__PURE__*/ (function (LoadComponentsSpan) {
      LoadComponentsSpan['loadDefaultErrorComponents'] =
        'LoadComponents.loadDefaultErrorComponents';
      LoadComponentsSpan['loadComponents'] = 'LoadComponents.loadComponents';
      return LoadComponentsSpan;
    })(LoadComponentsSpan || {});
    var NextServerSpan = /*#__PURE__*/ (function (NextServerSpan) {
      NextServerSpan['getRequestHandler'] = 'NextServer.getRequestHandler';
      NextServerSpan['getServer'] = 'NextServer.getServer';
      NextServerSpan['getServerRequestHandler'] = 'NextServer.getServerRequestHandler';
      NextServerSpan['createServer'] = 'createServer.createServer';
      return NextServerSpan;
    })(NextServerSpan || {});
    var NextNodeServerSpan = /*#__PURE__*/ (function (NextNodeServerSpan) {
      NextNodeServerSpan['compression'] = 'NextNodeServer.compression';
      NextNodeServerSpan['getBuildId'] = 'NextNodeServer.getBuildId';
      NextNodeServerSpan['createComponentTree'] = 'NextNodeServer.createComponentTree';
      NextNodeServerSpan['clientComponentLoading'] =
        'NextNodeServer.clientComponentLoading';
      NextNodeServerSpan['getLayoutOrPageModule'] =
        'NextNodeServer.getLayoutOrPageModule';
      NextNodeServerSpan['generateStaticRoutes'] = 'NextNodeServer.generateStaticRoutes';
      NextNodeServerSpan['generateFsStaticRoutes'] =
        'NextNodeServer.generateFsStaticRoutes';
      NextNodeServerSpan['generatePublicRoutes'] = 'NextNodeServer.generatePublicRoutes';
      NextNodeServerSpan['generateImageRoutes'] =
        'NextNodeServer.generateImageRoutes.route';
      NextNodeServerSpan['sendRenderResult'] = 'NextNodeServer.sendRenderResult';
      NextNodeServerSpan['proxyRequest'] = 'NextNodeServer.proxyRequest';
      NextNodeServerSpan['runApi'] = 'NextNodeServer.runApi';
      NextNodeServerSpan['render'] = 'NextNodeServer.render';
      NextNodeServerSpan['renderHTML'] = 'NextNodeServer.renderHTML';
      NextNodeServerSpan['imageOptimizer'] = 'NextNodeServer.imageOptimizer';
      NextNodeServerSpan['getPagePath'] = 'NextNodeServer.getPagePath';
      NextNodeServerSpan['getRoutesManifest'] = 'NextNodeServer.getRoutesManifest';
      NextNodeServerSpan['findPageComponents'] = 'NextNodeServer.findPageComponents';
      NextNodeServerSpan['getFontManifest'] = 'NextNodeServer.getFontManifest';
      NextNodeServerSpan['getServerComponentManifest'] =
        'NextNodeServer.getServerComponentManifest';
      NextNodeServerSpan['getRequestHandler'] = 'NextNodeServer.getRequestHandler';
      NextNodeServerSpan['renderToHTML'] = 'NextNodeServer.renderToHTML';
      NextNodeServerSpan['renderError'] = 'NextNodeServer.renderError';
      NextNodeServerSpan['renderErrorToHTML'] = 'NextNodeServer.renderErrorToHTML';
      NextNodeServerSpan['render404'] = 'NextNodeServer.render404';
      NextNodeServerSpan['startResponse'] = 'NextNodeServer.startResponse';
      // nested inner span, does not require parent scope name
      NextNodeServerSpan['route'] = 'route';
      NextNodeServerSpan['onProxyReq'] = 'onProxyReq';
      NextNodeServerSpan['apiResolver'] = 'apiResolver';
      NextNodeServerSpan['internalFetch'] = 'internalFetch';
      return NextNodeServerSpan;
    })(NextNodeServerSpan || {});
    var StartServerSpan = /*#__PURE__*/ (function (StartServerSpan) {
      StartServerSpan['startServer'] = 'startServer.startServer';
      return StartServerSpan;
    })(StartServerSpan || {});
    var RenderSpan = /*#__PURE__*/ (function (RenderSpan) {
      RenderSpan['getServerSideProps'] = 'Render.getServerSideProps';
      RenderSpan['getStaticProps'] = 'Render.getStaticProps';
      RenderSpan['renderToString'] = 'Render.renderToString';
      RenderSpan['renderDocument'] = 'Render.renderDocument';
      RenderSpan['createBodyResult'] = 'Render.createBodyResult';
      return RenderSpan;
    })(RenderSpan || {});
    var AppRenderSpan = /*#__PURE__*/ (function (AppRenderSpan) {
      AppRenderSpan['renderToString'] = 'AppRender.renderToString';
      AppRenderSpan['renderToReadableStream'] = 'AppRender.renderToReadableStream';
      AppRenderSpan['getBodyResult'] = 'AppRender.getBodyResult';
      AppRenderSpan['fetch'] = 'AppRender.fetch';
      return AppRenderSpan;
    })(AppRenderSpan || {});
    var RouterSpan = /*#__PURE__*/ (function (RouterSpan) {
      RouterSpan['executeRoute'] = 'Router.executeRoute';
      return RouterSpan;
    })(RouterSpan || {});
    var NodeSpan = /*#__PURE__*/ (function (NodeSpan) {
      NodeSpan['runHandler'] = 'Node.runHandler';
      return NodeSpan;
    })(NodeSpan || {});
    var AppRouteRouteHandlersSpan = /*#__PURE__*/ (function (AppRouteRouteHandlersSpan) {
      AppRouteRouteHandlersSpan['runHandler'] = 'AppRouteRouteHandlers.runHandler';
      return AppRouteRouteHandlersSpan;
    })(AppRouteRouteHandlersSpan || {});
    var ResolveMetadataSpan = /*#__PURE__*/ (function (ResolveMetadataSpan) {
      ResolveMetadataSpan['generateMetadata'] = 'ResolveMetadata.generateMetadata';
      ResolveMetadataSpan['generateViewport'] = 'ResolveMetadata.generateViewport';
      return ResolveMetadataSpan;
    })(ResolveMetadataSpan || {});
    var MiddlewareSpan = /*#__PURE__*/ (function (MiddlewareSpan) {
      MiddlewareSpan['execute'] = 'Middleware.execute';
      return MiddlewareSpan;
    })(MiddlewareSpan || {});
    const NextVanillaSpanAllowlist = [
      'Middleware.execute',
      'BaseServer.handleRequest',
      'Render.getServerSideProps',
      'Render.getStaticProps',
      'AppRender.fetch',
      'AppRender.getBodyResult',
      'Render.renderDocument',
      'Node.runHandler',
      'AppRouteRouteHandlers.runHandler',
      'ResolveMetadata.generateMetadata',
      'ResolveMetadata.generateViewport',
      'NextNodeServer.createComponentTree',
      'NextNodeServer.findPageComponents',
      'NextNodeServer.getLayoutOrPageModule',
      'NextNodeServer.startResponse',
      'NextNodeServer.clientComponentLoading',
    ];
    const LogSpanAllowList = [
      'NextNodeServer.findPageComponents',
      'NextNodeServer.createComponentTree',
      'NextNodeServer.clientComponentLoading',
    ];

    //# sourceMappingURL=constants.js.map
  },
  9223: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      BubbledError: function () {
        return BubbledError;
      },
      SpanKind: function () {
        return SpanKind;
      },
      SpanStatusCode: function () {
        return SpanStatusCode;
      },
      getTracer: function () {
        return getTracer;
      },
      isBubbledError: function () {
        return isBubbledError;
      },
    });
    const _constants = __webpack_require__(2917);
    const _isthenable = __webpack_require__(7268);
    let api;
    // we want to allow users to use their own version of @opentelemetry/api if they
    // want to, so we try to require it first, and if it fails we fall back to the
    // version that is bundled with Next.js
    // this is because @opentelemetry/api has to be synced with the version of
    // @opentelemetry/tracing that is used, and we don't want to force users to use
    // the version that is bundled with Next.js.
    // the API is ~stable, so this should be fine
    if (false) {
    } else {
      try {
        api = __webpack_require__(5358);
      } catch (err) {
        api = __webpack_require__(5358);
      }
    }
    const { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } = api;
    class BubbledError extends Error {
      constructor(bubble, result) {
        super(), (this.bubble = bubble), (this.result = result);
      }
    }
    function isBubbledError(error) {
      if (typeof error !== 'object' || error === null) return false;
      return error instanceof BubbledError;
    }
    const closeSpanWithError = (span, error) => {
      if (isBubbledError(error) && error.bubble) {
        span.setAttribute('next.bubble', true);
      } else {
        if (error) {
          span.recordException(error);
        }
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error == null ? void 0 : error.message,
        });
      }
      span.end();
    };
    /** We use this map to propagate attributes from nested spans to the top span */ const rootSpanAttributesStore =
      new Map();
    const rootSpanIdKey = api.createContextKey('next.rootSpanId');
    let lastSpanId = 0;
    const getSpanId = () => lastSpanId++;
    const clientTraceDataSetter = {
      set(carrier, key, value) {
        carrier.push({
          key,
          value,
        });
      },
    };
    class NextTracerImpl {
      /**
       * Returns an instance to the trace with configured name. Since wrap / trace can be
       * defined in any place prior to actual trace subscriber initialization, This should
       * be lazily evaluated.
       */ getTracerInstance() {
        return trace.getTracer('next.js', '0.0.1');
      }
      getContext() {
        return context;
      }
      getTracePropagationData() {
        const activeContext = context.active();
        const entries = [];
        propagation.inject(activeContext, entries, clientTraceDataSetter);
        return entries;
      }
      getActiveScopeSpan() {
        return trace.getSpan(context == null ? void 0 : context.active());
      }
      withPropagatedContext(carrier, fn, getter) {
        const activeContext = context.active();
        if (trace.getSpanContext(activeContext)) {
          // Active span is already set, too late to propagate.
          return fn();
        }
        const remoteContext = propagation.extract(activeContext, carrier, getter);
        return context.with(remoteContext, fn);
      }
      trace(...args) {
        var _trace_getSpanContext;
        const [type, fnOrOptions, fnOrEmpty] = args;
        // coerce options form overload
        const { fn, options } =
          typeof fnOrOptions === 'function'
            ? {
                fn: fnOrOptions,
                options: {},
              }
            : {
                fn: fnOrEmpty,
                options: {
                  ...fnOrOptions,
                },
              };
        const spanName = options.spanName ?? type;
        if (
          (!_constants.NextVanillaSpanAllowlist.includes(type) &&
            process.env.NEXT_OTEL_VERBOSE !== '1') ||
          options.hideSpan
        ) {
          return fn();
        }
        // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.
        let spanContext = this.getSpanContext(
          (options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan()
        );
        let isRootSpan = false;
        if (!spanContext) {
          spanContext = (context == null ? void 0 : context.active()) ?? ROOT_CONTEXT;
          isRootSpan = true;
        } else if (
          (_trace_getSpanContext = trace.getSpanContext(spanContext)) == null
            ? void 0
            : _trace_getSpanContext.isRemote
        ) {
          isRootSpan = true;
        }
        const spanId = getSpanId();
        options.attributes = {
          'next.span_name': spanName,
          'next.span_type': type,
          ...options.attributes,
        };
        return context.with(spanContext.setValue(rootSpanIdKey, spanId), () =>
          this.getTracerInstance().startActiveSpan(spanName, options, (span) => {
            const startTime =
              'performance' in globalThis && 'measure' in performance
                ? globalThis.performance.now()
                : undefined;
            const onCleanup = () => {
              rootSpanAttributesStore.delete(spanId);
              if (
                startTime &&
                process.env.NEXT_OTEL_PERFORMANCE_PREFIX &&
                _constants.LogSpanAllowList.includes(type || '')
              ) {
                performance.measure(
                  `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(type.split('.').pop() || '').replace(/[A-Z]/g, (match) => '-' + match.toLowerCase())}`,
                  {
                    start: startTime,
                    end: performance.now(),
                  }
                );
              }
            };
            if (isRootSpan) {
              rootSpanAttributesStore.set(
                spanId,
                new Map(Object.entries(options.attributes ?? {}))
              );
            }
            try {
              if (fn.length > 1) {
                return fn(span, (err) => closeSpanWithError(span, err));
              }
              const result = fn(span);
              if ((0, _isthenable.isThenable)(result)) {
                // If there's error make sure it throws
                return result
                  .then((res) => {
                    span.end();
                    // Need to pass down the promise result,
                    // it could be react stream response with error { error, stream }
                    return res;
                  })
                  .catch((err) => {
                    closeSpanWithError(span, err);
                    throw err;
                  })
                  .finally(onCleanup);
              } else {
                span.end();
                onCleanup();
              }
              return result;
            } catch (err) {
              closeSpanWithError(span, err);
              onCleanup();
              throw err;
            }
          })
        );
      }
      wrap(...args) {
        const tracer = this;
        const [name, options, fn] = args.length === 3 ? args : [args[0], {}, args[1]];
        if (
          !_constants.NextVanillaSpanAllowlist.includes(name) &&
          process.env.NEXT_OTEL_VERBOSE !== '1'
        ) {
          return fn;
        }
        return function () {
          let optionsObj = options;
          if (typeof optionsObj === 'function' && typeof fn === 'function') {
            optionsObj = optionsObj.apply(this, arguments);
          }
          const lastArgId = arguments.length - 1;
          const cb = arguments[lastArgId];
          if (typeof cb === 'function') {
            const scopeBoundCb = tracer.getContext().bind(context.active(), cb);
            return tracer.trace(name, optionsObj, (_span, done) => {
              arguments[lastArgId] = function (err) {
                done == null ? void 0 : done(err);
                return scopeBoundCb.apply(this, arguments);
              };
              return fn.apply(this, arguments);
            });
          } else {
            return tracer.trace(name, optionsObj, () => fn.apply(this, arguments));
          }
        };
      }
      startSpan(...args) {
        const [type, options] = args;
        const spanContext = this.getSpanContext(
          (options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan()
        );
        return this.getTracerInstance().startSpan(type, options, spanContext);
      }
      getSpanContext(parentSpan) {
        const spanContext = parentSpan
          ? trace.setSpan(context.active(), parentSpan)
          : undefined;
        return spanContext;
      }
      getRootSpanAttributes() {
        const spanId = context.active().getValue(rootSpanIdKey);
        return rootSpanAttributesStore.get(spanId);
      }
      setRootSpanAttribute(key, value) {
        const spanId = context.active().getValue(rootSpanIdKey);
        const attributes = rootSpanAttributesStore.get(spanId);
        if (attributes) {
          attributes.set(key, value);
        }
      }
    }
    const getTracer = (() => {
      const tracer = new NextTracerImpl();
      return () => tracer;
    })();

    //# sourceMappingURL=tracer.js.map
  },
  2166: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      isAbortError: function () {
        return isAbortError;
      },
      pipeToNodeResponse: function () {
        return pipeToNodeResponse;
      },
    });
    const _nextrequest = __webpack_require__(7125);
    const _detachedpromise = __webpack_require__(8308);
    const _tracer = __webpack_require__(9223);
    const _constants = __webpack_require__(2917);
    const _clientcomponentrendererlogger = __webpack_require__(2738);
    function isAbortError(e) {
      return (
        (e == null ? void 0 : e.name) === 'AbortError' ||
        (e == null ? void 0 : e.name) === _nextrequest.ResponseAbortedName
      );
    }
    function createWriterFromResponse(res, waitUntilForEnd) {
      let started = false;
      // Create a promise that will resolve once the response has drained. See
      // https://nodejs.org/api/stream.html#stream_event_drain
      let drained = new _detachedpromise.DetachedPromise();
      function onDrain() {
        drained.resolve();
      }
      res.on('drain', onDrain);
      // If the finish event fires, it means we shouldn't block and wait for the
      // drain event.
      res.once('close', () => {
        res.off('drain', onDrain);
        drained.resolve();
      });
      // Create a promise that will resolve once the response has finished. See
      // https://nodejs.org/api/http.html#event-finish_1
      const finished = new _detachedpromise.DetachedPromise();
      res.once('finish', () => {
        finished.resolve();
      });
      // Create a writable stream that will write to the response.
      return new WritableStream({
        write: async (chunk) => {
          // You'd think we'd want to use `start` instead of placing this in `write`
          // but this ensures that we don't actually flush the headers until we've
          // started writing chunks.
          if (!started) {
            started = true;
            if ('performance' in globalThis && process.env.NEXT_OTEL_PERFORMANCE_PREFIX) {
              const metrics = (0,
              _clientcomponentrendererlogger.getClientComponentLoaderMetrics)();
              if (metrics) {
                performance.measure(
                  `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,
                  {
                    start: metrics.clientComponentLoadStart,
                    end:
                      metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes,
                  }
                );
              }
            }
            res.flushHeaders();
            (0, _tracer.getTracer)().trace(
              _constants.NextNodeServerSpan.startResponse,
              {
                spanName: 'start response',
              },
              () => undefined
            );
          }
          try {
            const ok = res.write(chunk);
            // Added by the `compression` middleware, this is a function that will
            // flush the partially-compressed response to the client.
            if ('flush' in res && typeof res.flush === 'function') {
              res.flush();
            }
            // If the write returns false, it means there's some backpressure, so
            // wait until it's streamed before continuing.
            if (!ok) {
              await drained.promise;
              // Reset the drained promise so that we can wait for the next drain event.
              drained = new _detachedpromise.DetachedPromise();
            }
          } catch (err) {
            res.end();
            throw Object.defineProperty(
              new Error('failed to write chunk to response', {
                cause: err,
              }),
              '__NEXT_ERROR_CODE',
              {
                value: 'E321',
                enumerable: false,
                configurable: true,
              }
            );
          }
        },
        abort: (err) => {
          if (res.writableFinished) return;
          res.destroy(err);
        },
        close: async () => {
          // if a waitUntil promise was passed, wait for it to resolve before
          // ending the response.
          if (waitUntilForEnd) {
            await waitUntilForEnd;
          }
          if (res.writableFinished) return;
          res.end();
          return finished.promise;
        },
      });
    }
    async function pipeToNodeResponse(readable, res, waitUntilForEnd) {
      try {
        // If the response has already errored, then just return now.
        const { errored, destroyed } = res;
        if (errored || destroyed) return;
        // Create a new AbortController so that we can abort the readable if the
        // client disconnects.
        const controller = (0, _nextrequest.createAbortController)(res);
        const writer = createWriterFromResponse(res, waitUntilForEnd);
        await readable.pipeTo(writer, {
          signal: controller.signal,
        });
      } catch (err) {
        // If this isn't related to an abort error, re-throw it.
        if (isAbortError(err)) return;
        throw Object.defineProperty(
          new Error('failed to pipe response', {
            cause: err,
          }),
          '__NEXT_ERROR_CODE',
          {
            value: 'E180',
            enumerable: false,
            configurable: true,
          }
        );
      }
    }

    //# sourceMappingURL=pipe-readable.js.map
  },
  3620: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return RenderResult;
      },
    });
    const _nodewebstreamshelper = __webpack_require__(227);
    const _pipereadable = __webpack_require__(2166);
    class RenderResult {
      /**
       * Creates a new RenderResult instance from a static response.
       *
       * @param value The static response value
       * @returns A new RenderResult instance
       */ static fromStatic(value) {
        return new RenderResult(value, {
          metadata: {},
        });
      }
      constructor(response, { contentType, waitUntil, metadata }) {
        this.response = response;
        this.contentType = contentType;
        this.metadata = metadata;
        this.waitUntil = waitUntil;
      }
      assignMetadata(metadata) {
        Object.assign(this.metadata, metadata);
      }
      /**
       * Returns true if the response is null. It can be null if the response was not found
       * or was already sent.
       */ get isNull() {
        return this.response === null;
      }
      /**
       * Returns false if the response is a string. It can be a string if the page was
       * prerendered. If it's not, then it was generated dynamically.
       */ get isDynamic() {
        return typeof this.response !== 'string';
      }
      toUnchunkedBuffer(stream = false) {
        if (this.response === null) {
          throw Object.defineProperty(
            new Error('Invariant: null responses cannot be unchunked'),
            '__NEXT_ERROR_CODE',
            {
              value: 'E274',
              enumerable: false,
              configurable: true,
            }
          );
        }
        if (typeof this.response !== 'string') {
          if (!stream) {
            throw Object.defineProperty(
              new Error(
                'Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'
              ),
              '__NEXT_ERROR_CODE',
              {
                value: 'E81',
                enumerable: false,
                configurable: true,
              }
            );
          }
          return (0, _nodewebstreamshelper.streamToBuffer)(this.readable);
        }
        return Buffer.from(this.response);
      }
      toUnchunkedString(stream = false) {
        if (this.response === null) {
          throw Object.defineProperty(
            new Error('Invariant: null responses cannot be unchunked'),
            '__NEXT_ERROR_CODE',
            {
              value: 'E274',
              enumerable: false,
              configurable: true,
            }
          );
        }
        if (typeof this.response !== 'string') {
          if (!stream) {
            throw Object.defineProperty(
              new Error(
                'Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'
              ),
              '__NEXT_ERROR_CODE',
              {
                value: 'E81',
                enumerable: false,
                configurable: true,
              }
            );
          }
          return (0, _nodewebstreamshelper.streamToString)(this.readable);
        }
        return this.response;
      }
      /** Returns the response if it is a stream, or throws an error if it is a string. */ get readable() {
        if (this.response === null) {
          throw Object.defineProperty(
            new Error('Invariant: null responses cannot be streamed'),
            '__NEXT_ERROR_CODE',
            {
              value: 'E14',
              enumerable: false,
              configurable: true,
            }
          );
        }
        if (typeof this.response === 'string') {
          throw Object.defineProperty(
            new Error('Invariant: static responses cannot be streamed'),
            '__NEXT_ERROR_CODE',
            {
              value: 'E151',
              enumerable: false,
              configurable: true,
            }
          );
        }
        if (Buffer.isBuffer(this.response)) {
          return (0, _nodewebstreamshelper.streamFromBuffer)(this.response);
        }
        // If the response is an array of streams, then chain them together.
        if (Array.isArray(this.response)) {
          return (0, _nodewebstreamshelper.chainStreams)(...this.response);
        }
        return this.response;
      }
      /**
       * Chains a new stream to the response. This will convert the response to an array of
       * streams if it is not already one and will add the new stream to the end. When this
       * response is piped, all of the streams will be piped one after the other.
       *
       * @param readable The new stream to chain
       */ chain(readable) {
        if (this.response === null) {
          throw Object.defineProperty(
            new Error('Invariant: response is null. This is a bug in Next.js'),
            '__NEXT_ERROR_CODE',
            {
              value: 'E258',
              enumerable: false,
              configurable: true,
            }
          );
        }
        // If the response is not an array of streams already, make it one.
        let responses;
        if (typeof this.response === 'string') {
          responses = [(0, _nodewebstreamshelper.streamFromString)(this.response)];
        } else if (Array.isArray(this.response)) {
          responses = this.response;
        } else if (Buffer.isBuffer(this.response)) {
          responses = [(0, _nodewebstreamshelper.streamFromBuffer)(this.response)];
        } else {
          responses = [this.response];
        }
        // Add the new stream to the array.
        responses.push(readable);
        // Update the response.
        this.response = responses;
      }
      /**
       * Pipes the response to a writable stream. This will close/cancel the writable stream
       * if an error is encountered. If this doesn't throw, then the writable stream will be
       * closed or aborted.
       *
       * @param writable Writable stream to pipe the response to
       */ async pipeTo(writable) {
        try {
          await this.readable.pipeTo(writable, {
            // We want to close the writable stream ourselves so that we can wait
            // for the waitUntil promise to resolve before closing it. If an error
            // is encountered, we'll abort the writable stream if we swallowed the
            // error.
            preventClose: true,
          });
          // If there is a waitUntil promise, wait for it to resolve before
          // closing the writable stream.
          if (this.waitUntil) await this.waitUntil;
          // Close the writable stream.
          await writable.close();
        } catch (err) {
          // If this is an abort error, we should abort the writable stream (as we
          // took ownership of it when we started piping). We don't need to re-throw
          // because we handled the error.
          if ((0, _pipereadable.isAbortError)(err)) {
            // Abort the writable stream if an error is encountered.
            await writable.abort(err);
            return;
          }
          // We're not aborting the writer here as when this method throws it's not
          // clear as to how so the caller should assume it's their responsibility
          // to clean up the writer.
          throw err;
        }
      }
      /**
       * Pipes the response to a node response. This will close/cancel the node response if
       * an error is encountered.
       *
       * @param res
       */ async pipeToNodeResponse(res) {
        await (0, _pipereadable.pipeToNodeResponse)(this.readable, res, this.waitUntil);
      }
    }

    //# sourceMappingURL=render-result.js.map
  },
  7071: function (__unused_webpack_module, exports) {
    'use strict';
    /* eslint-disable no-redeclare */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      NEXT_REQUEST_META: function () {
        return NEXT_REQUEST_META;
      },
      addRequestMeta: function () {
        return addRequestMeta;
      },
      getRequestMeta: function () {
        return getRequestMeta;
      },
      removeRequestMeta: function () {
        return removeRequestMeta;
      },
      setRequestMeta: function () {
        return setRequestMeta;
      },
    });
    const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta');
    function getRequestMeta(req, key) {
      const meta = req[NEXT_REQUEST_META] || {};
      return typeof key === 'string' ? meta[key] : meta;
    }
    function setRequestMeta(req, meta) {
      req[NEXT_REQUEST_META] = meta;
      return meta;
    }
    function addRequestMeta(request, key, value) {
      const meta = getRequestMeta(request);
      meta[key] = value;
      return setRequestMeta(request, meta);
    }
    function removeRequestMeta(request, key) {
      const meta = getRequestMeta(request);
      delete meta[key];
      return setRequestMeta(request, meta);
    }

    //# sourceMappingURL=request-meta.js.map
  },
  5683: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      createParamsFromClient: function () {
        return createParamsFromClient;
      },
      createPrerenderParamsForClientSegment: function () {
        return createPrerenderParamsForClientSegment;
      },
      createServerParamsForMetadata: function () {
        return createServerParamsForMetadata;
      },
      createServerParamsForRoute: function () {
        return createServerParamsForRoute;
      },
      createServerParamsForServerSegment: function () {
        return createServerParamsForServerSegment;
      },
    });
    const _reflect = __webpack_require__(7025);
    const _dynamicrendering = __webpack_require__(7811);
    const _workunitasyncstorageexternal = __webpack_require__(412);
    const _invarianterror = __webpack_require__(9288);
    const _reflectutils = __webpack_require__(1898);
    const _dynamicrenderingutils = __webpack_require__(8458);
    const _creatededupedbycallsiteservererrorlogger = __webpack_require__(8298);
    const _scheduler = __webpack_require__(4230);
    function createParamsFromClient(underlyingParams, workStore) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        switch (workUnitStore.type) {
          case 'prerender':
          case 'prerender-ppr':
          case 'prerender-legacy':
            return createPrerenderParams(underlyingParams, workStore, workUnitStore);
          default:
        }
      }
      return createRenderParams(underlyingParams, workStore);
    }
    const createServerParamsForMetadata = createServerParamsForServerSegment;
    function createServerParamsForRoute(underlyingParams, workStore) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        switch (workUnitStore.type) {
          case 'prerender':
          case 'prerender-ppr':
          case 'prerender-legacy':
            return createPrerenderParams(underlyingParams, workStore, workUnitStore);
          default:
        }
      }
      return createRenderParams(underlyingParams, workStore);
    }
    function createServerParamsForServerSegment(underlyingParams, workStore) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        switch (workUnitStore.type) {
          case 'prerender':
          case 'prerender-ppr':
          case 'prerender-legacy':
            return createPrerenderParams(underlyingParams, workStore, workUnitStore);
          default:
        }
      }
      return createRenderParams(underlyingParams, workStore);
    }
    function createPrerenderParamsForClientSegment(underlyingParams, workStore) {
      const prerenderStore =
        _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (prerenderStore && prerenderStore.type === 'prerender') {
        const fallbackParams = workStore.fallbackRouteParams;
        if (fallbackParams) {
          for (let key in underlyingParams) {
            if (fallbackParams.has(key)) {
              // This params object has one of more fallback params so we need to consider
              // the awaiting of this params object "dynamic". Since we are in dynamicIO mode
              // we encode this as a promise that never resolves
              return (0, _dynamicrenderingutils.makeHangingPromise)(
                prerenderStore.renderSignal,
                '`params`'
              );
            }
          }
        }
      }
      // We're prerendering in a mode that does not abort. We resolve the promise without
      // any tracking because we're just transporting a value from server to client where the tracking
      // will be applied.
      return Promise.resolve(underlyingParams);
    }
    function createPrerenderParams(underlyingParams, workStore, prerenderStore) {
      const fallbackParams = workStore.fallbackRouteParams;
      if (fallbackParams) {
        let hasSomeFallbackParams = false;
        for (const key in underlyingParams) {
          if (fallbackParams.has(key)) {
            hasSomeFallbackParams = true;
            break;
          }
        }
        if (hasSomeFallbackParams) {
          // params need to be treated as dynamic because we have at least one fallback param
          if (prerenderStore.type === 'prerender') {
            // We are in a dynamicIO (PPR or otherwise) prerender
            return makeAbortingExoticParams(
              underlyingParams,
              workStore.route,
              prerenderStore
            );
          }
          // remaining cases are prerender-ppr and prerender-legacy
          // We aren't in a dynamicIO prerender but we do have fallback params at this
          // level so we need to make an erroring exotic params object which will postpone
          // if you access the fallback params
          return makeErroringExoticParams(
            underlyingParams,
            fallbackParams,
            workStore,
            prerenderStore
          );
        }
      }
      // We don't have any fallback params so we have an entirely static safe params object
      return makeUntrackedExoticParams(underlyingParams);
    }
    function createRenderParams(underlyingParams, workStore) {
      if (true && !workStore.isPrefetchRequest) {
        return makeDynamicallyTrackedExoticParamsWithDevWarnings(
          underlyingParams,
          workStore
        );
      } else {
        return makeUntrackedExoticParams(underlyingParams);
      }
    }
    const CachedParams = new WeakMap();
    function makeAbortingExoticParams(underlyingParams, route, prerenderStore) {
      const cachedParams = CachedParams.get(underlyingParams);
      if (cachedParams) {
        return cachedParams;
      }
      const promise = (0, _dynamicrenderingutils.makeHangingPromise)(
        prerenderStore.renderSignal,
        '`params`'
      );
      CachedParams.set(underlyingParams, promise);
      Object.keys(underlyingParams).forEach((prop) => {
        if (_reflectutils.wellKnownProperties.has(prop)) {
          // These properties cannot be shadowed because they need to be the
          // true underlying value for Promises to work correctly at runtime
        } else {
          Object.defineProperty(promise, prop, {
            get() {
              const expression = (0, _reflectutils.describeStringPropertyAccess)(
                'params',
                prop
              );
              const error = createParamsAccessError(route, expression);
              (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(
                route,
                expression,
                error,
                prerenderStore
              );
            },
            set(newValue) {
              Object.defineProperty(promise, prop, {
                value: newValue,
                writable: true,
                enumerable: true,
              });
            },
            enumerable: true,
            configurable: true,
          });
        }
      });
      return promise;
    }
    function makeErroringExoticParams(
      underlyingParams,
      fallbackParams,
      workStore,
      prerenderStore
    ) {
      const cachedParams = CachedParams.get(underlyingParams);
      if (cachedParams) {
        return cachedParams;
      }
      const augmentedUnderlying = {
        ...underlyingParams,
      };
      // We don't use makeResolvedReactPromise here because params
      // supports copying with spread and we don't want to unnecessarily
      // instrument the promise with spreadable properties of ReactPromise.
      const promise = Promise.resolve(augmentedUnderlying);
      CachedParams.set(underlyingParams, promise);
      Object.keys(underlyingParams).forEach((prop) => {
        if (_reflectutils.wellKnownProperties.has(prop)) {
          // These properties cannot be shadowed because they need to be the
          // true underlying value for Promises to work correctly at runtime
        } else {
          if (fallbackParams.has(prop)) {
            Object.defineProperty(augmentedUnderlying, prop, {
              get() {
                const expression = (0, _reflectutils.describeStringPropertyAccess)(
                  'params',
                  prop
                );
                // In most dynamic APIs we also throw if `dynamic = "error"` however
                // for params is only dynamic when we're generating a fallback shell
                // and even when `dynamic = "error"` we still support generating dynamic
                // fallback shells
                // TODO remove this comment when dynamicIO is the default since there
                // will be no `dynamic = "error"`
                if (prerenderStore.type === 'prerender-ppr') {
                  // PPR Prerender (no dynamicIO)
                  (0, _dynamicrendering.postponeWithTracking)(
                    workStore.route,
                    expression,
                    prerenderStore.dynamicTracking
                  );
                } else {
                  // Legacy Prerender
                  (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                    expression,
                    workStore,
                    prerenderStore
                  );
                }
              },
              enumerable: true,
            });
            Object.defineProperty(promise, prop, {
              get() {
                const expression = (0, _reflectutils.describeStringPropertyAccess)(
                  'params',
                  prop
                );
                // In most dynamic APIs we also throw if `dynamic = "error"` however
                // for params is only dynamic when we're generating a fallback shell
                // and even when `dynamic = "error"` we still support generating dynamic
                // fallback shells
                // TODO remove this comment when dynamicIO is the default since there
                // will be no `dynamic = "error"`
                if (prerenderStore.type === 'prerender-ppr') {
                  // PPR Prerender (no dynamicIO)
                  (0, _dynamicrendering.postponeWithTracking)(
                    workStore.route,
                    expression,
                    prerenderStore.dynamicTracking
                  );
                } else {
                  // Legacy Prerender
                  (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                    expression,
                    workStore,
                    prerenderStore
                  );
                }
              },
              set(newValue) {
                Object.defineProperty(promise, prop, {
                  value: newValue,
                  writable: true,
                  enumerable: true,
                });
              },
              enumerable: true,
              configurable: true,
            });
          } else {
            promise[prop] = underlyingParams[prop];
          }
        }
      });
      return promise;
    }
    function makeUntrackedExoticParams(underlyingParams) {
      const cachedParams = CachedParams.get(underlyingParams);
      if (cachedParams) {
        return cachedParams;
      }
      // We don't use makeResolvedReactPromise here because params
      // supports copying with spread and we don't want to unnecessarily
      // instrument the promise with spreadable properties of ReactPromise.
      const promise = Promise.resolve(underlyingParams);
      CachedParams.set(underlyingParams, promise);
      Object.keys(underlyingParams).forEach((prop) => {
        if (_reflectutils.wellKnownProperties.has(prop)) {
          // These properties cannot be shadowed because they need to be the
          // true underlying value for Promises to work correctly at runtime
        } else {
          promise[prop] = underlyingParams[prop];
        }
      });
      return promise;
    }
    function makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, store) {
      const cachedParams = CachedParams.get(underlyingParams);
      if (cachedParams) {
        return cachedParams;
      }
      // We don't use makeResolvedReactPromise here because params
      // supports copying with spread and we don't want to unnecessarily
      // instrument the promise with spreadable properties of ReactPromise.
      const promise = new Promise((resolve) =>
        (0, _scheduler.scheduleImmediate)(() => resolve(underlyingParams))
      );
      const proxiedProperties = new Set();
      const unproxiedProperties = [];
      Object.keys(underlyingParams).forEach((prop) => {
        if (_reflectutils.wellKnownProperties.has(prop)) {
          // These properties cannot be shadowed because they need to be the
          // true underlying value for Promises to work correctly at runtime
          unproxiedProperties.push(prop);
        } else {
          proxiedProperties.add(prop);
          promise[prop] = underlyingParams[prop];
        }
      });
      const proxiedPromise = new Proxy(promise, {
        get(target, prop, receiver) {
          if (typeof prop === 'string') {
            if (
              // We are accessing a property that was proxied to the promise instance
              proxiedProperties.has(prop)
            ) {
              const expression = (0, _reflectutils.describeStringPropertyAccess)(
                'params',
                prop
              );
              syncIODev(store.route, expression);
            }
          }
          return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (typeof prop === 'string') {
            proxiedProperties.delete(prop);
          }
          return _reflect.ReflectAdapter.set(target, prop, value, receiver);
        },
        ownKeys(target) {
          const expression = '`...params` or similar expression';
          syncIODev(store.route, expression, unproxiedProperties);
          return Reflect.ownKeys(target);
        },
      });
      CachedParams.set(underlyingParams, proxiedPromise);
      return proxiedPromise;
    }
    function syncIODev(route, expression, missingProperties) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (
        workUnitStore &&
        workUnitStore.type === 'request' &&
        workUnitStore.prerenderPhase === true
      ) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
      }
      // In all cases we warn normally
      if (missingProperties && missingProperties.length > 0) {
        warnForIncompleteEnumeration(route, expression, missingProperties);
      } else {
        warnForSyncAccess(route, expression);
      }
    }
    const warnForSyncAccess = (0,
    _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(
      createParamsAccessError
    );
    const warnForIncompleteEnumeration = (0,
    _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(
      createIncompleteEnumerationError
    );
    function createParamsAccessError(route, expression) {
      const prefix = route ? `Route "${route}" ` : 'This route ';
      return Object.defineProperty(
        new Error(
          `${prefix}used ${expression}. ` +
            `\`params\` should be awaited before using its properties. ` +
            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E307',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function createIncompleteEnumerationError(route, expression, missingProperties) {
      const prefix = route ? `Route "${route}" ` : 'This route ';
      return Object.defineProperty(
        new Error(
          `${prefix}used ${expression}. ` +
            `\`params\` should be awaited before using its properties. ` +
            `The following properties were not available through enumeration ` +
            `because they conflict with builtin property names: ` +
            `${describeListOfPropertyNames(missingProperties)}. ` +
            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E482',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function describeListOfPropertyNames(properties) {
      switch (properties.length) {
        case 0:
          throw Object.defineProperty(
            new _invarianterror.InvariantError(
              'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E531',
              enumerable: false,
              configurable: true,
            }
          );
        case 1:
          return `\`${properties[0]}\``;
        case 2:
          return `\`${properties[0]}\` and \`${properties[1]}\``;
        default: {
          let description = '';
          for (let i = 0; i < properties.length - 1; i++) {
            description += `\`${properties[i]}\`, `;
          }
          description += `, and \`${properties[properties.length - 1]}\``;
          return description;
        }
      }
    }

    //# sourceMappingURL=params.js.map
  },
  1611: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      createPrerenderSearchParamsForClientPage: function () {
        return createPrerenderSearchParamsForClientPage;
      },
      createSearchParamsFromClient: function () {
        return createSearchParamsFromClient;
      },
      createServerSearchParamsForMetadata: function () {
        return createServerSearchParamsForMetadata;
      },
      createServerSearchParamsForServerPage: function () {
        return createServerSearchParamsForServerPage;
      },
      makeErroringExoticSearchParamsForUseCache: function () {
        return makeErroringExoticSearchParamsForUseCache;
      },
    });
    const _reflect = __webpack_require__(7025);
    const _dynamicrendering = __webpack_require__(7811);
    const _workunitasyncstorageexternal = __webpack_require__(412);
    const _invarianterror = __webpack_require__(9288);
    const _dynamicrenderingutils = __webpack_require__(8458);
    const _creatededupedbycallsiteservererrorlogger = __webpack_require__(8298);
    const _reflectutils = __webpack_require__(1898);
    const _utils = __webpack_require__(4191);
    const _scheduler = __webpack_require__(4230);
    function createSearchParamsFromClient(underlyingSearchParams, workStore) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        switch (workUnitStore.type) {
          case 'prerender':
          case 'prerender-ppr':
          case 'prerender-legacy':
            return createPrerenderSearchParams(workStore, workUnitStore);
          default:
        }
      }
      return createRenderSearchParams(underlyingSearchParams, workStore);
    }
    const createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;
    function createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        switch (workUnitStore.type) {
          case 'prerender':
          case 'prerender-ppr':
          case 'prerender-legacy':
            return createPrerenderSearchParams(workStore, workUnitStore);
          default:
        }
      }
      return createRenderSearchParams(underlyingSearchParams, workStore);
    }
    function createPrerenderSearchParamsForClientPage(workStore) {
      if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
      }
      const prerenderStore =
        _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (prerenderStore && prerenderStore.type === 'prerender') {
        // dynamicIO Prerender
        // We're prerendering in a mode that aborts (dynamicIO) and should stall
        // the promise to ensure the RSC side is considered dynamic
        return (0, _dynamicrenderingutils.makeHangingPromise)(
          prerenderStore.renderSignal,
          '`searchParams`'
        );
      }
      // We're prerendering in a mode that does not aborts. We resolve the promise without
      // any tracking because we're just transporting a value from server to client where the tracking
      // will be applied.
      return Promise.resolve({});
    }
    function createPrerenderSearchParams(workStore, prerenderStore) {
      if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
      }
      if (prerenderStore.type === 'prerender') {
        // We are in a dynamicIO (PPR or otherwise) prerender
        return makeAbortingExoticSearchParams(workStore.route, prerenderStore);
      }
      // The remaining cases are prerender-ppr and prerender-legacy
      // We are in a legacy static generation and need to interrupt the prerender
      // when search params are accessed.
      return makeErroringExoticSearchParams(workStore, prerenderStore);
    }
    function createRenderSearchParams(underlyingSearchParams, workStore) {
      if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
      } else {
        if (true && !workStore.isPrefetchRequest) {
          return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(
            underlyingSearchParams,
            workStore
          );
        } else {
          return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore);
        }
      }
    }
    const CachedSearchParams = new WeakMap();
    const CachedSearchParamsForUseCache = new WeakMap();
    function makeAbortingExoticSearchParams(route, prerenderStore) {
      const cachedSearchParams = CachedSearchParams.get(prerenderStore);
      if (cachedSearchParams) {
        return cachedSearchParams;
      }
      const promise = (0, _dynamicrenderingutils.makeHangingPromise)(
        prerenderStore.renderSignal,
        '`searchParams`'
      );
      const proxiedPromise = new Proxy(promise, {
        get(target, prop, receiver) {
          if (Object.hasOwn(promise, prop)) {
            // The promise has this property directly. we must return it.
            // We know it isn't a dynamic access because it can only be something
            // that was previously written to the promise and thus not an underlying searchParam value
            return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
          switch (prop) {
            case 'then': {
              const expression = '`await searchParams`, `searchParams.then`, or similar';
              (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);
              return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            case 'status': {
              const expression = '`use(searchParams)`, `searchParams.status`, or similar';
              (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);
              return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            default: {
              if (
                typeof prop === 'string' &&
                !_reflectutils.wellKnownProperties.has(prop)
              ) {
                const expression = (0, _reflectutils.describeStringPropertyAccess)(
                  'searchParams',
                  prop
                );
                const error = createSearchAccessError(route, expression);
                (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(
                  route,
                  expression,
                  error,
                  prerenderStore
                );
              }
              return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
          }
        },
        has(target, prop) {
          // We don't expect key checking to be used except for testing the existence of
          // searchParams so we make all has tests trigger dynamic. this means that `promise.then`
          // can resolve to the then function on the Promise prototype but 'then' in promise will assume
          // you are testing whether the searchParams has a 'then' property.
          if (typeof prop === 'string') {
            const expression = (0, _reflectutils.describeHasCheckingStringProperty)(
              'searchParams',
              prop
            );
            const error = createSearchAccessError(route, expression);
            (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(
              route,
              expression,
              error,
              prerenderStore
            );
          }
          return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys() {
          const expression =
            '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
          const error = createSearchAccessError(route, expression);
          (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(
            route,
            expression,
            error,
            prerenderStore
          );
        },
      });
      CachedSearchParams.set(prerenderStore, proxiedPromise);
      return proxiedPromise;
    }
    function makeErroringExoticSearchParams(workStore, prerenderStore) {
      const cachedSearchParams = CachedSearchParams.get(workStore);
      if (cachedSearchParams) {
        return cachedSearchParams;
      }
      const underlyingSearchParams = {};
      // For search params we don't construct a ReactPromise because we want to interrupt
      // rendering on any property access that was not set from outside and so we only want
      // to have properties like value and status if React sets them.
      const promise = Promise.resolve(underlyingSearchParams);
      const proxiedPromise = new Proxy(promise, {
        get(target, prop, receiver) {
          if (Object.hasOwn(promise, prop)) {
            // The promise has this property directly. we must return it.
            // We know it isn't a dynamic access because it can only be something
            // that was previously written to the promise and thus not an underlying searchParam value
            return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
          switch (prop) {
            case 'then': {
              const expression = '`await searchParams`, `searchParams.then`, or similar';
              if (workStore.dynamicShouldError) {
                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                  workStore.route,
                  expression
                );
              } else if (prerenderStore.type === 'prerender-ppr') {
                // PPR Prerender (no dynamicIO)
                (0, _dynamicrendering.postponeWithTracking)(
                  workStore.route,
                  expression,
                  prerenderStore.dynamicTracking
                );
              } else {
                // Legacy Prerender
                (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                  expression,
                  workStore,
                  prerenderStore
                );
              }
              return;
            }
            case 'status': {
              const expression = '`use(searchParams)`, `searchParams.status`, or similar';
              if (workStore.dynamicShouldError) {
                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                  workStore.route,
                  expression
                );
              } else if (prerenderStore.type === 'prerender-ppr') {
                // PPR Prerender (no dynamicIO)
                (0, _dynamicrendering.postponeWithTracking)(
                  workStore.route,
                  expression,
                  prerenderStore.dynamicTracking
                );
              } else {
                // Legacy Prerender
                (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                  expression,
                  workStore,
                  prerenderStore
                );
              }
              return;
            }
            default: {
              if (
                typeof prop === 'string' &&
                !_reflectutils.wellKnownProperties.has(prop)
              ) {
                const expression = (0, _reflectutils.describeStringPropertyAccess)(
                  'searchParams',
                  prop
                );
                if (workStore.dynamicShouldError) {
                  (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                    workStore.route,
                    expression
                  );
                } else if (prerenderStore.type === 'prerender-ppr') {
                  // PPR Prerender (no dynamicIO)
                  (0, _dynamicrendering.postponeWithTracking)(
                    workStore.route,
                    expression,
                    prerenderStore.dynamicTracking
                  );
                } else {
                  // Legacy Prerender
                  (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                    expression,
                    workStore,
                    prerenderStore
                  );
                }
              }
              return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
          }
        },
        has(target, prop) {
          // We don't expect key checking to be used except for testing the existence of
          // searchParams so we make all has tests trigger dynamic. this means that `promise.then`
          // can resolve to the then function on the Promise prototype but 'then' in promise will assume
          // you are testing whether the searchParams has a 'then' property.
          if (typeof prop === 'string') {
            const expression = (0, _reflectutils.describeHasCheckingStringProperty)(
              'searchParams',
              prop
            );
            if (workStore.dynamicShouldError) {
              (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                workStore.route,
                expression
              );
            } else if (prerenderStore.type === 'prerender-ppr') {
              // PPR Prerender (no dynamicIO)
              (0, _dynamicrendering.postponeWithTracking)(
                workStore.route,
                expression,
                prerenderStore.dynamicTracking
              );
            } else {
              // Legacy Prerender
              (0, _dynamicrendering.throwToInterruptStaticGeneration)(
                expression,
                workStore,
                prerenderStore
              );
            }
            return false;
          }
          return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys() {
          const expression =
            '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
          if (workStore.dynamicShouldError) {
            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
              workStore.route,
              expression
            );
          } else if (prerenderStore.type === 'prerender-ppr') {
            // PPR Prerender (no dynamicIO)
            (0, _dynamicrendering.postponeWithTracking)(
              workStore.route,
              expression,
              prerenderStore.dynamicTracking
            );
          } else {
            // Legacy Prerender
            (0, _dynamicrendering.throwToInterruptStaticGeneration)(
              expression,
              workStore,
              prerenderStore
            );
          }
        },
      });
      CachedSearchParams.set(workStore, proxiedPromise);
      return proxiedPromise;
    }
    function makeErroringExoticSearchParamsForUseCache(workStore) {
      const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore);
      if (cachedSearchParams) {
        return cachedSearchParams;
      }
      const promise = Promise.resolve({});
      const proxiedPromise = new Proxy(promise, {
        get(target, prop, receiver) {
          if (Object.hasOwn(promise, prop)) {
            // The promise has this property directly. we must return it. We know it
            // isn't a dynamic access because it can only be something that was
            // previously written to the promise and thus not an underlying
            // searchParam value
            return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
          if (
            typeof prop === 'string' &&
            (prop === 'then' || !_reflectutils.wellKnownProperties.has(prop))
          ) {
            (0, _utils.throwForSearchParamsAccessInUseCache)(workStore);
          }
          return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        has(target, prop) {
          // We don't expect key checking to be used except for testing the existence of
          // searchParams so we make all has tests throw an error. this means that `promise.then`
          // can resolve to the then function on the Promise prototype but 'then' in promise will assume
          // you are testing whether the searchParams has a 'then' property.
          if (
            typeof prop === 'string' &&
            (prop === 'then' || !_reflectutils.wellKnownProperties.has(prop))
          ) {
            (0, _utils.throwForSearchParamsAccessInUseCache)(workStore);
          }
          return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys() {
          (0, _utils.throwForSearchParamsAccessInUseCache)(workStore);
        },
      });
      CachedSearchParamsForUseCache.set(workStore, proxiedPromise);
      return proxiedPromise;
    }
    function makeUntrackedExoticSearchParams(underlyingSearchParams, store) {
      const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
      if (cachedSearchParams) {
        return cachedSearchParams;
      }
      // We don't use makeResolvedReactPromise here because searchParams
      // supports copying with spread and we don't want to unnecessarily
      // instrument the promise with spreadable properties of ReactPromise.
      const promise = Promise.resolve(underlyingSearchParams);
      CachedSearchParams.set(underlyingSearchParams, promise);
      Object.keys(underlyingSearchParams).forEach((prop) => {
        if (!_reflectutils.wellKnownProperties.has(prop)) {
          Object.defineProperty(promise, prop, {
            get() {
              const workUnitStore =
                _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
              (0, _dynamicrendering.trackDynamicDataInDynamicRender)(
                store,
                workUnitStore
              );
              return underlyingSearchParams[prop];
            },
            set(value) {
              Object.defineProperty(promise, prop, {
                value,
                writable: true,
                enumerable: true,
              });
            },
            enumerable: true,
            configurable: true,
          });
        }
      });
      return promise;
    }
    function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(
      underlyingSearchParams,
      store
    ) {
      const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
      if (cachedSearchParams) {
        return cachedSearchParams;
      }
      const proxiedProperties = new Set();
      const unproxiedProperties = [];
      // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying
      // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender
      // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking
      // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger
      // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce
      // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.
      let promiseInitialized = false;
      const proxiedUnderlying = new Proxy(underlyingSearchParams, {
        get(target, prop, receiver) {
          if (typeof prop === 'string' && promiseInitialized) {
            if (store.dynamicShouldError) {
              const expression = (0, _reflectutils.describeStringPropertyAccess)(
                'searchParams',
                prop
              );
              (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                store.route,
                expression
              );
            }
            const workUnitStore =
              _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
            (0, _dynamicrendering.trackDynamicDataInDynamicRender)(store, workUnitStore);
          }
          return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        has(target, prop) {
          if (typeof prop === 'string') {
            if (store.dynamicShouldError) {
              const expression = (0, _reflectutils.describeHasCheckingStringProperty)(
                'searchParams',
                prop
              );
              (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
                store.route,
                expression
              );
            }
          }
          return Reflect.has(target, prop);
        },
        ownKeys(target) {
          if (store.dynamicShouldError) {
            const expression =
              '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
              store.route,
              expression
            );
          }
          return Reflect.ownKeys(target);
        },
      });
      // We don't use makeResolvedReactPromise here because searchParams
      // supports copying with spread and we don't want to unnecessarily
      // instrument the promise with spreadable properties of ReactPromise.
      const promise = new Promise((resolve) =>
        (0, _scheduler.scheduleImmediate)(() => resolve(underlyingSearchParams))
      );
      promise.then(() => {
        promiseInitialized = true;
      });
      Object.keys(underlyingSearchParams).forEach((prop) => {
        if (_reflectutils.wellKnownProperties.has(prop)) {
          // These properties cannot be shadowed because they need to be the
          // true underlying value for Promises to work correctly at runtime
          unproxiedProperties.push(prop);
        } else {
          proxiedProperties.add(prop);
          Object.defineProperty(promise, prop, {
            get() {
              return proxiedUnderlying[prop];
            },
            set(newValue) {
              Object.defineProperty(promise, prop, {
                value: newValue,
                writable: true,
                enumerable: true,
              });
            },
            enumerable: true,
            configurable: true,
          });
        }
      });
      const proxiedPromise = new Proxy(promise, {
        get(target, prop, receiver) {
          if (prop === 'then' && store.dynamicShouldError) {
            const expression = '`searchParams.then`';
            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(
              store.route,
              expression
            );
          }
          if (typeof prop === 'string') {
            if (
              !_reflectutils.wellKnownProperties.has(prop) &&
              (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)
            ) {
              const expression = (0, _reflectutils.describeStringPropertyAccess)(
                'searchParams',
                prop
              );
              syncIODev(store.route, expression);
            }
          }
          return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (typeof prop === 'string') {
            proxiedProperties.delete(prop);
          }
          return Reflect.set(target, prop, value, receiver);
        },
        has(target, prop) {
          if (typeof prop === 'string') {
            if (
              !_reflectutils.wellKnownProperties.has(prop) &&
              (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)
            ) {
              const expression = (0, _reflectutils.describeHasCheckingStringProperty)(
                'searchParams',
                prop
              );
              syncIODev(store.route, expression);
            }
          }
          return Reflect.has(target, prop);
        },
        ownKeys(target) {
          const expression = '`Object.keys(searchParams)` or similar';
          syncIODev(store.route, expression, unproxiedProperties);
          return Reflect.ownKeys(target);
        },
      });
      CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
      return proxiedPromise;
    }
    function syncIODev(route, expression, missingProperties) {
      // In all cases we warn normally
      if (missingProperties && missingProperties.length > 0) {
        warnForIncompleteEnumeration(route, expression, missingProperties);
      } else {
        warnForSyncAccess(route, expression);
      }
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (
        workUnitStore &&
        workUnitStore.type === 'request' &&
        workUnitStore.prerenderPhase === true
      ) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
      }
    }
    const warnForSyncAccess = (0,
    _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(
      createSearchAccessError
    );
    const warnForIncompleteEnumeration = (0,
    _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(
      createIncompleteEnumerationError
    );
    function createSearchAccessError(route, expression) {
      const prefix = route ? `Route "${route}" ` : 'This route ';
      return Object.defineProperty(
        new Error(
          `${prefix}used ${expression}. ` +
            `\`searchParams\` should be awaited before using its properties. ` +
            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E249',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function createIncompleteEnumerationError(route, expression, missingProperties) {
      const prefix = route ? `Route "${route}" ` : 'This route ';
      return Object.defineProperty(
        new Error(
          `${prefix}used ${expression}. ` +
            `\`searchParams\` should be awaited before using its properties. ` +
            `The following properties were not available through enumeration ` +
            `because they conflict with builtin or well-known property names: ` +
            `${describeListOfPropertyNames(missingProperties)}. ` +
            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E2',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function describeListOfPropertyNames(properties) {
      switch (properties.length) {
        case 0:
          throw Object.defineProperty(
            new _invarianterror.InvariantError(
              'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'
            ),
            '__NEXT_ERROR_CODE',
            {
              value: 'E531',
              enumerable: false,
              configurable: true,
            }
          );
        case 1:
          return `\`${properties[0]}\``;
        case 2:
          return `\`${properties[0]}\` and \`${properties[1]}\``;
        default: {
          let description = '';
          for (let i = 0; i < properties.length - 1; i++) {
            description += `\`${properties[i]}\`, `;
          }
          description += `, and \`${properties[properties.length - 1]}\``;
          return description;
        }
      }
    }

    //# sourceMappingURL=search-params.js.map
  },
  4191: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      isRequestAPICallableInsideAfter: function () {
        return isRequestAPICallableInsideAfter;
      },
      throwForSearchParamsAccessInUseCache: function () {
        return throwForSearchParamsAccessInUseCache;
      },
      throwWithStaticGenerationBailoutError: function () {
        return throwWithStaticGenerationBailoutError;
      },
      throwWithStaticGenerationBailoutErrorWithDynamicError: function () {
        return throwWithStaticGenerationBailoutErrorWithDynamicError;
      },
    });
    const _staticgenerationbailout = __webpack_require__(8489);
    const _aftertaskasyncstorageexternal = __webpack_require__(5673);
    function throwWithStaticGenerationBailoutError(route, expression) {
      throw Object.defineProperty(
        new _staticgenerationbailout.StaticGenBailoutError(
          `Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E576',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {
      throw Object.defineProperty(
        new _staticgenerationbailout.StaticGenBailoutError(
          `Route ${route} with \`dynamic = "error"\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E543',
          enumerable: false,
          configurable: true,
        }
      );
    }
    function throwForSearchParamsAccessInUseCache(workStore) {
      const error = Object.defineProperty(
        new Error(
          `Route ${workStore.route} used "searchParams" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "searchParams" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`
        ),
        '__NEXT_ERROR_CODE',
        {
          value: 'E634',
          enumerable: false,
          configurable: true,
        }
      );
      workStore.invalidUsageError ??= error;
      throw error;
    }
    function isRequestAPICallableInsideAfter() {
      const afterTaskStore =
        _aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore();
      return (
        (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action'
      );
    }

    //# sourceMappingURL=utils.js.map
  },
  7339: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'default', {
      enumerable: true,
      get: function () {
        return ResponseCache;
      },
    });
    0 && 0;
    const _batcher = __webpack_require__(8567);
    const _scheduler = __webpack_require__(4230);
    const _utils = __webpack_require__(8204);
    _export_star(__webpack_require__(5807), exports);
    function _export_star(from, to) {
      Object.keys(from).forEach(function (k) {
        if (k !== 'default' && !Object.prototype.hasOwnProperty.call(to, k)) {
          Object.defineProperty(to, k, {
            enumerable: true,
            get: function () {
              return from[k];
            },
          });
        }
      });
      return from;
    }
    class ResponseCache {
      constructor(minimalMode) {
        this.batcher = _batcher.Batcher.create({
          // Ensure on-demand revalidate doesn't block normal requests, it should be
          // safe to run an on-demand revalidate for the same key as a normal request.
          cacheKeyFn: ({ key, isOnDemandRevalidate }) =>
            `${key}-${isOnDemandRevalidate ? '1' : '0'}`,
          // We wait to do any async work until after we've added our promise to
          // `pendingResponses` to ensure that any any other calls will reuse the
          // same promise until we've fully finished our work.
          schedulerFn: _scheduler.scheduleOnNextTick,
        });
        // this is a hack to avoid Webpack knowing this is equal to this.minimalMode
        // because we replace this.minimalMode to true in production bundles.
        const minimalModeKey = 'minimalMode';
        this[minimalModeKey] = minimalMode;
      }
      async get(key, responseGenerator, context) {
        // If there is no key for the cache, we can't possibly look this up in the
        // cache so just return the result of the response generator.
        if (!key) {
          return responseGenerator({
            hasResolved: false,
            previousCacheEntry: null,
          });
        }
        const {
          incrementalCache,
          isOnDemandRevalidate = false,
          isFallback = false,
          isRoutePPREnabled = false,
        } = context;
        const response = await this.batcher.batch(
          {
            key,
            isOnDemandRevalidate,
          },
          async (cacheKey, resolve) => {
            var _this_previousCacheItem;
            // We keep the previous cache entry around to leverage when the
            // incremental cache is disabled in minimal mode.
            if (
              this.minimalMode &&
              ((_this_previousCacheItem = this.previousCacheItem) == null
                ? void 0
                : _this_previousCacheItem.key) === cacheKey &&
              this.previousCacheItem.expiresAt > Date.now()
            ) {
              return this.previousCacheItem.entry;
            }
            // Coerce the kindHint into a given kind for the incremental cache.
            const kind = (0, _utils.routeKindToIncrementalCacheKind)(context.routeKind);
            let resolved = false;
            let cachedResponse = null;
            try {
              cachedResponse = !this.minimalMode
                ? await incrementalCache.get(key, {
                    kind,
                    isRoutePPREnabled: context.isRoutePPREnabled,
                    isFallback,
                  })
                : null;
              if (cachedResponse && !isOnDemandRevalidate) {
                resolve(cachedResponse);
                resolved = true;
                if (!cachedResponse.isStale || context.isPrefetch) {
                  // The cached value is still valid, so we don't need
                  // to update it yet.
                  return null;
                }
              }
              const cacheEntry = await responseGenerator({
                hasResolved: resolved,
                previousCacheEntry: cachedResponse,
                isRevalidating: true,
              });
              // If the cache entry couldn't be generated, we don't want to cache
              // the result.
              if (!cacheEntry) {
                // Unset the previous cache item if it was set.
                if (this.minimalMode) this.previousCacheItem = undefined;
                return null;
              }
              const resolveValue = await (0, _utils.fromResponseCacheEntry)({
                ...cacheEntry,
                isMiss: !cachedResponse,
              });
              if (!resolveValue) {
                // Unset the previous cache item if it was set.
                if (this.minimalMode) this.previousCacheItem = undefined;
                return null;
              }
              // For on-demand revalidate wait to resolve until cache is set.
              // Otherwise resolve now.
              if (!isOnDemandRevalidate && !resolved) {
                resolve(resolveValue);
                resolved = true;
              }
              // We want to persist the result only if it has a cache control value
              // defined.
              if (resolveValue.cacheControl) {
                if (this.minimalMode) {
                  this.previousCacheItem = {
                    key: cacheKey,
                    entry: resolveValue,
                    expiresAt: Date.now() + 1000,
                  };
                } else {
                  await incrementalCache.set(key, resolveValue.value, {
                    cacheControl: resolveValue.cacheControl,
                    isRoutePPREnabled,
                    isFallback,
                  });
                }
              }
              return resolveValue;
            } catch (err) {
              // When a path is erroring we automatically re-set the existing cache
              // with new revalidate and expire times to prevent non-stop retrying.
              if (cachedResponse == null ? void 0 : cachedResponse.cacheControl) {
                const newRevalidate = Math.min(
                  Math.max(cachedResponse.cacheControl.revalidate || 3, 3),
                  30
                );
                const newExpire =
                  cachedResponse.cacheControl.expire === undefined
                    ? undefined
                    : Math.max(newRevalidate + 3, cachedResponse.cacheControl.expire);
                await incrementalCache.set(key, cachedResponse.value, {
                  cacheControl: {
                    revalidate: newRevalidate,
                    expire: newExpire,
                  },
                  isRoutePPREnabled,
                  isFallback,
                });
              }
              // While revalidating in the background we can't reject as we already
              // resolved the cache entry so log the error here.
              if (resolved) {
                console.error(err);
                return null;
              }
              // We haven't resolved yet, so let's throw to indicate an error.
              throw err;
            }
          }
        );
        return (0, _utils.toResponseCacheEntry)(response);
      }
    }

    //# sourceMappingURL=index.js.map
  },
  5807: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      CachedRouteKind: function () {
        return CachedRouteKind;
      },
      IncrementalCacheKind: function () {
        return IncrementalCacheKind;
      },
    });
    var CachedRouteKind = /*#__PURE__*/ (function (CachedRouteKind) {
      CachedRouteKind['APP_PAGE'] = 'APP_PAGE';
      CachedRouteKind['APP_ROUTE'] = 'APP_ROUTE';
      CachedRouteKind['PAGES'] = 'PAGES';
      CachedRouteKind['FETCH'] = 'FETCH';
      CachedRouteKind['REDIRECT'] = 'REDIRECT';
      CachedRouteKind['IMAGE'] = 'IMAGE';
      return CachedRouteKind;
    })({});
    var IncrementalCacheKind = /*#__PURE__*/ (function (IncrementalCacheKind) {
      IncrementalCacheKind['APP_PAGE'] = 'APP_PAGE';
      IncrementalCacheKind['APP_ROUTE'] = 'APP_ROUTE';
      IncrementalCacheKind['PAGES'] = 'PAGES';
      IncrementalCacheKind['FETCH'] = 'FETCH';
      IncrementalCacheKind['IMAGE'] = 'IMAGE';
      return IncrementalCacheKind;
    })({});

    //# sourceMappingURL=types.js.map
  },
  8204: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      fromResponseCacheEntry: function () {
        return fromResponseCacheEntry;
      },
      routeKindToIncrementalCacheKind: function () {
        return routeKindToIncrementalCacheKind;
      },
      toResponseCacheEntry: function () {
        return toResponseCacheEntry;
      },
    });
    const _types = __webpack_require__(5807);
    const _renderresult = /*#__PURE__*/ _interop_require_default(
      __webpack_require__(3620)
    );
    const _routekind = __webpack_require__(2312);
    function _interop_require_default(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }
    async function fromResponseCacheEntry(cacheEntry) {
      var _cacheEntry_value, _cacheEntry_value1;
      return {
        ...cacheEntry,
        value:
          ((_cacheEntry_value = cacheEntry.value) == null
            ? void 0
            : _cacheEntry_value.kind) === _types.CachedRouteKind.PAGES
            ? {
                kind: _types.CachedRouteKind.PAGES,
                html: await cacheEntry.value.html.toUnchunkedString(true),
                pageData: cacheEntry.value.pageData,
                headers: cacheEntry.value.headers,
                status: cacheEntry.value.status,
              }
            : ((_cacheEntry_value1 = cacheEntry.value) == null
                  ? void 0
                  : _cacheEntry_value1.kind) === _types.CachedRouteKind.APP_PAGE
              ? {
                  kind: _types.CachedRouteKind.APP_PAGE,
                  html: await cacheEntry.value.html.toUnchunkedString(true),
                  postponed: cacheEntry.value.postponed,
                  rscData: cacheEntry.value.rscData,
                  headers: cacheEntry.value.headers,
                  status: cacheEntry.value.status,
                  segmentData: cacheEntry.value.segmentData,
                }
              : cacheEntry.value,
      };
    }
    async function toResponseCacheEntry(response) {
      var _response_value, _response_value1;
      if (!response) return null;
      return {
        isMiss: response.isMiss,
        isStale: response.isStale,
        cacheControl: response.cacheControl,
        isFallback: response.isFallback,
        value:
          ((_response_value = response.value) == null ? void 0 : _response_value.kind) ===
          _types.CachedRouteKind.PAGES
            ? {
                kind: _types.CachedRouteKind.PAGES,
                html: _renderresult.default.fromStatic(response.value.html),
                pageData: response.value.pageData,
                headers: response.value.headers,
                status: response.value.status,
              }
            : ((_response_value1 = response.value) == null
                  ? void 0
                  : _response_value1.kind) === _types.CachedRouteKind.APP_PAGE
              ? {
                  kind: _types.CachedRouteKind.APP_PAGE,
                  html: _renderresult.default.fromStatic(response.value.html),
                  rscData: response.value.rscData,
                  headers: response.value.headers,
                  status: response.value.status,
                  postponed: response.value.postponed,
                  segmentData: response.value.segmentData,
                }
              : response.value,
      };
    }
    function routeKindToIncrementalCacheKind(routeKind) {
      switch (routeKind) {
        case _routekind.RouteKind.PAGES:
          return _types.IncrementalCacheKind.PAGES;
        case _routekind.RouteKind.APP_PAGE:
          return _types.IncrementalCacheKind.APP_PAGE;
        case _routekind.RouteKind.IMAGE:
          return _types.IncrementalCacheKind.IMAGE;
        case _routekind.RouteKind.APP_ROUTE:
          return _types.IncrementalCacheKind.APP_ROUTE;
        default:
          throw Object.defineProperty(
            new Error(`Unexpected route kind ${routeKind}`),
            '__NEXT_ERROR_CODE',
            {
              value: 'E64',
              enumerable: false,
              configurable: true,
            }
          );
      }
    }

    //# sourceMappingURL=utils.js.map
  },
  2312: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'RouteKind', {
      enumerable: true,
      get: function () {
        return RouteKind;
      },
    });
    var RouteKind = /*#__PURE__*/ (function (RouteKind) {
      /** `PAGES` represents all the React pages that are under `pages/`. */ RouteKind[
        'PAGES'
      ] = 'PAGES';
      /** `PAGES_API` represents all the API routes under `pages/api/`. */ RouteKind[
        'PAGES_API'
      ] = 'PAGES_API';
      /**
       * `APP_PAGE` represents all the React pages that are under `app/` with the filename
       * of `page.{j,t}s{,x}`.
       */ RouteKind['APP_PAGE'] = 'APP_PAGE';
      /**
       * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/`
       * with the filename of `route.{j,t}s{,x}`.
       */ RouteKind['APP_ROUTE'] = 'APP_ROUTE';
      /** `IMAGE` represents all the images that are generated by `next/image`. */ RouteKind[
        'IMAGE'
      ] = 'IMAGE';
      return RouteKind;
    })({});

    //# sourceMappingURL=route-kind.js.map
  },
  4095: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    if (false) {
    } else {
      if (false) {
      } else {
        if (true) {
          if (false) {
          } else {
            module.exports = __webpack_require__(6693);
          }
        } else {
        }
      }
    }

    //# sourceMappingURL=module.compiled.js.map
  },
  1405: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(4095) /* .vendored["react-rsc"].ReactDOM */.vendored[
        'react-rsc'
      ].ReactDOM;

    //# sourceMappingURL=react-dom.js.map
  },
  6493: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(4095) /* .vendored["react-rsc"].ReactJsxDevRuntime */.vendored[
        'react-rsc'
      ].ReactJsxDevRuntime;

    //# sourceMappingURL=react-jsx-dev-runtime.js.map
  },
  9133: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(4095) /* .vendored["react-rsc"].ReactJsxRuntime */.vendored[
        'react-rsc'
      ].ReactJsxRuntime;

    //# sourceMappingURL=react-jsx-runtime.js.map
  },
  7322: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(
        4095
      ) /* .vendored["react-rsc"].ReactServerDOMWebpackServerEdge */.vendored[
        'react-rsc'
      ].ReactServerDOMWebpackServerEdge;

    //# sourceMappingURL=react-server-dom-webpack-server-edge.js.map
  },
  4176: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(
        4095
      ) /* .vendored["react-rsc"].ReactServerDOMWebpackStaticEdge */.vendored[
        'react-rsc'
      ].ReactServerDOMWebpackStaticEdge;

    //# sourceMappingURL=react-server-dom-webpack-static-edge.js.map
  },
  8516: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';

    module.exports =
      __webpack_require__(4095) /* .vendored["react-rsc"].React */.vendored[
        'react-rsc'
      ].React;

    //# sourceMappingURL=react.js.map
  },
  6958: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ENCODED_TAGS', {
      enumerable: true,
      get: function () {
        return ENCODED_TAGS;
      },
    });
    const ENCODED_TAGS = {
      // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`
      OPENING: {
        // <html
        HTML: new Uint8Array([60, 104, 116, 109, 108]),
        // <body
        BODY: new Uint8Array([60, 98, 111, 100, 121]),
      },
      CLOSED: {
        // </head>
        HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),
        // </body>
        BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),
        // </html>
        HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),
        // </body></html>
        BODY_AND_HTML: new Uint8Array([
          60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,
        ]),
      },
    };

    //# sourceMappingURL=encodedTags.js.map
  },
  227: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      chainStreams: function () {
        return chainStreams;
      },
      continueDynamicHTMLResume: function () {
        return continueDynamicHTMLResume;
      },
      continueDynamicPrerender: function () {
        return continueDynamicPrerender;
      },
      continueFizzStream: function () {
        return continueFizzStream;
      },
      continueStaticPrerender: function () {
        return continueStaticPrerender;
      },
      createBufferedTransformStream: function () {
        return createBufferedTransformStream;
      },
      createDocumentClosingStream: function () {
        return createDocumentClosingStream;
      },
      createRootLayoutValidatorStream: function () {
        return createRootLayoutValidatorStream;
      },
      renderToInitialFizzStream: function () {
        return renderToInitialFizzStream;
      },
      streamFromBuffer: function () {
        return streamFromBuffer;
      },
      streamFromString: function () {
        return streamFromString;
      },
      streamToBuffer: function () {
        return streamToBuffer;
      },
      streamToString: function () {
        return streamToString;
      },
    });
    const _tracer = __webpack_require__(9223);
    const _constants = __webpack_require__(2917);
    const _detachedpromise = __webpack_require__(8308);
    const _scheduler = __webpack_require__(4230);
    const _encodedTags = __webpack_require__(6958);
    const _uint8arrayhelpers = __webpack_require__(9225);
    const _constants1 = __webpack_require__(2608);
    function voidCatch() {
      // this catcher is designed to be used with pipeTo where we expect the underlying
      // pipe implementation to forward errors but we don't want the pipeTo promise to reject
      // and be unhandled
    }
    // We can share the same encoder instance everywhere
    // Notably we cannot do the same for TextDecoder because it is stateful
    // when handling streaming data
    const encoder = new TextEncoder();
    function chainStreams(...streams) {
      // We could encode this invariant in the arguments but current uses of this function pass
      // use spread so it would be missed by
      if (streams.length === 0) {
        throw Object.defineProperty(
          new Error('Invariant: chainStreams requires at least one stream'),
          '__NEXT_ERROR_CODE',
          {
            value: 'E437',
            enumerable: false,
            configurable: true,
          }
        );
      }
      // If we only have 1 stream we fast path it by returning just this stream
      if (streams.length === 1) {
        return streams[0];
      }
      const { readable, writable } = new TransformStream();
      // We always initiate pipeTo immediately. We know we have at least 2 streams
      // so we need to avoid closing the writable when this one finishes.
      let promise = streams[0].pipeTo(writable, {
        preventClose: true,
      });
      let i = 1;
      for (; i < streams.length - 1; i++) {
        const nextStream = streams[i];
        promise = promise.then(() =>
          nextStream.pipeTo(writable, {
            preventClose: true,
          })
        );
      }
      // We can omit the length check because we halted before the last stream and there
      // is at least two streams so the lastStream here will always be defined
      const lastStream = streams[i];
      promise = promise.then(() => lastStream.pipeTo(writable));
      // Catch any errors from the streams and ignore them, they will be handled
      // by whatever is consuming the readable stream.
      promise.catch(voidCatch);
      return readable;
    }
    function streamFromString(str) {
      return new ReadableStream({
        start(controller) {
          controller.enqueue(encoder.encode(str));
          controller.close();
        },
      });
    }
    function streamFromBuffer(chunk) {
      return new ReadableStream({
        start(controller) {
          controller.enqueue(chunk);
          controller.close();
        },
      });
    }
    async function streamToBuffer(stream) {
      const reader = stream.getReader();
      const chunks = [];
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        chunks.push(value);
      }
      return Buffer.concat(chunks);
    }
    async function streamToString(stream, signal) {
      const decoder = new TextDecoder('utf-8', {
        fatal: true,
      });
      let string = '';
      for await (const chunk of stream) {
        if (signal == null ? void 0 : signal.aborted) {
          return string;
        }
        string += decoder.decode(chunk, {
          stream: true,
        });
      }
      string += decoder.decode();
      return string;
    }
    function createBufferedTransformStream() {
      let bufferedChunks = [];
      let bufferByteLength = 0;
      let pending;
      const flush = (controller) => {
        // If we already have a pending flush, then return early.
        if (pending) return;
        const detached = new _detachedpromise.DetachedPromise();
        pending = detached;
        (0, _scheduler.scheduleImmediate)(() => {
          try {
            const chunk = new Uint8Array(bufferByteLength);
            let copiedBytes = 0;
            for (let i = 0; i < bufferedChunks.length; i++) {
              const bufferedChunk = bufferedChunks[i];
              chunk.set(bufferedChunk, copiedBytes);
              copiedBytes += bufferedChunk.byteLength;
            }
            // We just wrote all the buffered chunks so we need to reset the bufferedChunks array
            // and our bufferByteLength to prepare for the next round of buffered chunks
            bufferedChunks.length = 0;
            bufferByteLength = 0;
            controller.enqueue(chunk);
          } catch {
            // If an error occurs while enqueuing it can't be due to this
            // transformers fault. It's likely due to the controller being
            // errored due to the stream being cancelled.
          } finally {
            pending = undefined;
            detached.resolve();
          }
        });
      };
      return new TransformStream({
        transform(chunk, controller) {
          // Combine the previous buffer with the new chunk.
          bufferedChunks.push(chunk);
          bufferByteLength += chunk.byteLength;
          // Flush the buffer to the controller.
          flush(controller);
        },
        flush() {
          if (!pending) return;
          return pending.promise;
        },
      });
    }
    function renderToInitialFizzStream({ ReactDOMServer, element, streamOptions }) {
      return (0, _tracer.getTracer)().trace(
        _constants.AppRenderSpan.renderToReadableStream,
        async () => ReactDOMServer.renderToReadableStream(element, streamOptions)
      );
    }
    function createHeadInsertionTransformStream(insert) {
      let inserted = false;
      // We need to track if this transform saw any bytes because if it didn't
      // we won't want to insert any server HTML at all
      let hasBytes = false;
      return new TransformStream({
        async transform(chunk, controller) {
          hasBytes = true;
          const insertion = await insert();
          if (inserted) {
            if (insertion) {
              const encodedInsertion = encoder.encode(insertion);
              controller.enqueue(encodedInsertion);
            }
            controller.enqueue(chunk);
          } else {
            // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.
            const index = (0, _uint8arrayhelpers.indexOfUint8Array)(
              chunk,
              _encodedTags.ENCODED_TAGS.CLOSED.HEAD
            );
            // In fully static rendering or non PPR rendering cases:
            // `/head>` will always be found in the chunk in first chunk rendering.
            if (index !== -1) {
              if (insertion) {
                const encodedInsertion = encoder.encode(insertion);
                // Get the total count of the bytes in the chunk and the insertion
                // e.g.
                // chunk = <head><meta charset="utf-8"></head>
                // insertion = <script>...</script>
                // output = <head><meta charset="utf-8"> [ <script>...</script> ] </head>
                const insertedHeadContent = new Uint8Array(
                  chunk.length + encodedInsertion.length
                );
                // Append the first part of the chunk, before the head tag
                insertedHeadContent.set(chunk.slice(0, index));
                // Append the server inserted content
                insertedHeadContent.set(encodedInsertion, index);
                // Append the rest of the chunk
                insertedHeadContent.set(
                  chunk.slice(index),
                  index + encodedInsertion.length
                );
                controller.enqueue(insertedHeadContent);
              } else {
                controller.enqueue(chunk);
              }
              inserted = true;
            } else {
              // This will happens in PPR rendering during next start, when the page is partially rendered.
              // When the page resumes, the head tag will be found in the middle of the chunk.
              // Where we just need to append the insertion and chunk to the current stream.
              // e.g.
              // PPR-static: <head>...</head><body> [ resume content ] </body>
              // PPR-resume: [ insertion ] [ rest content ]
              if (insertion) {
                controller.enqueue(encoder.encode(insertion));
              }
              controller.enqueue(chunk);
              inserted = true;
            }
          }
        },
        async flush(controller) {
          // Check before closing if there's anything remaining to insert.
          if (hasBytes) {
            const insertion = await insert();
            if (insertion) {
              controller.enqueue(encoder.encode(insertion));
            }
          }
        },
      });
    }
    // Suffix after main body content - scripts before </body>,
    // but wait for the major chunks to be enqueued.
    function createDeferredSuffixStream(suffix) {
      let flushed = false;
      let pending;
      const flush = (controller) => {
        const detached = new _detachedpromise.DetachedPromise();
        pending = detached;
        (0, _scheduler.scheduleImmediate)(() => {
          try {
            controller.enqueue(encoder.encode(suffix));
          } catch {
            // If an error occurs while enqueuing it can't be due to this
            // transformers fault. It's likely due to the controller being
            // errored due to the stream being cancelled.
          } finally {
            pending = undefined;
            detached.resolve();
          }
        });
      };
      return new TransformStream({
        transform(chunk, controller) {
          controller.enqueue(chunk);
          // If we've already flushed, we're done.
          if (flushed) return;
          // Schedule the flush to happen.
          flushed = true;
          flush(controller);
        },
        flush(controller) {
          if (pending) return pending.promise;
          if (flushed) return;
          // Flush now.
          controller.enqueue(encoder.encode(suffix));
        },
      });
    }
    // Merge two streams into one. Ensure the final transform stream is closed
    // when both are finished.
    function createMergedTransformStream(stream) {
      let pull = null;
      let donePulling = false;
      async function startPulling(controller) {
        if (pull) {
          return;
        }
        const reader = stream.getReader();
        // NOTE: streaming flush
        // We are buffering here for the inlined data stream because the
        // "shell" stream might be chunkenized again by the underlying stream
        // implementation, e.g. with a specific high-water mark. To ensure it's
        // the safe timing to pipe the data stream, this extra tick is
        // necessary.
        // We don't start reading until we've left the current Task to ensure
        // that it's inserted after flushing the shell. Note that this implementation
        // might get stale if impl details of Fizz change in the future.
        await (0, _scheduler.atLeastOneTask)();
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              donePulling = true;
              return;
            }
            controller.enqueue(value);
          }
        } catch (err) {
          controller.error(err);
        }
      }
      return new TransformStream({
        transform(chunk, controller) {
          controller.enqueue(chunk);
          // Start the streaming if it hasn't already been started yet.
          if (!pull) {
            pull = startPulling(controller);
          }
        },
        flush(controller) {
          if (donePulling) {
            return;
          }
          return pull || startPulling(controller);
        },
      });
    }
    const CLOSE_TAG = '</body></html>';
    /**
     * This transform stream moves the suffix to the end of the stream, so results like
     * `</body></html><script>...</script>` will be transformed to
     * `<script>...</script></body></html>`.
     */ function createMoveSuffixStream() {
      let foundSuffix = false;
      return new TransformStream({
        transform(chunk, controller) {
          if (foundSuffix) {
            return controller.enqueue(chunk);
          }
          const index = (0, _uint8arrayhelpers.indexOfUint8Array)(
            chunk,
            _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML
          );
          if (index > -1) {
            foundSuffix = true;
            // If the whole chunk is the suffix, then don't write anything, it will
            // be written in the flush.
            if (chunk.length === _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {
              return;
            }
            // Write out the part before the suffix.
            const before = chunk.slice(0, index);
            controller.enqueue(before);
            // In the case where the suffix is in the middle of the chunk, we need
            // to split the chunk into two parts.
            if (
              chunk.length >
              _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index
            ) {
              // Write out the part after the suffix.
              const after = chunk.slice(
                index + _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length
              );
              controller.enqueue(after);
            }
          } else {
            controller.enqueue(chunk);
          }
        },
        flush(controller) {
          // Even if we didn't find the suffix, the HTML is not valid if we don't
          // add it, so insert it at the end.
          controller.enqueue(_encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML);
        },
      });
    }
    function createStripDocumentClosingTagsTransform() {
      return new TransformStream({
        transform(chunk, controller) {
          // We rely on the assumption that chunks will never break across a code unit.
          // This is reasonable because we currently concat all of React's output from a single
          // flush into one chunk before streaming it forward which means the chunk will represent
          // a single coherent utf-8 string. This is not safe to use if we change our streaming to no
          // longer do this large buffered chunk
          if (
            (0, _uint8arrayhelpers.isEquivalentUint8Arrays)(
              chunk,
              _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML
            ) ||
            (0, _uint8arrayhelpers.isEquivalentUint8Arrays)(
              chunk,
              _encodedTags.ENCODED_TAGS.CLOSED.BODY
            ) ||
            (0, _uint8arrayhelpers.isEquivalentUint8Arrays)(
              chunk,
              _encodedTags.ENCODED_TAGS.CLOSED.HTML
            )
          ) {
            // the entire chunk is the closing tags; return without enqueueing anything.
            return;
          }
          // We assume these tags will go at together at the end of the document and that
          // they won't appear anywhere else in the document. This is not really a safe assumption
          // but until we revamp our streaming infra this is a performant way to string the tags
          chunk = (0, _uint8arrayhelpers.removeFromUint8Array)(
            chunk,
            _encodedTags.ENCODED_TAGS.CLOSED.BODY
          );
          chunk = (0, _uint8arrayhelpers.removeFromUint8Array)(
            chunk,
            _encodedTags.ENCODED_TAGS.CLOSED.HTML
          );
          controller.enqueue(chunk);
        },
      });
    }
    function createRootLayoutValidatorStream() {
      let foundHtml = false;
      let foundBody = false;
      return new TransformStream({
        async transform(chunk, controller) {
          // Peek into the streamed chunk to see if the tags are present.
          if (
            !foundHtml &&
            (0, _uint8arrayhelpers.indexOfUint8Array)(
              chunk,
              _encodedTags.ENCODED_TAGS.OPENING.HTML
            ) > -1
          ) {
            foundHtml = true;
          }
          if (
            !foundBody &&
            (0, _uint8arrayhelpers.indexOfUint8Array)(
              chunk,
              _encodedTags.ENCODED_TAGS.OPENING.BODY
            ) > -1
          ) {
            foundBody = true;
          }
          controller.enqueue(chunk);
        },
        flush(controller) {
          const missingTags = [];
          if (!foundHtml) missingTags.push('html');
          if (!foundBody) missingTags.push('body');
          if (!missingTags.length) return;
          controller.enqueue(
            encoder.encode(`<html id="__next_error__">
            <template
              data-next-error-message="Missing ${missingTags.map((c) => `<${c}>`).join(missingTags.length > 1 ? ' and ' : '')} tags in the root layout.\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags""
              data-next-error-digest="${_constants1.MISSING_ROOT_TAGS_ERROR}"
              data-next-error-stack=""
            ></template>
          `)
          );
        },
      });
    }
    function chainTransformers(readable, transformers) {
      let stream = readable;
      for (const transformer of transformers) {
        if (!transformer) continue;
        stream = stream.pipeThrough(transformer);
      }
      return stream;
    }
    async function continueFizzStream(
      renderStream,
      {
        suffix,
        inlinedDataStream,
        isStaticGeneration,
        getServerInsertedHTML,
        getServerInsertedMetadata,
        validateRootLayout,
      }
    ) {
      // Suffix itself might contain close tags at the end, so we need to split it.
      const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null;
      // If we're generating static HTML and there's an `allReady` promise on the
      // stream, we need to wait for it to resolve before continuing.
      if (isStaticGeneration && 'allReady' in renderStream) {
        await renderStream.allReady;
      }
      return chainTransformers(renderStream, [
        // Buffer everything to avoid flushing too frequently
        createBufferedTransformStream(),
        // Insert generated metadata
        createHeadInsertionTransformStream(getServerInsertedMetadata),
        // Insert suffix content
        suffixUnclosed != null && suffixUnclosed.length > 0
          ? createDeferredSuffixStream(suffixUnclosed)
          : null,
        // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
        inlinedDataStream ? createMergedTransformStream(inlinedDataStream) : null,
        // Validate the root layout for missing html or body tags
        validateRootLayout ? createRootLayoutValidatorStream() : null,
        // Close tags should always be deferred to the end
        createMoveSuffixStream(),
        // Special head insertions
        // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid
        // hydration errors. Remove this once it's ready to be handled by react itself.
        createHeadInsertionTransformStream(getServerInsertedHTML),
      ]);
    }
    async function continueDynamicPrerender(
      prerenderStream,
      { getServerInsertedHTML, getServerInsertedMetadata }
    ) {
      return prerenderStream // Buffer everything to avoid flushing too frequently
        .pipeThrough(createBufferedTransformStream())
        .pipeThrough(createStripDocumentClosingTagsTransform()) // Insert generated tags to head
        .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Insert generated metadata
        .pipeThrough(createHeadInsertionTransformStream(getServerInsertedMetadata));
    }
    async function continueStaticPrerender(
      prerenderStream,
      { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata }
    ) {
      return prerenderStream // Buffer everything to avoid flushing too frequently
        .pipeThrough(createBufferedTransformStream()) // Insert generated tags to head
        .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Insert generated metadata to head
        .pipeThrough(createHeadInsertionTransformStream(getServerInsertedMetadata)) // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
        .pipeThrough(createMergedTransformStream(inlinedDataStream)) // Close tags should always be deferred to the end
        .pipeThrough(createMoveSuffixStream());
    }
    async function continueDynamicHTMLResume(
      renderStream,
      { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata }
    ) {
      return renderStream // Buffer everything to avoid flushing too frequently
        .pipeThrough(createBufferedTransformStream()) // Insert generated tags to head
        .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Insert generated metadata to body
        .pipeThrough(createHeadInsertionTransformStream(getServerInsertedMetadata)) // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
        .pipeThrough(createMergedTransformStream(inlinedDataStream)) // Close tags should always be deferred to the end
        .pipeThrough(createMoveSuffixStream());
    }
    function createDocumentClosingStream() {
      return streamFromString(CLOSE_TAG);
    }

    //# sourceMappingURL=node-web-streams-helper.js.map
  },
  9225: function (__unused_webpack_module, exports) {
    'use strict';
    /** Find the starting index of Uint8Array `b` within Uint8Array `a`. */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      indexOfUint8Array: function () {
        return indexOfUint8Array;
      },
      isEquivalentUint8Arrays: function () {
        return isEquivalentUint8Arrays;
      },
      removeFromUint8Array: function () {
        return removeFromUint8Array;
      },
    });
    function indexOfUint8Array(a, b) {
      if (b.length === 0) return 0;
      if (a.length === 0 || b.length > a.length) return -1;
      // start iterating through `a`
      for (let i = 0; i <= a.length - b.length; i++) {
        let completeMatch = true;
        // from index `i`, iterate through `b` and check for mismatch
        for (let j = 0; j < b.length; j++) {
          // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.
          if (a[i + j] !== b[j]) {
            completeMatch = false;
            break;
          }
        }
        if (completeMatch) {
          return i;
        }
      }
      return -1;
    }
    function isEquivalentUint8Arrays(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
    function removeFromUint8Array(a, b) {
      const tagIndex = indexOfUint8Array(a, b);
      if (tagIndex === 0) return a.subarray(b.length);
      if (tagIndex > -1) {
        const removed = new Uint8Array(a.length - b.length);
        removed.set(a.slice(0, tagIndex));
        removed.set(a.slice(tagIndex + b.length), tagIndex);
        return removed;
      } else {
        return a;
      }
    }

    //# sourceMappingURL=uint8array-helpers.js.map
  },
  1863: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      PageSignatureError: function () {
        return PageSignatureError;
      },
      RemovedPageError: function () {
        return RemovedPageError;
      },
      RemovedUAError: function () {
        return RemovedUAError;
      },
    });
    class PageSignatureError extends Error {
      constructor({ page }) {
        super(`The middleware "${page}" accepts an async API directly with the form:
  
  export function middleware(request, event) {
    return NextResponse.redirect('/new-location')
  }
  
  Read more: https://nextjs.org/docs/messages/middleware-new-signature
  `);
      }
    }
    class RemovedPageError extends Error {
      constructor() {
        super(`The request.page has been deprecated in favour of \`URLPattern\`.
  Read more: https://nextjs.org/docs/messages/middleware-request-page
  `);
      }
    }
    class RemovedUAError extends Error {
      constructor() {
        super(`The request.ua has been removed in favour of \`userAgent\` function.
  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
  `);
      }
    }

    //# sourceMappingURL=error.js.map
  },
  8899: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'NextURL', {
      enumerable: true,
      get: function () {
        return NextURL;
      },
    });
    const _detectdomainlocale = __webpack_require__(3235);
    const _formatnextpathnameinfo = __webpack_require__(879);
    const _gethostname = __webpack_require__(5465);
    const _getnextpathnameinfo = __webpack_require__(8177);
    const REGEX_LOCALHOST_HOSTNAME =
      /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\[::1\]|localhost)/;
    function parseURL(url, base) {
      return new URL(
        String(url).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'),
        base && String(base).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost')
      );
    }
    const Internal = Symbol('NextURLInternal');
    class NextURL {
      constructor(input, baseOrOpts, opts) {
        let base;
        let options;
        if (
          (typeof baseOrOpts === 'object' && 'pathname' in baseOrOpts) ||
          typeof baseOrOpts === 'string'
        ) {
          base = baseOrOpts;
          options = opts || {};
        } else {
          options = opts || baseOrOpts || {};
        }
        this[Internal] = {
          url: parseURL(input, base ?? options.base),
          options: options,
          basePath: '',
        };
        this.analyze();
      }
      analyze() {
        var _this_Internal_options_nextConfig_i18n,
          _this_Internal_options_nextConfig,
          _this_Internal_domainLocale,
          _this_Internal_options_nextConfig_i18n1,
          _this_Internal_options_nextConfig1;
        const info = (0, _getnextpathnameinfo.getNextPathnameInfo)(
          this[Internal].url.pathname,
          {
            nextConfig: this[Internal].options.nextConfig,
            parseData: !undefined,
            i18nProvider: this[Internal].options.i18nProvider,
          }
        );
        const hostname = (0, _gethostname.getHostname)(
          this[Internal].url,
          this[Internal].options.headers
        );
        this[Internal].domainLocale = this[Internal].options.i18nProvider
          ? this[Internal].options.i18nProvider.detectDomainLocale(hostname)
          : (0, _detectdomainlocale.detectDomainLocale)(
              (_this_Internal_options_nextConfig = this[Internal].options.nextConfig) ==
                null
                ? void 0
                : (_this_Internal_options_nextConfig_i18n =
                      _this_Internal_options_nextConfig.i18n) == null
                  ? void 0
                  : _this_Internal_options_nextConfig_i18n.domains,
              hostname
            );
        const defaultLocale =
          ((_this_Internal_domainLocale = this[Internal].domainLocale) == null
            ? void 0
            : _this_Internal_domainLocale.defaultLocale) ||
          ((_this_Internal_options_nextConfig1 = this[Internal].options.nextConfig) ==
          null
            ? void 0
            : (_this_Internal_options_nextConfig_i18n1 =
                  _this_Internal_options_nextConfig1.i18n) == null
              ? void 0
              : _this_Internal_options_nextConfig_i18n1.defaultLocale);
        this[Internal].url.pathname = info.pathname;
        this[Internal].defaultLocale = defaultLocale;
        this[Internal].basePath = info.basePath ?? '';
        this[Internal].buildId = info.buildId;
        this[Internal].locale = info.locale ?? defaultLocale;
        this[Internal].trailingSlash = info.trailingSlash;
      }
      formatPathname() {
        return (0, _formatnextpathnameinfo.formatNextPathnameInfo)({
          basePath: this[Internal].basePath,
          buildId: this[Internal].buildId,
          defaultLocale: !this[Internal].options.forceLocale
            ? this[Internal].defaultLocale
            : undefined,
          locale: this[Internal].locale,
          pathname: this[Internal].url.pathname,
          trailingSlash: this[Internal].trailingSlash,
        });
      }
      formatSearch() {
        return this[Internal].url.search;
      }
      get buildId() {
        return this[Internal].buildId;
      }
      set buildId(buildId) {
        this[Internal].buildId = buildId;
      }
      get locale() {
        return this[Internal].locale ?? '';
      }
      set locale(locale) {
        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig;
        if (
          !this[Internal].locale ||
          !((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) ==
          null
            ? void 0
            : (_this_Internal_options_nextConfig_i18n =
                  _this_Internal_options_nextConfig.i18n) == null
              ? void 0
              : _this_Internal_options_nextConfig_i18n.locales.includes(locale))
        ) {
          throw Object.defineProperty(
            new TypeError(`The NextURL configuration includes no locale "${locale}"`),
            '__NEXT_ERROR_CODE',
            {
              value: 'E597',
              enumerable: false,
              configurable: true,
            }
          );
        }
        this[Internal].locale = locale;
      }
      get defaultLocale() {
        return this[Internal].defaultLocale;
      }
      get domainLocale() {
        return this[Internal].domainLocale;
      }
      get searchParams() {
        return this[Internal].url.searchParams;
      }
      get host() {
        return this[Internal].url.host;
      }
      set host(value) {
        this[Internal].url.host = value;
      }
      get hostname() {
        return this[Internal].url.hostname;
      }
      set hostname(value) {
        this[Internal].url.hostname = value;
      }
      get port() {
        return this[Internal].url.port;
      }
      set port(value) {
        this[Internal].url.port = value;
      }
      get protocol() {
        return this[Internal].url.protocol;
      }
      set protocol(value) {
        this[Internal].url.protocol = value;
      }
      get href() {
        const pathname = this.formatPathname();
        const search = this.formatSearch();
        return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`;
      }
      set href(url) {
        this[Internal].url = parseURL(url);
        this.analyze();
      }
      get origin() {
        return this[Internal].url.origin;
      }
      get pathname() {
        return this[Internal].url.pathname;
      }
      set pathname(value) {
        this[Internal].url.pathname = value;
      }
      get hash() {
        return this[Internal].url.hash;
      }
      set hash(value) {
        this[Internal].url.hash = value;
      }
      get search() {
        return this[Internal].url.search;
      }
      set search(value) {
        this[Internal].url.search = value;
      }
      get password() {
        return this[Internal].url.password;
      }
      set password(value) {
        this[Internal].url.password = value;
      }
      get username() {
        return this[Internal].url.username;
      }
      set username(value) {
        this[Internal].url.username = value;
      }
      get basePath() {
        return this[Internal].basePath;
      }
      set basePath(value) {
        this[Internal].basePath = value.startsWith('/') ? value : `/${value}`;
      }
      toString() {
        return this.href;
      }
      toJSON() {
        return this.href;
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          href: this.href,
          origin: this.origin,
          protocol: this.protocol,
          username: this.username,
          password: this.password,
          host: this.host,
          hostname: this.hostname,
          port: this.port,
          pathname: this.pathname,
          search: this.search,
          searchParams: this.searchParams,
          hash: this.hash,
        };
      }
      clone() {
        return new NextURL(String(this), this[Internal].options);
      }
    }

    //# sourceMappingURL=next-url.js.map
  },
  7125: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      NextRequestAdapter: function () {
        return NextRequestAdapter;
      },
      ResponseAborted: function () {
        return ResponseAborted;
      },
      ResponseAbortedName: function () {
        return ResponseAbortedName;
      },
      createAbortController: function () {
        return createAbortController;
      },
      signalFromNodeResponse: function () {
        return signalFromNodeResponse;
      },
    });
    const _requestmeta = __webpack_require__(7071);
    const _utils = __webpack_require__(6124);
    const _request = __webpack_require__(5554);
    const _helpers = __webpack_require__(5871);
    const ResponseAbortedName = 'ResponseAborted';
    class ResponseAborted extends Error {
      constructor(...args) {
        super(...args), (this.name = ResponseAbortedName);
      }
    }
    function createAbortController(response) {
      const controller = new AbortController();
      // If `finish` fires first, then `res.end()` has been called and the close is
      // just us finishing the stream on our side. If `close` fires first, then we
      // know the client disconnected before we finished.
      response.once('close', () => {
        if (response.writableFinished) return;
        controller.abort(new ResponseAborted());
      });
      return controller;
    }
    function signalFromNodeResponse(response) {
      const { errored, destroyed } = response;
      if (errored || destroyed) {
        return AbortSignal.abort(errored ?? new ResponseAborted());
      }
      const { signal } = createAbortController(response);
      return signal;
    }
    class NextRequestAdapter {
      static fromBaseNextRequest(request, signal) {
        if (
          // The type check here ensures that `req` is correctly typed, and the
          // environment variable check provides dead code elimination.
          false
        ) {
        } else if (
          // The type check here ensures that `req` is correctly typed, and the
          // environment variable check provides dead code elimination.
          true &&
          (0, _helpers.isNodeNextRequest)(request)
        ) {
          return NextRequestAdapter.fromNodeNextRequest(request, signal);
        } else {
          throw Object.defineProperty(
            new Error('Invariant: Unsupported NextRequest type'),
            '__NEXT_ERROR_CODE',
            {
              value: 'E345',
              enumerable: false,
              configurable: true,
            }
          );
        }
      }
      static fromNodeNextRequest(request, signal) {
        // HEAD and GET requests can not have a body.
        let body = null;
        if (request.method !== 'GET' && request.method !== 'HEAD' && request.body) {
          // @ts-expect-error - this is handled by undici, when streams/web land use it instead
          body = request.body;
        }
        let url;
        if (request.url.startsWith('http')) {
          url = new URL(request.url);
        } else {
          // Grab the full URL from the request metadata.
          const base = (0, _requestmeta.getRequestMeta)(request, 'initURL');
          if (!base || !base.startsWith('http')) {
            // Because the URL construction relies on the fact that the URL provided
            // is absolute, we need to provide a base URL. We can't use the request
            // URL because it's relative, so we use a dummy URL instead.
            url = new URL(request.url, 'http://n');
          } else {
            url = new URL(request.url, base);
          }
        }
        return new _request.NextRequest(url, {
          method: request.method,
          headers: (0, _utils.fromNodeOutgoingHttpHeaders)(request.headers),
          duplex: 'half',
          signal,
          // geo
          // ip
          // nextConfig
          // body can not be passed if request was aborted
          // or we get a Request body was disturbed error
          ...(signal.aborted
            ? {}
            : {
                body,
              }),
        });
      }
      static fromWebNextRequest(request) {
        // HEAD and GET requests can not have a body.
        let body = null;
        if (request.method !== 'GET' && request.method !== 'HEAD') {
          body = request.body;
        }
        return new _request.NextRequest(request.url, {
          method: request.method,
          headers: (0, _utils.fromNodeOutgoingHttpHeaders)(request.headers),
          duplex: 'half',
          signal: request.request.signal,
          // geo
          // ip
          // nextConfig
          // body can not be passed if request was aborted
          // or we get a Request body was disturbed error
          ...(request.request.signal.aborted
            ? {}
            : {
                body,
              }),
        });
      }
    }

    //# sourceMappingURL=next-request.js.map
  },
  7025: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ReflectAdapter', {
      enumerable: true,
      get: function () {
        return ReflectAdapter;
      },
    });
    class ReflectAdapter {
      static get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === 'function') {
          return value.bind(target);
        }
        return value;
      }
      static set(target, prop, value, receiver) {
        return Reflect.set(target, prop, value, receiver);
      }
      static has(target, prop) {
        return Reflect.has(target, prop);
      }
      static deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
      }
    }

    //# sourceMappingURL=reflect.js.map
  },
  234: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      RequestCookies: function () {
        return _cookies.RequestCookies;
      },
      ResponseCookies: function () {
        return _cookies.ResponseCookies;
      },
      stringifyCookie: function () {
        return _cookies.stringifyCookie;
      },
    });
    const _cookies = __webpack_require__(7558);

    //# sourceMappingURL=cookies.js.map
  },
  5554: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      INTERNALS: function () {
        return INTERNALS;
      },
      NextRequest: function () {
        return NextRequest;
      },
    });
    const _nexturl = __webpack_require__(8899);
    const _utils = __webpack_require__(6124);
    const _error = __webpack_require__(1863);
    const _cookies = __webpack_require__(234);
    const INTERNALS = Symbol('internal request');
    class NextRequest extends Request {
      constructor(input, init = {}) {
        const url =
          typeof input !== 'string' && 'url' in input ? input.url : String(input);
        (0, _utils.validateURL)(url);
        // node Request instance requires duplex option when a body
        // is present or it errors, we don't handle this for
        // Request being passed in since it would have already
        // errored if this wasn't configured
        if (true) {
          if (init.body && init.duplex !== 'half') {
            init.duplex = 'half';
          }
        }
        if (input instanceof Request) super(input, init);
        else super(url, init);
        const nextUrl = new _nexturl.NextURL(url, {
          headers: (0, _utils.toNodeOutgoingHttpHeaders)(this.headers),
          nextConfig: init.nextConfig,
        });
        this[INTERNALS] = {
          cookies: new _cookies.RequestCookies(this.headers),
          nextUrl,
          url: false ? 0 : nextUrl.toString(),
        };
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          cookies: this.cookies,
          nextUrl: this.nextUrl,
          url: this.url,
          // rest of props come from Request
          bodyUsed: this.bodyUsed,
          cache: this.cache,
          credentials: this.credentials,
          destination: this.destination,
          headers: Object.fromEntries(this.headers),
          integrity: this.integrity,
          keepalive: this.keepalive,
          method: this.method,
          mode: this.mode,
          redirect: this.redirect,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          signal: this.signal,
        };
      }
      get cookies() {
        return this[INTERNALS].cookies;
      }
      get nextUrl() {
        return this[INTERNALS].nextUrl;
      }
      /**
       * @deprecated `page` has been deprecated in favour of `URLPattern`. Read more:
       *   https://nextjs.org/docs/messages/middleware-request-page
       */ get page() {
        throw new _error.RemovedPageError();
      }
      /**
       * @deprecated `ua` has been removed in favour of `userAgent` function. Read more:
       *   https://nextjs.org/docs/messages/middleware-parse-user-agent
       */ get ua() {
        throw new _error.RemovedUAError();
      }
      get url() {
        return this[INTERNALS].url;
      }
    }

    //# sourceMappingURL=request.js.map
  },
  6124: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      fromNodeOutgoingHttpHeaders: function () {
        return fromNodeOutgoingHttpHeaders;
      },
      normalizeNextQueryParam: function () {
        return normalizeNextQueryParam;
      },
      splitCookiesString: function () {
        return splitCookiesString;
      },
      toNodeOutgoingHttpHeaders: function () {
        return toNodeOutgoingHttpHeaders;
      },
      validateURL: function () {
        return validateURL;
      },
    });
    const _constants = __webpack_require__(6914);
    function fromNodeOutgoingHttpHeaders(nodeHeaders) {
      const headers = new Headers();
      for (let [key, value] of Object.entries(nodeHeaders)) {
        const values = Array.isArray(value) ? value : [value];
        for (let v of values) {
          if (typeof v === 'undefined') continue;
          if (typeof v === 'number') {
            v = v.toString();
          }
          headers.append(key, v);
        }
      }
      return headers;
    }
    function splitCookiesString(cookiesString) {
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== '=' && ch !== ';' && ch !== ',';
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ',') {
            // ',' is a cookie separator if we have later first '=', not ';' or ','
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            // currently special character
            if (pos < cookiesString.length && cookiesString.charAt(pos) === '=') {
              // we found cookies separator
              cookiesSeparatorFound = true;
              // pos is inside the next cookie, so back up and return it.
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              // in param ',' or param separator ';',
              // we continue from that comma
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    function toNodeOutgoingHttpHeaders(headers) {
      const nodeHeaders = {};
      const cookies = [];
      if (headers) {
        for (const [key, value] of headers.entries()) {
          if (key.toLowerCase() === 'set-cookie') {
            // We may have gotten a comma joined string of cookies, or multiple
            // set-cookie headers. We need to merge them into one header array
            // to represent all the cookies.
            cookies.push(...splitCookiesString(value));
            nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies;
          } else {
            nodeHeaders[key] = value;
          }
        }
      }
      return nodeHeaders;
    }
    function validateURL(url) {
      try {
        return String(new URL(String(url)));
      } catch (error) {
        throw Object.defineProperty(
          new Error(
            `URL is malformed "${String(url)}". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`,
            {
              cause: error,
            }
          ),
          '__NEXT_ERROR_CODE',
          {
            value: 'E61',
            enumerable: false,
            configurable: true,
          }
        );
      }
    }
    function normalizeNextQueryParam(key) {
      const prefixes = [
        _constants.NEXT_QUERY_PARAM_PREFIX,
        _constants.NEXT_INTERCEPTION_MARKER_PREFIX,
      ];
      for (const prefix of prefixes) {
        if (key !== prefix && key.startsWith(prefix)) {
          return key.substring(prefix.length);
        }
      }
      return null;
    }

    //# sourceMappingURL=utils.js.map
  },
  9986: function (__unused_webpack_module, exports) {
    'use strict';
    var __webpack_unused_export__;

    __webpack_unused_export__ = {
      value: true,
    };
    Object.defineProperty(exports, 'deepFreeze', {
      enumerable: true,
      get: function () {
        return deepFreeze;
      },
    });
    function deepFreeze(obj) {
      // If the object is already frozen, there's no need to freeze it again.
      if (Object.isFrozen(obj)) return obj;
      // An array is an object, but we also want to freeze each element in the array
      // as well.
      if (Array.isArray(obj)) {
        for (const item of obj) {
          if (!item || typeof item !== 'object') continue;
          deepFreeze(item);
        }
        return Object.freeze(obj);
      }
      for (const value of Object.values(obj)) {
        if (!value || typeof value !== 'object') continue;
        deepFreeze(value);
      }
      return Object.freeze(obj);
    } //# sourceMappingURL=deep-freeze.js.map
  },
  2608: function (module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'MISSING_ROOT_TAGS_ERROR', {
      enumerable: true,
      get: function () {
        return MISSING_ROOT_TAGS_ERROR;
      },
    });
    const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS';
    if (
      (typeof exports['default'] === 'function' ||
        (typeof exports['default'] === 'object' && exports['default'] !== null)) &&
      typeof exports['default'].__esModule === 'undefined'
    ) {
      Object.defineProperty(exports['default'], '__esModule', {
        value: true,
      });
      Object.assign(exports['default'], exports);
      module.exports = exports['default'];
    } //# sourceMappingURL=constants.js.map
  },
  5465: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'getHostname', {
      enumerable: true,
      get: function () {
        return getHostname;
      },
    });
    function getHostname(parsed, headers) {
      // Get the hostname from the headers if it exists, otherwise use the parsed
      // hostname.
      let hostname;
      if ((headers == null ? void 0 : headers.host) && !Array.isArray(headers.host)) {
        hostname = headers.host.toString().split(':', 1)[0];
      } else if (parsed.hostname) {
        hostname = parsed.hostname;
      } else return;
      return hostname.toLowerCase();
    } //# sourceMappingURL=get-hostname.js.map
  },
  3235: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'detectDomainLocale', {
      enumerable: true,
      get: function () {
        return detectDomainLocale;
      },
    });
    function detectDomainLocale(domainItems, hostname, detectedLocale) {
      if (!domainItems) return;
      if (detectedLocale) {
        detectedLocale = detectedLocale.toLowerCase();
      }
      for (const item of domainItems) {
        var _item_domain, _item_locales;
        // remove port if present
        const domainHostname =
          (_item_domain = item.domain) == null
            ? void 0
            : _item_domain.split(':', 1)[0].toLowerCase();
        if (
          hostname === domainHostname ||
          detectedLocale === item.defaultLocale.toLowerCase() ||
          ((_item_locales = item.locales) == null
            ? void 0
            : _item_locales.some((locale) => locale.toLowerCase() === detectedLocale))
        ) {
          return item;
        }
      }
    } //# sourceMappingURL=detect-domain-locale.js.map
  },
  237: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'normalizeLocalePath', {
      enumerable: true,
      get: function () {
        return normalizeLocalePath;
      },
    });
    /**
     * A cache of lowercased locales for each list of locales. This is stored as a WeakMap so
     * if the locales are garbage collected, the cache entry will be removed as well.
     */ const cache = new WeakMap();
    function normalizeLocalePath(pathname, locales) {
      // If locales is undefined, return the pathname as is.
      if (!locales)
        return {
          pathname,
        };
      // Get the cached lowercased locales or create a new cache entry.
      let lowercasedLocales = cache.get(locales);
      if (!lowercasedLocales) {
        lowercasedLocales = locales.map((locale) => locale.toLowerCase());
        cache.set(locales, lowercasedLocales);
      }
      let detectedLocale;
      // The first segment will be empty, because it has a leading `/`. If
      // there is no further segment, there is no locale (or it's the default).
      const segments = pathname.split('/', 2);
      // If there's no second segment (ie, the pathname is just `/`), there's no
      // locale.
      if (!segments[1])
        return {
          pathname,
        };
      // The second segment will contain the locale part if any.
      const segment = segments[1].toLowerCase();
      // See if the segment matches one of the locales. If it doesn't, there is
      // no locale (or it's the default).
      const index = lowercasedLocales.indexOf(segment);
      if (index < 0)
        return {
          pathname,
        };
      // Return the case-sensitive locale.
      detectedLocale = locales[index];
      // Remove the `/${locale}` part of the pathname.
      pathname = pathname.slice(detectedLocale.length + 1) || '/';
      return {
        pathname,
        detectedLocale,
      };
    } //# sourceMappingURL=normalize-locale-path.js.map
  },
  9288: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'InvariantError', {
      enumerable: true,
      get: function () {
        return InvariantError;
      },
    });
    class InvariantError extends Error {
      constructor(message, options) {
        super(
          'Invariant: ' +
            (message.endsWith('.') ? message : message + '.') +
            ' This is a bug in Next.js.',
          options
        );
        this.name = 'InvariantError';
      }
    } //# sourceMappingURL=invariant-error.js.map
  },
  6794: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      getObjectClassLabel: function () {
        return getObjectClassLabel;
      },
      isPlainObject: function () {
        return isPlainObject;
      },
    });
    function getObjectClassLabel(value) {
      return Object.prototype.toString.call(value);
    }
    function isPlainObject(value) {
      if (getObjectClassLabel(value) !== '[object Object]') {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      /**
       * This used to be previously:
       *
       * `return prototype === null || prototype === Object.prototype`
       *
       * But Edge Runtime expose Object from vm, being that kind of type-checking wrongly
       * fail.
       *
       * It was changed to the current implementation since it's resilient to serialization.
       */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');
    } //# sourceMappingURL=is-plain-object.js.map
  },
  7268: function (__unused_webpack_module, exports) {
    'use strict';
    /**
     * Check to see if a value is Thenable.
     *
     * @param promise The maybe-thenable value
     * @returns True if the value is thenable
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'isThenable', {
      enumerable: true,
      get: function () {
        return isThenable;
      },
    });
    function isThenable(promise) {
      return (
        promise !== null &&
        typeof promise === 'object' &&
        'then' in promise &&
        typeof promise.then === 'function'
      );
    } //# sourceMappingURL=is-thenable.js.map
  },
  2203: function (module, __unused_webpack_exports, __webpack_require__) {
    'use strict';
    /**
     * This module is for next.js server internal usage of path module. It will use native
     * path module for nodejs runtime. It will use path-browserify polyfill for edge runtime.
     */
    let path;
    if (false) {
    } else {
      path = __webpack_require__(5315);
    }
    module.exports = path; //# sourceMappingURL=path.js.map
  },
  7940: function (__unused_webpack_module, exports) {
    'use strict';
    // This has to be a shared module which is shared between client component error boundary and dynamic component

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      BailoutToCSRError: function () {
        return BailoutToCSRError;
      },
      isBailoutToCSRError: function () {
        return isBailoutToCSRError;
      },
    });
    const BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
    class BailoutToCSRError extends Error {
      constructor(reason) {
        super('Bail out to client-side rendering: ' + reason),
          (this.reason = reason),
          (this.digest = BAILOUT_TO_CSR);
      }
    }
    function isBailoutToCSRError(err) {
      if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
      }
      return err.digest === BAILOUT_TO_CSR;
    } //# sourceMappingURL=bailout-to-csr.js.map
  },
  3295: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'addLocale', {
      enumerable: true,
      get: function () {
        return addLocale;
      },
    });
    const _addpathprefix = __webpack_require__(8866);
    const _pathhasprefix = __webpack_require__(3914);
    function addLocale(path, locale, defaultLocale, ignorePrefix) {
      // If no locale was given or the locale is the default locale, we don't need
      // to prefix the path.
      if (!locale || locale === defaultLocale) return path;
      const lower = path.toLowerCase();
      // If the path is an API path or the path already has the locale prefix, we
      // don't need to prefix the path.
      if (!ignorePrefix) {
        if ((0, _pathhasprefix.pathHasPrefix)(lower, '/api')) return path;
        if ((0, _pathhasprefix.pathHasPrefix)(lower, '/' + locale.toLowerCase()))
          return path;
      }
      // Add the locale prefix to the path.
      return (0, _addpathprefix.addPathPrefix)(path, '/' + locale);
    } //# sourceMappingURL=add-locale.js.map
  },
  8866: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'addPathPrefix', {
      enumerable: true,
      get: function () {
        return addPathPrefix;
      },
    });
    const _parsepath = __webpack_require__(7350);
    function addPathPrefix(path, prefix) {
      if (!path.startsWith('/') || !prefix) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
      return '' + prefix + pathname + query + hash;
    } //# sourceMappingURL=add-path-prefix.js.map
  },
  9254: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'addPathSuffix', {
      enumerable: true,
      get: function () {
        return addPathSuffix;
      },
    });
    const _parsepath = __webpack_require__(7350);
    function addPathSuffix(path, suffix) {
      if (!path.startsWith('/') || !suffix) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
      return '' + pathname + suffix + query + hash;
    } //# sourceMappingURL=add-path-suffix.js.map
  },
  879: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'formatNextPathnameInfo', {
      enumerable: true,
      get: function () {
        return formatNextPathnameInfo;
      },
    });
    const _removetrailingslash = __webpack_require__(8005);
    const _addpathprefix = __webpack_require__(8866);
    const _addpathsuffix = __webpack_require__(9254);
    const _addlocale = __webpack_require__(3295);
    function formatNextPathnameInfo(info) {
      let pathname = (0, _addlocale.addLocale)(
        info.pathname,
        info.locale,
        info.buildId ? undefined : info.defaultLocale,
        info.ignorePrefix
      );
      if (info.buildId || !info.trailingSlash) {
        pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);
      }
      if (info.buildId) {
        pathname = (0, _addpathsuffix.addPathSuffix)(
          (0, _addpathprefix.addPathPrefix)(pathname, '/_next/data/' + info.buildId),
          info.pathname === '/' ? 'index.json' : '.json'
        );
      }
      pathname = (0, _addpathprefix.addPathPrefix)(pathname, info.basePath);
      return !info.buildId && info.trailingSlash
        ? !pathname.endsWith('/')
          ? (0, _addpathsuffix.addPathSuffix)(pathname, '/')
          : pathname
        : (0, _removetrailingslash.removeTrailingSlash)(pathname);
    } //# sourceMappingURL=format-next-pathname-info.js.map
  },
  8177: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'getNextPathnameInfo', {
      enumerable: true,
      get: function () {
        return getNextPathnameInfo;
      },
    });
    const _normalizelocalepath = __webpack_require__(237);
    const _removepathprefix = __webpack_require__(2363);
    const _pathhasprefix = __webpack_require__(3914);
    function getNextPathnameInfo(pathname, options) {
      var _options_nextConfig;
      const { basePath, i18n, trailingSlash } =
        (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};
      const info = {
        pathname,
        trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash,
      };
      if (basePath && (0, _pathhasprefix.pathHasPrefix)(info.pathname, basePath)) {
        info.pathname = (0, _removepathprefix.removePathPrefix)(info.pathname, basePath);
        info.basePath = basePath;
      }
      let pathnameNoDataPrefix = info.pathname;
      if (info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {
        const paths = info.pathname
          .replace(/^\/_next\/data\//, '')
          .replace(/\.json$/, '')
          .split('/');
        const buildId = paths[0];
        info.buildId = buildId;
        pathnameNoDataPrefix =
          paths[1] !== 'index' ? '/' + paths.slice(1).join('/') : '/';
        // update pathname with normalized if enabled although
        // we use normalized to populate locale info still
        if (options.parseData === true) {
          info.pathname = pathnameNoDataPrefix;
        }
      }
      // If provided, use the locale route normalizer to detect the locale instead
      // of the function below.
      if (i18n) {
        let result = options.i18nProvider
          ? options.i18nProvider.analyze(info.pathname)
          : (0, _normalizelocalepath.normalizeLocalePath)(info.pathname, i18n.locales);
        info.locale = result.detectedLocale;
        var _result_pathname;
        info.pathname =
          (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;
        if (!result.detectedLocale && info.buildId) {
          result = options.i18nProvider
            ? options.i18nProvider.analyze(pathnameNoDataPrefix)
            : (0, _normalizelocalepath.normalizeLocalePath)(
                pathnameNoDataPrefix,
                i18n.locales
              );
          if (result.detectedLocale) {
            info.locale = result.detectedLocale;
          }
        }
      }
      return info;
    } //# sourceMappingURL=get-next-pathname-info.js.map
  },
  7350: function (__unused_webpack_module, exports) {
    'use strict';
    /**
     * Given a path this function will find the pathname, query and hash and return them. This
     * is useful to parse full paths on the client side.
     *
     * @param path A path to parse e.g. /foo/bar?id=1#hash
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'parsePath', {
      enumerable: true,
      get: function () {
        return parsePath;
      },
    });
    function parsePath(path) {
      const hashIndex = path.indexOf('#');
      const queryIndex = path.indexOf('?');
      const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
      if (hasQuery || hashIndex > -1) {
        return {
          pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
          query: hasQuery
            ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined)
            : '',
          hash: hashIndex > -1 ? path.slice(hashIndex) : '',
        };
      }
      return {
        pathname: path,
        query: '',
        hash: '',
      };
    } //# sourceMappingURL=parse-path.js.map
  },
  3914: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'pathHasPrefix', {
      enumerable: true,
      get: function () {
        return pathHasPrefix;
      },
    });
    const _parsepath = __webpack_require__(7350);
    function pathHasPrefix(path, prefix) {
      if (typeof path !== 'string') {
        return false;
      }
      const { pathname } = (0, _parsepath.parsePath)(path);
      return pathname === prefix || pathname.startsWith(prefix + '/');
    } //# sourceMappingURL=path-has-prefix.js.map
  },
  2363: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'removePathPrefix', {
      enumerable: true,
      get: function () {
        return removePathPrefix;
      },
    });
    const _pathhasprefix = __webpack_require__(3914);
    function removePathPrefix(path, prefix) {
      // If the path doesn't start with the prefix we can return it as is. This
      // protects us from situations where the prefix is a substring of the path
      // prefix such as:
      //
      // For prefix: /blog
      //
      //   /blog -> true
      //   /blog/ -> true
      //   /blog/1 -> true
      //   /blogging -> false
      //   /blogging/ -> false
      //   /blogging/1 -> false
      if (!(0, _pathhasprefix.pathHasPrefix)(path, prefix)) {
        return path;
      }
      // Remove the prefix from the path via slicing.
      const withoutPrefix = path.slice(prefix.length);
      // If the path without the prefix starts with a `/` we can return it as is.
      if (withoutPrefix.startsWith('/')) {
        return withoutPrefix;
      }
      // If the path without the prefix doesn't start with a `/` we need to add it
      // back to the path to make sure it's a valid path.
      return '/' + withoutPrefix;
    } //# sourceMappingURL=remove-path-prefix.js.map
  },
  8005: function (__unused_webpack_module, exports) {
    'use strict';
    /**
     * Removes the trailing slash for a given route or page path. Preserves the root page.
     * Examples:
     *
     * - `/foo/bar/` -> `/foo/bar`
     * - `/foo/bar` -> `/foo/bar`
     * - `/` -> `/`
     */
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'removeTrailingSlash', {
      enumerable: true,
      get: function () {
        return removeTrailingSlash;
      },
    });
    function removeTrailingSlash(route) {
      return route.replace(/\/$/, '') || '/';
    } //# sourceMappingURL=remove-trailing-slash.js.map
  },
  9021: function (__unused_webpack_module, exports, __webpack_require__) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      ROOT_SEGMENT_KEY: function () {
        return ROOT_SEGMENT_KEY;
      },
      convertSegmentPathToStaticExportFilename: function () {
        return convertSegmentPathToStaticExportFilename;
      },
      encodeChildSegmentKey: function () {
        return encodeChildSegmentKey;
      },
      encodeSegment: function () {
        return encodeSegment;
      },
    });
    const _segment = __webpack_require__(7099);
    function encodeSegment(segment) {
      if (typeof segment === 'string') {
        if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {
          // The Flight Router State type sometimes includes the search params in
          // the page segment. However, the Segment Cache tracks this as a separate
          // key. So, we strip the search params here, and then add them back when
          // the cache entry is turned back into a FlightRouterState. This is an
          // unfortunate consequence of the FlightRouteState being used both as a
          // transport type and as a cache key; we'll address this once more of the
          // Segment Cache implementation has settled.
          // TODO: We should hoist the search params out of the FlightRouterState
          // type entirely, This is our plan for dynamic route params, too.
          return _segment.PAGE_SEGMENT_KEY;
        }
        const safeName = // But params typically don't include the leading slash. We should use
          // a different encoding to avoid this special case.
          segment === '/_not-found'
            ? '_not-found'
            : encodeToFilesystemAndURLSafeString(segment);
        // Since this is not a dynamic segment, it's fully encoded. It does not
        // need to be "hydrated" with a param value.
        return safeName;
      }
      const name = segment[0];
      const paramValue = segment[1];
      const paramType = segment[2];
      const safeName = encodeToFilesystemAndURLSafeString(name);
      const safeValue = encodeToFilesystemAndURLSafeString(paramValue);
      const encodedName = '$' + paramType + '$' + safeName + '$' + safeValue;
      return encodedName;
    }
    const ROOT_SEGMENT_KEY = '';
    function encodeChildSegmentKey(parentSegmentKey, parallelRouteKey, segment) {
      // Aside from being filesystem safe, segment keys are also designed so that
      // each segment and parallel route creates its own subdirectory. Roughly in
      // the same shape as the source app directory. This is mostly just for easier
      // debugging (you can open up the build folder and navigate the output); if
      // we wanted to do we could just use a flat structure.
      // Omit the parallel route key for children, since this is the most
      // common case. Saves some bytes (and it's what the app directory does).
      const slotKey =
        parallelRouteKey === 'children'
          ? segment
          : '@' + encodeToFilesystemAndURLSafeString(parallelRouteKey) + '/' + segment;
      return parentSegmentKey + '/' + slotKey;
    }
    // Define a regex pattern to match the most common characters found in a route
    // param. It excludes anything that might not be cross-platform filesystem
    // compatible, like |. It does not need to be precise because the fallback is to
    // just base64url-encode the whole parameter, which is fine; we just don't do it
    // by default for compactness, and for easier debugging.
    const simpleParamValueRegex = /^[a-zA-Z0-9\-_@]+$/;
    function encodeToFilesystemAndURLSafeString(value) {
      if (simpleParamValueRegex.test(value)) {
        return value;
      }
      // If there are any unsafe characters, base64url-encode the entire value.
      // We also add a ! prefix so it doesn't collide with the simple case.
      const base64url = btoa(value)
        .replace(/\+/g, '-') // Replace '+' with '-'
        .replace(/\//g, '_') // Replace '/' with '_'
        .replace(/=+$/, ''); // Remove trailing '='
      return '!' + base64url;
    }
    function convertSegmentPathToStaticExportFilename(segmentPath) {
      return '__next' + segmentPath.replace(/\//g, '.') + '.txt';
    } //# sourceMappingURL=segment-value-encoding.js.map
  },
  7099: function (__unused_webpack_module, exports) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DEFAULT_SEGMENT_KEY: function () {
        return DEFAULT_SEGMENT_KEY;
      },
      PAGE_SEGMENT_KEY: function () {
        return PAGE_SEGMENT_KEY;
      },
      addSearchParamsIfPageSegment: function () {
        return addSearchParamsIfPageSegment;
      },
      isGroupSegment: function () {
        return isGroupSegment;
      },
      isParallelRouteSegment: function () {
        return isParallelRouteSegment;
      },
    });
    function isGroupSegment(segment) {
      // Use array[0] for performant purpose
      return segment[0] === '(' && segment.endsWith(')');
    }
    function isParallelRouteSegment(segment) {
      return segment.startsWith('@') && segment !== '@children';
    }
    function addSearchParamsIfPageSegment(segment, searchParams) {
      const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);
      if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== '{}'
          ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery
          : PAGE_SEGMENT_KEY;
      }
      return segment;
    }
    const PAGE_SEGMENT_KEY = '__PAGE__';
    const DEFAULT_SEGMENT_KEY = '__DEFAULT__'; //# sourceMappingURL=segment.js.map
  },
  1898: function (__unused_webpack_module, exports) {
    'use strict';
    // This regex will have fast negatives meaning valid identifiers may not pass
    // this test. However this is only used during static generation to provide hints
    // about why a page bailed out of some or all prerendering and we can use bracket notation
    // for example while `ಠ_ಠ` is a valid identifier it's ok to print `searchParams['ಠ_ಠ']`
    // even if this would have been fine too `searchParams.ಠ_ಠ`

    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    0 && 0;
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      describeHasCheckingStringProperty: function () {
        return describeHasCheckingStringProperty;
      },
      describeStringPropertyAccess: function () {
        return describeStringPropertyAccess;
      },
      wellKnownProperties: function () {
        return wellKnownProperties;
      },
    });
    const isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
    function describeStringPropertyAccess(target, prop) {
      if (isDefinitelyAValidIdentifier.test(prop)) {
        return '`' + target + '.' + prop + '`';
      }
      return '`' + target + '[' + JSON.stringify(prop) + ']`';
    }
    function describeHasCheckingStringProperty(target, prop) {
      const stringifiedProp = JSON.stringify(prop);
      return (
        '`Reflect.has(' +
        target +
        ', ' +
        stringifiedProp +
        ')`, `' +
        stringifiedProp +
        ' in ' +
        target +
        '`, or similar'
      );
    }
    const wellKnownProperties = new Set([
      'hasOwnProperty',
      'isPrototypeOf',
      'propertyIsEnumerable',
      'toString',
      'valueOf',
      'toLocaleString',
      // Promise prototype
      // fallthrough
      'then',
      'catch',
      'finally',
      // React Promise extension
      // fallthrough
      'status',
      // React introspection
      'displayName',
      // Common tested properties
      // fallthrough
      'toJSON',
      '$$typeof',
      '__esModule',
    ]); //# sourceMappingURL=reflect-utils.js.map
  },
  3728: function (
    __unused_webpack___webpack_module__,
    __webpack_exports__,
    __webpack_require__
  ) {
    'use strict';
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      _: () => _class_private_field_loose_base,
    });
    function _class_private_field_loose_base(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError('attempted to use private field on non-instance');
      }

      return receiver;
    }
  },
  3234: function (
    __unused_webpack___webpack_module__,
    __webpack_exports__,
    __webpack_require__
  ) {
    'use strict';
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      _: () => _class_private_field_loose_key,
    });
    var id = 0;

    function _class_private_field_loose_key(name) {
      return '__private_' + id++ + '_' + name;
    }
  },
  3899: function (
    __unused_webpack___webpack_module__,
    __webpack_exports__,
    __webpack_require__
  ) {
    'use strict';
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      _: () => _interop_require_default,
    });
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  },
  315: function (
    __unused_webpack___webpack_module__,
    __webpack_exports__,
    __webpack_require__
  ) {
    'use strict';
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      _: () => _interop_require_wildcard,
    });
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== 'function') return null;

      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();

      return (_getRequireWildcardCache = function (nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) return obj;
      if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function'))
        return { default: obj };

      var cache = _getRequireWildcardCache(nodeInterop);

      if (cache && cache.has(obj)) return cache.get(obj);

      var newObj = { __proto__: null };
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;
          if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
          else newObj[key] = obj[key];
        }
      }

      newObj.default = obj;

      if (cache) cache.set(obj, newObj);

      return newObj;
    }
  },
  1637: function (
    __unused_webpack___webpack_module__,
    __webpack_exports__,
    __webpack_require__
  ) {
    'use strict';
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      _: () => _tagged_template_literal_loose,
    });
    function _tagged_template_literal_loose(strings, raw) {
      if (!raw) raw = strings.slice(0);

      strings.raw = raw;

      return strings;
    }
  },
  5053: function (
    __unused_webpack___webpack_module__,
    __webpack_exports__,
    __webpack_require__
  ) {
    'use strict';
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      _: () => _interop_require_default,
    });
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  },
};
