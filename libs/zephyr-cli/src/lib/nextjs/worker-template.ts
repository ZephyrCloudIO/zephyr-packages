/**
 * Template for generating a Next.js worker entry point This worker handles routing for
 * deployed Next.js applications
 */

import { RouteInfo } from './types';

interface AssetManifest {
  [path: string]: {
    hash: string;
    contentType: string;
  };
}

/**
 * Generate the worker entry point code This creates a Cloudflare Worker that routes
 * requests to the appropriate Next.js handlers
 */
export function generateWorkerCode(
  routes: RouteInfo[],
  buildId: string,
  basePath: string = '',
  assetsManifest: AssetManifest = {},
  edgeFunctionChunks: Record<string, string[]> = {}
): string {
  // Serialize routes for the worker
  const routesJson = JSON.stringify(
    routes.map((route) => ({
      path: route.path,
      type: route.type,
      regex: route.regex,
      entryPoint: route.entryPoint,
      runtime: route.runtime,
      isDynamic: route.isDynamic,
      routeKeys: route.routeKeys,
    })),
    null,
    2
  );

  const assetsManifestJson = JSON.stringify(assetsManifest, null, 2);
  const edgeChunksJson = JSON.stringify(edgeFunctionChunks, null, 2);

  return `/**
 * Next.js Worker Entry Point
 * Generated by Zephyr CLI
 * Build ID: ${buildId}
 */

// Polyfills for Node.js compatibility in edge runtime
// Next.js/Turbopack edge runtime code expects these globals

// Minimal process global
if (typeof globalThis.process === 'undefined') {
  globalThis.process = {
    env: { NEXT_PHASE: 'phase-production-server', NODE_ENV: 'production' },
    nextTick: (fn, ...args) => queueMicrotask(() => fn(...args)),
  };
}

// Node.js built-in module stubs for edge runtime
// Turbopack tries to load these but they should be stubbed in edge runtime
const nodeBuiltins = {
  'node:buffer': { Buffer: globalThis.Buffer || class Buffer {} },
  'node:async_hooks': {
    AsyncLocalStorage: class AsyncLocalStorage {
      constructor() { this.store = undefined; }
      getStore() { return this.store; }
      run(store, fn, ...args) {
        const prev = this.store;
        this.store = store;
        try { return fn(...args); }
        finally { this.store = prev; }
      }
    }
  },
  'node:util': {
    types: {
      isProxy: () => false,
      isModuleNamespaceObject: () => false,
    }
  },
  'buffer': { Buffer: globalThis.Buffer || class Buffer {} },
  'async_hooks': {
    AsyncLocalStorage: class AsyncLocalStorage {
      constructor() { this.store = undefined; }
      getStore() { return this.store; }
      run(store, fn, ...args) {
        const prev = this.store;
        this.store = store;
        try { return fn(...args); }
        finally { this.store = prev; }
      }
    }
  },
};

// Synchronous require for Node.js built-ins
if (typeof globalThis.require === 'undefined') {
  globalThis.require = function(moduleName) {
    if (nodeBuiltins[moduleName]) {
      return nodeBuiltins[moduleName];
    }
    throw new Error(\`Module not found: '\${moduleName}' - Only Node.js built-in stubs are available in edge runtime\`);
  };
  // Make it look like a real require
  globalThis.require.resolve = (id) => id;
}

// Route definitions from Next.js build
const ROUTES = ${routesJson};
const BASE_PATH = ${JSON.stringify(basePath)};
const BUILD_ID = ${JSON.stringify(buildId)};
const ASSETS_MANIFEST = ${assetsManifestJson};
const EDGE_CHUNKS = ${edgeChunksJson};

/**
 * Main fetch handler for the worker
 */
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    let pathname = url.pathname;

    console.log('[NextJS Worker] Request:', request.method, pathname);

    // Remove base path if present
    if (BASE_PATH && pathname.startsWith(BASE_PATH)) {
      pathname = pathname.slice(BASE_PATH.length) || '/';
    }

    try {
      // 1. Check for static assets first (_next/static/*, public files)
      if (pathname.startsWith('/_next/static/')) {
        console.log('[NextJS Worker] Handling static asset:', pathname);
        return await handleStaticAsset(pathname, env);
      }

      // 2. Check for public files (e.g., /favicon.ico, /robots.txt, etc.)
      const publicAssetResponse = await handlePublicAsset(pathname, env);
      if (publicAssetResponse) {
        console.log('[NextJS Worker] Handling public asset:', pathname);
        return publicAssetResponse;
      }

      // 3. Match against Next.js routes
      for (const route of ROUTES) {
        const match = matchRoute(pathname, route);
        if (match) {
          console.log('[NextJS Worker] Route matched:', route.path, 'type:', route.type);
          return await handleRoute(request, route, match, pathname, env);
        }
      }

      // 4. No route matched - return 404
      console.log('[NextJS Worker] No route matched for:', pathname);
      return new Response('Not Found', {
        status: 404,
        headers: { 'Content-Type': 'text/plain' },
      });
    } catch (error) {
      console.error('[NextJS Worker] Error:', error);
      return new Response(
        JSON.stringify({
          error: 'Internal Server Error',
          message: error.message || 'Unknown error',
          stack: error.stack || 'No stack',
        }),
        {
          status: 500,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }
  },
};

/**
 * Create a mutable Request object
 * Next.js SSR sometimes tries to modify Request properties which are read-only by default
 */
function createMutableRequest(originalRequest) {
  // Create a storage for mutable properties
  const mutableProps = {
    url: originalRequest.url,
  };

  // Create a Proxy that allows property writes
  return new Proxy(originalRequest, {
    get(target, prop) {
      // Return mutable property if it exists in our storage
      if (prop in mutableProps) {
        return mutableProps[prop];
      }
      // Otherwise return from original request
      const value = target[prop];
      // Bind methods to the original request
      if (typeof value === 'function') {
        return value.bind(target);
      }
      return value;
    },
    set(target, prop, value) {
      // Allow setting any property by storing in mutableProps
      mutableProps[prop] = value;
      return true;
    },
    has(target, prop) {
      return prop in mutableProps || prop in target;
    },
    ownKeys(target) {
      return [...new Set([...Object.keys(mutableProps), ...Reflect.ownKeys(target)])];
    },
    getOwnPropertyDescriptor(target, prop) {
      if (prop in mutableProps) {
        return {
          configurable: true,
          enumerable: true,
          writable: true,
          value: mutableProps[prop]
        };
      }
      return Reflect.getOwnPropertyDescriptor(target, prop);
    }
  });
}

/**
 * Match a pathname against a route definition
 */
function matchRoute(pathname, route) {
  try {
    const regex = new RegExp(route.regex);
    const match = pathname.match(regex);

    if (!match) {
      return null;
    }

    // Extract params from dynamic routes
    const params = {};
    if (route.isDynamic && route.routeKeys) {
      Object.entries(route.routeKeys).forEach(([key, value]) => {
        const index = parseInt(value, 10);
        if (!isNaN(index) && match[index]) {
          params[key] = match[index];
        }
      });
    }

    return { params, matches: match };
  } catch (error) {
    console.error(\`[NextJS Worker] Error matching route \${route.path}:\`, error);
    return null;
  }
}

/**
 * Handle a matched route
 */
async function handleRoute(request, route, match, pathname, env) {
  const { type, entryPoint, runtime } = route;

  // For static HTML pages, serve the pre-rendered HTML
  if (type === 'static-html') {
    return await handleStaticHtml(route.path, pathname, env);
  }

  // For edge functions and serverless functions, load and execute the handler
  if (type === 'edge-function' || type === 'serverless-api' || type === 'serverless-ssr') {
    return await handleServerlessFunction(request, route, match);
  }

  // For ISR, serve cached HTML or regenerate
  if (type === 'isr') {
    return await handleISR(request, route, match);
  }

  // Unknown route type
  return new Response('Route type not implemented: ' + type, {
    status: 500,
    headers: { 'Content-Type': 'text/plain' },
  });
}

/**
 * Handle static HTML pages
 */
async function handleStaticHtml(routePath, pathname, env) {
  // Map route path to HTML file
  let htmlPath;
  if (routePath === '/') {
    htmlPath = 'client/index.html';
  } else {
    htmlPath = \`client\${routePath}.html\`;
  }

  console.log('[NextJS Worker] Fetching HTML:', htmlPath);

  // Fetch from snapshot assets
  const content = await fetchAsset(htmlPath, env);

  if (content) {
    return new Response(content, {
      status: 200,
      headers: {
        'Content-Type': 'text/html; charset=utf-8',
        'Cache-Control': 'public, max-age=0, must-revalidate',
      },
    });
  }

  console.log('[NextJS Worker] HTML file not found:', htmlPath);
  return new Response('HTML file not found: ' + htmlPath, {
    status: 404,
    headers: { 'Content-Type': 'text/plain' },
  });
}

/**
 * Handle serverless functions (API routes and SSR pages)
 */
async function handleServerlessFunction(request, route, match) {
  const { entryPoint, runtime, type } = route;

  if (!entryPoint) {
    return new Response('No entry point for route: ' + route.path, {
      status: 500,
      headers: { 'Content-Type': 'text/plain' },
    });
  }

  try {
    // Determine the module path based on runtime
    // The modules are uploaded with the structure: server/<type>/<route_dir>/<entryPoint>
    // This worker is at server/_worker.js, so paths are relative to server/
    const routeDir = route.path.replace(/^\\//, '').replace(/\\//g, '_') || 'root';
    let modulePath;

    if (runtime === 'edge') {
      // For Edge functions with Turbopack (Next.js 16+), we need to import all chunks
      // to initialize the _ENTRIES global properly
      const chunkDir = \`./edge/\${routeDir}\`;

      // Import all .js files in the edge function directory in order
      // This ensures TURBOPACK runtime is properly initialized
      try {
        // Get chunk files that need to be loaded for this route
        const chunkFiles = EDGE_CHUNKS[route.path] || [];

        console.log('[NextJS Worker] Loading edge chunks for', route.path, ':', chunkFiles);

        // Import all chunks in order
        // The chunks must be loaded in the correct order for Turbopack to work
        for (const chunkFile of chunkFiles) {
          const chunkPath = \`./edge/\${routeDir}/\${chunkFile}\`;
          console.log('[NextJS Worker] Loading chunk:', chunkPath);
          await import(chunkPath);
        }

        // After importing all chunks, check if _ENTRIES is populated
        if (globalThis._ENTRIES) {
          // Try different entry key formats that Turbopack uses
          // For SSR pages: look for /page suffix
          // For API routes: look for /route suffix
          const possibleKeys = [
            // Pages (SSR)
            \`middleware_app\${route.path}/page\`,
            \`app\${route.path}/page\`,
            // API Routes
            \`middleware_app\${route.path}/route\`,
            \`app\${route.path}/route\`,
            // Fallbacks
            \`middleware_app\${route.path}\`,
            \`app\${route.path}\`
          ];

          console.log('[NextJS Worker] Checking _ENTRIES:', {
            availableKeys: Object.keys(globalThis._ENTRIES),
            lookingFor: possibleKeys
          });

          for (const key of possibleKeys) {
            if (globalThis._ENTRIES[key]) {
              console.log('[NextJS Worker] Found handler in _ENTRIES:', key);
              const entryHandler = await globalThis._ENTRIES[key];
              const mutableRequest = createMutableRequest(request);

              console.log('[NextJS Worker] entryHandler structure:', {
                type: typeof entryHandler,
                isFunction: typeof entryHandler === 'function',
                hasDefault: !!entryHandler.default,
                defaultType: typeof entryHandler.default,
                keys: Object.keys(entryHandler),
                hasGET: !!entryHandler.GET,
                hasPOST: !!entryHandler.POST,
                hasComponentMod: !!entryHandler.ComponentMod,
                componentModType: typeof entryHandler.ComponentMod
              });

              // Check if ComponentMod has the actual handlers
              if (entryHandler.ComponentMod) {
                console.log('[NextJS Worker] ComponentMod structure:', {
                  type: typeof entryHandler.ComponentMod,
                  keys: Object.keys(entryHandler.ComponentMod),
                  hasGET: !!entryHandler.ComponentMod.GET,
                  hasPOST: !!entryHandler.ComponentMod.POST,
                  hasHandler: !!entryHandler.ComponentMod.handler,
                  handlerType: typeof entryHandler.ComponentMod.handler,
                  hasRouteModule: !!entryHandler.ComponentMod.routeModule,
                  routeModuleType: typeof entryHandler.ComponentMod.routeModule
                });

                // Check routeModule structure
                if (entryHandler.ComponentMod.routeModule) {
                  console.log('[NextJS Worker] routeModule structure:', {
                    type: typeof entryHandler.ComponentMod.routeModule,
                    keys: Object.keys(entryHandler.ComponentMod.routeModule),
                    hasUserland: !!entryHandler.ComponentMod.routeModule.userland,
                    userlandType: typeof entryHandler.ComponentMod.routeModule.userland
                  });

                  // Check userland
                  if (entryHandler.ComponentMod.routeModule.userland) {
                    console.log('[NextJS Worker] userland structure:', {
                      type: typeof entryHandler.ComponentMod.routeModule.userland,
                      keys: Object.keys(entryHandler.ComponentMod.routeModule.userland),
                      hasGET: !!entryHandler.ComponentMod.routeModule.userland.GET,
                      hasPOST: !!entryHandler.ComponentMod.routeModule.userland.POST
                    });
                  }
                }
              }

              console.log('[NextJS Worker] Request object:', {
                type: typeof request,
                hasUrl: !!request.url,
                url: request.url,
                method: request.method,
                constructor: request.constructor?.name
              });

              // Create context object for Next.js route handlers
              // Next.js route handlers expect (request, context) where context = { params }
              const context = {
                params: match.params || {}
              };

              const method = request.method;

              // For SSR pages, try the render path first
              if (type === 'serverless-ssr') {
                // Create a mutable Request-like object for SSR pages
                // Next.js SSR sometimes tries to modify Request properties like 'url'

                // Try routeModule.handle (Next.js 16 Turbopack structure for pages)
                if (entryHandler.ComponentMod?.routeModule?.handle && typeof entryHandler.ComponentMod.routeModule.handle === 'function') {
                  console.log('[NextJS Worker] Calling routeModule.handle for SSR page');
                  return await entryHandler.ComponentMod.routeModule.handle(mutableRequest, context);
                }

                // Try routeModule.render
                if (entryHandler.ComponentMod?.routeModule?.render && typeof entryHandler.ComponentMod.routeModule.render === 'function') {
                  console.log('[NextJS Worker] Calling routeModule.render for SSR page');
                  return await entryHandler.ComponentMod.routeModule.render(mutableRequest, context);
                }

                // Try calling routeModule as a function
                if (typeof entryHandler.ComponentMod?.routeModule === 'function') {
                  console.log('[NextJS Worker] Calling routeModule as function for SSR page');
                  return await entryHandler.ComponentMod.routeModule(mutableRequest, context);
                }
              }

              // Try ComponentMod.routeModule.userland (Next.js 16 Turbopack structure for API routes)
              if (entryHandler.ComponentMod?.routeModule?.userland) {
                const userland = entryHandler.ComponentMod.routeModule.userland;
                if (userland[method] && typeof userland[method] === 'function') {
                  console.log('[NextJS Worker] Calling method from userland:', method);
                  return await userland[method](mutableRequest, context);
                }
              }

              // Try ComponentMod.handler (might be a general handler)
              if (entryHandler.ComponentMod?.handler && typeof entryHandler.ComponentMod.handler === 'function') {
                console.log('[NextJS Worker] Calling ComponentMod.handler');
                return await entryHandler.ComponentMod.handler(mutableRequest, context);
              }

              // Try ComponentMod directly
              if (entryHandler.ComponentMod) {
                if (entryHandler.ComponentMod[method] && typeof entryHandler.ComponentMod[method] === 'function') {
                  console.log('[NextJS Worker] Calling method from ComponentMod:', method);
                  return await entryHandler.ComponentMod[method](mutableRequest, context);
                }
              }

              // Try calling the method directly
              if (entryHandler[method] && typeof entryHandler[method] === 'function') {
                console.log('[NextJS Worker] Calling method from _ENTRIES:', method);
                return await entryHandler[method](mutableRequest, context);
              }

              // Try default export
              if (entryHandler.default && typeof entryHandler.default === 'function') {
                console.log('[NextJS Worker] Calling default from _ENTRIES');
                return await entryHandler.default(mutableRequest, context);
              }

              // Maybe entryHandler itself is the function?
              if (typeof entryHandler === 'function') {
                console.log('[NextJS Worker] Calling entryHandler directly as function');
                return await entryHandler(mutableRequest, context);
              }
            }
          }
        }
      } catch (importError) {
        console.error('[NextJS Worker] Error importing edge function:', importError);
        throw importError;
      }

      modulePath = \`./edge/\${routeDir}/\${entryPoint}\`;
    } else {
      // Serverless functions are in server/serverless/<route>/
      modulePath = \`./serverless/\${routeDir}/\${entryPoint}\`;
    }

    console.log('[NextJS Worker] Attempting to import handler:', modulePath);

    // Import the handler module
    const handler = await import(modulePath);

    console.log('[NextJS Worker] Handler imported:', {
      hasDefault: !!handler.default,
      keys: Object.keys(handler),
      hasEntries: !!globalThis._ENTRIES
    });

    // Fallback to traditional handler resolution
    // Call the handler
    // Next.js API routes and route handlers export default functions
    if (handler.default && typeof handler.default === 'function') {
      return await handler.default(request);
    }

    // For App Router route handlers, check for named exports (GET, POST, etc.)
    const method = request.method;
    if (handler[method] && typeof handler[method] === 'function') {
      return await handler[method](request);
    }

    return new Response('No handler found for method: ' + method, {
      status: 405,
      headers: {
        'Content-Type': 'text/plain',
        'Allow': Object.keys(handler).filter(k => ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'].includes(k)).join(', ')
      },
    });
  } catch (error) {
    console.error(\`[NextJS Worker] Error executing handler for \${route.path}:\`, error);
    return new Response(
      JSON.stringify({
        error: 'Handler execution failed',
        message: error.message || 'Unknown error',
        route: route.path,
        stack: error.stack || 'No stack trace available',
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  }
}

/**
 * Handle ISR (Incremental Static Regeneration) routes
 * TODO: Implement caching and revalidation logic
 */
async function handleISR(request, route, match) {
  // For now, treat ISR like serverless SSR
  // In the future, we should implement proper caching with KV or Cache API
  return await handleServerlessFunction(request, route, match);
}

/**
 * Handle static assets from _next/static/
 */
async function handleStaticAsset(pathname, env) {
  // Remove leading slash for asset lookup
  const assetPath = \`client\${pathname}\`;
  const content = await fetchAsset(assetPath, env);

  if (content) {
    return new Response(content, {
      status: 200,
      headers: {
        'Content-Type': getContentType(pathname),
        'Cache-Control': 'public, max-age=31536000, immutable',
      },
    });
  }

  console.log('[NextJS Worker] Asset not found:', assetPath);
  return new Response('Asset not found', {
    status: 404,
    headers: { 'Content-Type': 'text/plain' },
  });
}

/**
 * Handle public assets (favicon.ico, robots.txt, etc.)
 */
async function handlePublicAsset(pathname, env) {
  // Common public files
  const publicFiles = [
    'favicon.ico',
    'robots.txt',
    'sitemap.xml',
    'manifest.json',
    'next.svg',
    'vercel.svg',
  ];

  const filename = pathname.slice(1); // Remove leading slash
  if (publicFiles.includes(filename)) {
    const assetPath = \`client\${pathname}\`;
    const content = await fetchAsset(assetPath, env);

    if (content) {
      return new Response(content, {
        status: 200,
        headers: {
          'Content-Type': getContentType(pathname),
          'Cache-Control': 'public, max-age=3600',
        },
      });
    }
  }

  return null;
}

/**
 * Fetch an asset from the snapshot using KV
 */
async function fetchAsset(path, env) {
  // Check if asset exists in manifest
  const assetInfo = ASSETS_MANIFEST[path];
  if (!assetInfo) {
    console.log('[NextJS Worker] Asset not in manifest:', path);
    return null;
  }

  // Get application UID from env
  const appUid = env.APP_UID;
  if (!appUid) {
    console.error('[NextJS Worker] APP_UID not found in env');
    return null;
  }

  // Get ze_files KV namespace
  const kvNamespace = env.ze_files;
  if (!kvNamespace) {
    console.error('[NextJS Worker] ze_files KV namespace not found in env');
    return null;
  }

  // Construct KV key: application_uid:hash
  const fileKey = \`\${appUid}:\${assetInfo.hash}\`;

  try {
    // Fetch content from KV
    // For binary files, use 'arrayBuffer', for text files use 'text'
    const contentType = assetInfo.contentType || getContentType(path);
    const isBinary = contentType.startsWith('image/') ||
                     contentType.startsWith('font/') ||
                     contentType === 'application/octet-stream';

    const content = await kvNamespace.get(fileKey, isBinary ? 'arrayBuffer' : 'text');

    if (!content) {
      console.log('[NextJS Worker] Content not found in KV:', fileKey);
      return null;
    }

    return content;
  } catch (error) {
    console.error(\`[NextJS Worker] Error fetching asset \${path}:\`, error);
    return null;
  }
}

/**
 * Get content type based on file extension
 */
function getContentType(pathname) {
  const ext = pathname.split('.').pop()?.toLowerCase();

  const types = {
    html: 'text/html; charset=utf-8',
    css: 'text/css',
    js: 'application/javascript',
    mjs: 'application/javascript',
    json: 'application/json',
    png: 'image/png',
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    gif: 'image/gif',
    svg: 'image/svg+xml',
    ico: 'image/x-icon',
    woff: 'font/woff',
    woff2: 'font/woff2',
    ttf: 'font/ttf',
    webp: 'image/webp',
    avif: 'image/avif',
    txt: 'text/plain',
  };

  return types[ext] || 'application/octet-stream';
}
`;
}
