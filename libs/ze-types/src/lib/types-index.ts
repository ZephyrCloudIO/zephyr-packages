import path from 'node:path';
import { mkdir, readdir, writeFile } from 'node:fs/promises';
import { existsSync } from 'node:fs';

const SKIP_DIRS = new Set(['compiled-types', 'node_modules']);

async function collectEntryTypeFiles(
  baseDir: string,
  currentDir: string,
  out: string[]
): Promise<void> {
  const entries = await readdir(currentDir, { withFileTypes: true });
  await Promise.all(
    entries.map(async (entry) => {
      const fullPath = path.join(currentDir, entry.name);
      if (entry.isDirectory()) {
        if (SKIP_DIRS.has(entry.name)) {
          return;
        }
        await collectEntryTypeFiles(baseDir, fullPath, out);
        return;
      }
      if (!entry.isFile()) {
        return;
      }
      if (!entry.name.endsWith('.d.ts')) {
        return;
      }
      if (entry.name === 'apis.d.ts') {
        return;
      }
      const rel = path.relative(baseDir, fullPath).replace(/\.d\.ts$/, '');
      const normalized = rel.split(path.sep).join('/');
      out.push(normalized);
    })
  );
}

export async function writeTypesIndex(options: {
  typesRoot: string;
  remotes: string[];
  sourceUrls: string[];
}): Promise<void> {
  const { typesRoot, remotes, sourceUrls } = options;
  await mkdir(typesRoot, { recursive: true });

  const moduleMap = new Map<string, string>();
  const fallbackModules: string[] = [];

  for (const remote of remotes.sort()) {
    const remoteDir = path.join(typesRoot, remote);
    if (!existsSync(remoteDir)) {
      fallbackModules.push(remote);
      continue;
    }

    const entryFiles: string[] = [];
    await collectEntryTypeFiles(remoteDir, remoteDir, entryFiles);

    if (!entryFiles.length) {
      fallbackModules.push(remote);
      continue;
    }

    for (const entryPath of entryFiles.sort()) {
      const typePath = `./${remote}/${entryPath}`;
      if (entryPath === 'index') {
        moduleMap.set(remote, typePath);
        moduleMap.set(`${remote}/index`, typePath);
        continue;
      }
      if (entryPath.endsWith('/index')) {
        const base = entryPath.slice(0, -'/index'.length);
        moduleMap.set(`${remote}/${base}`, typePath);
        moduleMap.set(`${remote}/${base}/index`, typePath);
        continue;
      }
      moduleMap.set(`${remote}/${entryPath}`, typePath);
    }
  }

  const lines: string[] = [
    '/* eslint-disable */',
    '// Auto-generated by ze-types. DO NOT EDIT.',
  ];
  if (sourceUrls.length) {
    lines.push(`// Source: ${sourceUrls.join(', ')}`);
  }
  lines.push('/// <reference path="./index.d.ts" />', '');

  const moduleNames = Array.from(moduleMap.keys()).sort();
  for (const moduleName of moduleNames) {
    const typePath = moduleMap.get(moduleName);
    if (!typePath) continue;
    lines.push(
      `declare module '${moduleName}' {`,
      `  export * from '${typePath}';`,
      `  export { default } from '${typePath}';`,
      `}`,
      ''
    );
  }

  if (fallbackModules.length) {
    lines.push('// Fallbacks');
    for (const remote of fallbackModules.sort()) {
      lines.push(
        `declare module '${remote}/*' {`,
        '  const mod: any;',
        '  export = mod;',
        '}',
        ''
      );
    }
  }

  lines.push('export {};');

  const outputPath = path.join(typesRoot, 'ze-types.d.ts');
  await writeFile(outputPath, lines.join('\n'), 'utf8');
}
